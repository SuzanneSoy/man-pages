
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Stdlib.Array</TITLE>
</HEAD><BODY>
<H1>Stdlib.Array</H1>
Section: OCaml library (3o)<BR>Updated: 2020-01-30<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Stdlib.Array - no description
<A NAME="lbAC">&nbsp;</A>
<H2>Module</H2>

Module   Stdlib.Array
<A NAME="lbAD">&nbsp;</A>
<H2>Documentation</H2>

<P>
Module
<B>Array</B>

<BR>&nbsp;:&nbsp;
<B>(module Stdlib__array)</B>

<P>
<P>
<P>
<P>
<P>
<P>
<P>
<I>type </I>

<B>'a</B>

<I>t </I>

= 
<B>'a array</B>

<P>
<P>
An alias for the type of arrays.
<P>
<P>
<P>
<P>

Array operations.
<P>

<P>
<I>val length </I>

: 
<B>'a array -&gt; int</B>

<P>
Return the length (number of elements) of the given array.
<P>
<P>
<P>
<I>val get </I>

: 
<B>'a array -&gt; int -&gt; 'a</B>

<P>
<P>
<B>Array.get a n</B>

returns the element number 
<B>n</B>

of array 
<B>a</B>

.
The first element has number 0.
The last element has number 
<B>Array.length a - 1</B>

.
You can also write 
<B>a.(n)</B>

instead of 
<B>Array.get a n</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n</B>

is outside the range 0 to 
<B>(Array.length a - 1)</B>

.
<P>
<P>
<P>
<I>val set </I>

: 
<B>'a array -&gt; int -&gt; 'a -&gt; unit</B>

<P>
<P>
<B>Array.set a n x</B>

modifies array 
<B>a</B>

in place, replacing
element number 
<B>n</B>

with 
<B>x</B>

.
You can also write 
<B>a.(n) &lt;- x</B>

instead of 
<B>Array.set a n x</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n</B>

is outside the range 0 to 
<B>Array.length a - 1</B>

.
<P>
<P>
<P>
<I>val make </I>

: 
<B>int -&gt; 'a -&gt; 'a array</B>

<P>
<P>
<B>Array.make n x</B>

returns a fresh array of length 
<B>n</B>

,
initialized with 
<B>x</B>

.
All the elements of this new array are initially
physically equal to 
<B>x</B>

(in the sense of the 
<B>==</B>

predicate).
Consequently, if 
<B>x</B>

is mutable, it is shared among all elements
of the array, and modifying 
<B>x</B>

through one of the array entries
will modify all other entries at the same time.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n &lt; 0</B>

or 
<B>n &gt; Sys.max_array_length</B>

.
If the value of 
<B>x</B>

is a floating-point number, then the maximum
size is only 
<B>Sys.max_array_length / 2</B>

.
<P>
<P>
<P>
<I>val create </I>

: 
<B>int -&gt; 'a -&gt; 'a array</B>

<P>
<B>Deprecated.</B>

<P>
<B>Array.create</B>

is an alias for 
<B>Array.make</B>

.
<P>
<P>
<P>
<I>val create_float </I>

: 
<B>int -&gt; float array</B>

<P>
<P>
<B>Array.create_float n</B>

returns a fresh float array of length 
<B>n</B>

,
with uninitialized data.
<P>
<P>
<B>Since</B>

4.03
<P>
<P>
<P>
<I>val make_float </I>

: 
<B>int -&gt; float array</B>

<P>
<B>Deprecated.</B>

<P>
<B>Array.make_float</B>

is an alias for 
<B>Array.create_float</B>

.
<P>
<P>
<P>
<I>val init </I>

: 
<B>int -&gt; (int -&gt; 'a) -&gt; 'a array</B>

<P>
<P>
<B>Array.init n f</B>

returns a fresh array of length 
<B>n</B>

,
with element number 
<B>i</B>

initialized to the result of 
<B>f i</B>

.
In other terms, 
<B>Array.init n f</B>

tabulates the results of 
<B>f</B>

applied to the integers 
<B>0</B>

to 
<B>n-1</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n &lt; 0</B>

or 
<B>n &gt; Sys.max_array_length</B>

.
If the return type of 
<B>f</B>

is 
<B>float</B>

, then the maximum
size is only 
<B>Sys.max_array_length / 2</B>

.
<P>
<P>
<P>
<I>val make_matrix </I>

: 
<B>int -&gt; int -&gt; 'a -&gt; 'a array array</B>

<P>
<P>
<B>Array.make_matrix dimx dimy e</B>

returns a two-dimensional array
(an array of arrays) with first dimension 
<B>dimx</B>

and
second dimension 
<B>dimy</B>

. All the elements of this new matrix
are initially physically equal to 
<B>e</B>

.
The element (
<B>x,y</B>

) of a matrix 
<B>m</B>

is accessed
with the notation 
<B>m.(x).(y)</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>dimx</B>

or 
<B>dimy</B>

is negative or
greater than 
<B>Sys.max_array_length</B>

.
If the value of 
<B>e</B>

is a floating-point number, then the maximum
size is only 
<B>Sys.max_array_length / 2</B>

.
<P>
<P>
<P>
<I>val create_matrix </I>

: 
<B>int -&gt; int -&gt; 'a -&gt; 'a array array</B>

<P>
<B>Deprecated.</B>

<P>
<B>Array.create_matrix</B>

is an alias for 
<B>Array.make_matrix</B>

.
<P>
<P>
<P>
<I>val append </I>

: 
<B>'a array -&gt; 'a array -&gt; 'a array</B>

<P>
<P>
<B>Array.append v1 v2</B>

returns a fresh array containing the
concatenation of the arrays 
<B>v1</B>

and 
<B>v2</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if
<B>Array.length v1 + Array.length v2 &gt; Sys.max_array_length</B>

.
<P>
<P>
<P>
<I>val concat </I>

: 
<B>'a array list -&gt; 'a array</B>

<P>
Same as 
<B>Array.append</B>

, but concatenates a list of arrays.
<P>
<P>
<P>
<I>val sub </I>

: 
<B>'a array -&gt; int -&gt; int -&gt; 'a array</B>

<P>
<P>
<B>Array.sub a start len</B>

returns a fresh array of length 
<B>len</B>

,
containing the elements number 
<B>start</B>

to 
<B>start + len - 1</B>

of array 
<B>a</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>start</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>a</B>

; that is, if
<B>start &lt; 0</B>

, or 
<B>len &lt; 0</B>

, or 
<B>start + len &gt; Array.length a</B>

.
<P>
<P>
<P>
<I>val copy </I>

: 
<B>'a array -&gt; 'a array</B>

<P>
<P>
<B>Array.copy a</B>

returns a copy of 
<B>a</B>

, that is, a fresh array
containing the same elements as 
<B>a</B>

.
<P>
<P>
<P>
<I>val fill </I>

: 
<B>'a array -&gt; int -&gt; int -&gt; 'a -&gt; unit</B>

<P>
<P>
<B>Array.fill a ofs len x</B>

modifies the array 
<B>a</B>

in place,
storing 
<B>x</B>

in elements number 
<B>ofs</B>

to 
<B>ofs + len - 1</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>ofs</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>a</B>

.
<P>
<P>
<P>
<I>val blit </I>

: 
<B>'a array -&gt; int -&gt; 'a array -&gt; int -&gt; int -&gt; unit</B>

<P>
<P>
<B>Array.blit v1 o1 v2 o2 len</B>

copies 
<B>len</B>

elements
from array 
<B>v1</B>

, starting at element number 
<B>o1</B>

, to array 
<B>v2</B>

,
starting at element number 
<B>o2</B>

. It works correctly even if
<B>v1</B>

and 
<B>v2</B>

are the same array, and the source and
destination chunks overlap.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>o1</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>v1</B>

, or if 
<B>o2</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>v2</B>

.
<P>
<P>
<P>
<I>val to_list </I>

: 
<B>'a array -&gt; 'a list</B>

<P>
<P>
<B>Array.to_list a</B>

returns the list of all the elements of 
<B>a</B>

.
<P>
<P>
<P>
<I>val of_list </I>

: 
<B>'a list -&gt; 'a array</B>

<P>
<P>
<B>Array.of_list l</B>

returns a fresh array containing the elements
of 
<B>l</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if the length of 
<B>l</B>

is greater than
<B>Sys.max_array_length</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAE">&nbsp;</A>
<H3>Iterators</H3>

<P>
<P>

<P>
<I>val iter </I>

: 
<B>('a -&gt; unit) -&gt; 'a array -&gt; unit</B>

<P>
<P>
<B>Array.iter f a</B>

applies function 
<B>f</B>

in turn to all
the elements of 
<B>a</B>

.  It is equivalent to
<B>f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()</B>

.
<P>
<P>
<P>
<I>val iteri </I>

: 
<B>(int -&gt; 'a -&gt; unit) -&gt; 'a array -&gt; unit</B>

<P>
Same as 
<B>Array.iter</B>

, but the
function is applied with the index of the element as first argument,
and the element itself as second argument.
<P>
<P>
<P>
<I>val map </I>

: 
<B>('a -&gt; 'b) -&gt; 'a array -&gt; 'b array</B>

<P>
<P>
<B>Array.map f a</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

,
and builds an array with the results returned by 
<B>f</B>

:
<B>[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]</B>

.
<P>
<P>
<P>
<I>val mapi </I>

: 
<B>(int -&gt; 'a -&gt; 'b) -&gt; 'a array -&gt; 'b array</B>

<P>
Same as 
<B>Array.map</B>

, but the
function is applied to the index of the element as first argument,
and the element itself as second argument.
<P>
<P>
<P>
<I>val fold_left </I>

: 
<B>('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b array -&gt; 'a</B>

<P>
<P>
<B>Array.fold_left f x a</B>

computes
<B>f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)</B>

,
where 
<B>n</B>

is the length of the array 
<B>a</B>

.
<P>
<P>
<P>
<I>val fold_right </I>

: 
<B>('b -&gt; 'a -&gt; 'a) -&gt; 'b array -&gt; 'a -&gt; 'a</B>

<P>
<P>
<B>Array.fold_right f a x</B>

computes
<B>f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))</B>

,
where 
<B>n</B>

is the length of the array 
<B>a</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAF">&nbsp;</A>
<H3>Iterators on two arrays</H3>

<P>
<P>

<P>
<I>val iter2 </I>

: 
<B>('a -&gt; 'b -&gt; unit) -&gt; 'a array -&gt; 'b array -&gt; unit</B>

<P>
<P>
<B>Array.iter2 f a b</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

and 
<B>b</B>

.
Raise 
<B>Invalid_argument</B>

if the arrays are not the same size.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val map2 </I>

: 
<B>('a -&gt; 'b -&gt; 'c) -&gt; 'a array -&gt; 'b array -&gt; 'c array</B>

<P>
<P>
<B>Array.map2 f a b</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

and 
<B>b</B>

, and builds an array with the results returned by 
<B>f</B>

:
<B>[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]</B>

.
Raise 
<B>Invalid_argument</B>

if the arrays are not the same size.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<P>

<A NAME="lbAG">&nbsp;</A>
<H3>Array scanning</H3>

<P>
<P>

<P>
<I>val for_all </I>

: 
<B>('a -&gt; bool) -&gt; 'a array -&gt; bool</B>

<P>
<P>
<B>Array.for_all p [|a1; ...; an|]</B>

checks if all elements of the array
satisfy the predicate 
<B>p</B>

. That is, it returns
<B>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</B>

.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val exists </I>

: 
<B>('a -&gt; bool) -&gt; 'a array -&gt; bool</B>

<P>
<P>
<B>Array.exists p [|a1; ...; an|]</B>

checks if at least one element of
the array satisfies the predicate 
<B>p</B>

. That is, it returns
<B>(p a1) || (p a2) || ... || (p an)</B>

.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val mem </I>

: 
<B>'a -&gt; 'a array -&gt; bool</B>

<P>
<P>
<B>mem a l</B>

is true if and only if 
<B>a</B>

is structurally equal
to an element of 
<B>l</B>

(i.e. there is an 
<B>x</B>

in 
<B>l</B>

such that
<B>compare a x = 0</B>

).
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val memq </I>

: 
<B>'a -&gt; 'a array -&gt; bool</B>

<P>
Same as 
<B>Array.mem</B>

, but uses physical equality instead of structural
equality to compare elements.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<P>

<A NAME="lbAH">&nbsp;</A>
<H3>Sorting</H3>

<P>
<P>

<P>
<I>val sort </I>

: 
<B>('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</B>

<P>
Sort an array in increasing order according to a comparison
function.  The comparison function must return 0 if its arguments
compare as equal, a positive integer if the first is greater,
and a negative integer if the first is smaller (see below for a
complete specification).  For example, 
<B>compare</B>

is
a suitable comparison function.  After calling 
<B>Array.sort</B>

, the
array is sorted in place in increasing order.
<B>Array.sort</B>

is guaranteed to run in constant heap space
and (at most) logarithmic stack space.
<P>
The current implementation uses Heap Sort.  It runs in constant
stack space.
<P>
Specification of the comparison function:
Let 
<B>a</B>

be the array and 
<B>cmp</B>

the comparison function.  The following
must be true for all 
<B>x</B>

, 
<B>y</B>

, 
<B>z</B>

in 
<B>a</B>

:
<P>
-  
<B>cmp x y</B>

&gt; 0 if and only if 
<B>cmp y x</B>

&lt; 0
<P>
-  if 
<B>cmp x y</B>

&gt;= 0 and 
<B>cmp y z</B>

&gt;= 0 then 
<B>cmp x z</B>

&gt;= 0
<P>
When 
<B>Array.sort</B>

returns, 
<B>a</B>

contains the same elements as before,
reordered in such a way that for all i and j valid indices of 
<B>a</B>

:
<P>
-  
<B>cmp a.(i) a.(j)</B>

&gt;= 0 if and only if i &gt;= j
<P>
<P>
<P>
<P>
<I>val stable_sort </I>

: 
<B>('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</B>

<P>
Same as 
<B>Array.sort</B>

, but the sorting algorithm is stable (i.e.
elements that compare equal are kept in their original order) and
not guaranteed to run in constant heap space.
<P>
The current implementation uses Merge Sort. It uses a temporary
array of length 
<B>n/2</B>

, where 
<B>n</B>

is the length of the array.
It is usually faster than the current implementation of 
<B>Array.sort</B>

.
<P>
<P>
<P>
<I>val fast_sort </I>

: 
<B>('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</B>

<P>
Same as 
<B>Array.sort</B>

or 
<B>Array.stable_sort</B>

, whichever is faster
on typical input.
<P>
<P>
<P>
<P>

<A NAME="lbAI">&nbsp;</A>
<H3>Iterators</H3>

<P>
<P>

<P>
<I>val to_seq </I>

: 
<B>'a array -&gt; 'a Seq.t</B>

<P>
Iterate on the array, in increasing order. Modifications of the
array during iteration will be reflected in the iterator.
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>
<I>val to_seqi </I>

: 
<B>'a array -&gt; (int * 'a) Seq.t</B>

<P>
Iterate on the array, in increasing order, yielding indices along elements.
Modifications of the array during iteration will be reflected in the
iterator.
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>
<I>val of_seq </I>

: 
<B>'a Seq.t -&gt; 'a array</B>

<P>
Create an array from the generator
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">Module</A><DD>
<DT id="3"><A HREF="#lbAD">Documentation</A><DD>
<DL>
<DT id="4"><A HREF="#lbAE">Iterators</A><DD>
<DT id="5"><A HREF="#lbAF">Iterators on two arrays</A><DD>
<DT id="6"><A HREF="#lbAG">Array scanning</A><DD>
<DT id="7"><A HREF="#lbAH">Sorting</A><DD>
<DT id="8"><A HREF="#lbAI">Iterators</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:57 GMT, March 31, 2021
</BODY>
</HTML>
