
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of PCRE2API</TITLE>
</HEAD><BODY>
<H1>PCRE2API</H1>
Section: C Library Functions (3)<BR>Updated: 02 September 2019<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

PCRE2 - Perl-compatible regular expressions (revised API)
<P>
<B>#include &lt;<A HREF="file:///usr/include/pcre2.h">pcre2.h</A>&gt;</B>

<P>
PCRE2 is a new API for PCRE, starting at release 10.0. This document contains a
description of all its native functions. See the

<B>pcre2</B>

document for an overview of all the PCRE2 documentation.
<A NAME="lbAC">&nbsp;</A>
<H2>PCRE2 NATIVE API BASIC FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_code *pcre2_compile(PCRE2_SPTR </B><I>pattern</I>, PCRE2_SIZE <I>length</I>,
<B>  uint32_t </B><I>options</I>, int *<I>errorcode</I>, PCRE2_SIZE *<I>erroroffset,</I>
<B>  pcre2_compile_context *</B><I>ccontext</I>);

<B>void pcre2_code_free(pcre2_code *</B><I>code</I>);

<B>pcre2_match_data *pcre2_match_data_create(uint32_t </B><I>ovecsize</I>,
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_match_data *pcre2_match_data_create_from_pattern(</B>
<B>  const pcre2_code *</B><I>code</I>, pcre2_general_context *<I>gcontext</I>);

<B>int pcre2_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>);

<B>int pcre2_dfa_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>,
<B>  int *</B><I>workspace</I>, PCRE2_SIZE <I>wscount</I>);

<B>void pcre2_match_data_free(pcre2_match_data *</B><I>match_data</I>);
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>PCRE2 NATIVE API AUXILIARY MATCH FUNCTIONS</H2>


<P>
<PRE>
<B>PCRE2_SPTR pcre2_get_mark(pcre2_match_data *</B><I>match_data</I>);

<B>uint32_t pcre2_get_ovector_count(pcre2_match_data *</B><I>match_data</I>);

<B>PCRE2_SIZE *pcre2_get_ovector_pointer(pcre2_match_data *</B><I>match_data</I>);

<B>PCRE2_SIZE pcre2_get_startchar(pcre2_match_data *</B><I>match_data</I>);
</PRE>

<A NAME="lbAE">&nbsp;</A>
<H2>PCRE2 NATIVE API GENERAL CONTEXT FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_general_context *pcre2_general_context_create(</B>
<B>  void *(*</B><I>private_malloc</I>)(PCRE2_SIZE, void *),
<B>  void (*</B><I>private_free</I>)(void *, void *), void *<I>memory_data</I>);

<B>pcre2_general_context *pcre2_general_context_copy(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>void pcre2_general_context_free(pcre2_general_context *</B><I>gcontext</I>);
</PRE>

<A NAME="lbAF">&nbsp;</A>
<H2>PCRE2 NATIVE API COMPILE CONTEXT FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_compile_context *pcre2_compile_context_create(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_compile_context *pcre2_compile_context_copy(</B>
<B>  pcre2_compile_context *</B><I>ccontext</I>);

<B>void pcre2_compile_context_free(pcre2_compile_context *</B><I>ccontext</I>);

<B>int pcre2_set_bsr(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_character_tables(pcre2_compile_context *</B><I>ccontext</I>,
<B>  const uint8_t *</B><I>tables</I>);

<B>int pcre2_set_compile_extra_options(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>extra_options</I>);

<B>int pcre2_set_max_pattern_length(pcre2_compile_context *</B><I>ccontext</I>,
<B>  PCRE2_SIZE </B><I>value</I>);

<B>int pcre2_set_newline(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_parens_nest_limit(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_compile_recursion_guard(pcre2_compile_context *</B><I>ccontext</I>,
<B>  int (*</B><I>guard_function</I>)(uint32_t, void *), void *<I>user_data</I>);
</PRE>

<A NAME="lbAG">&nbsp;</A>
<H2>PCRE2 NATIVE API MATCH CONTEXT FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_match_context *pcre2_match_context_create(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_match_context *pcre2_match_context_copy(</B>
<B>  pcre2_match_context *</B><I>mcontext</I>);

<B>void pcre2_match_context_free(pcre2_match_context *</B><I>mcontext</I>);

<B>int pcre2_set_callout(pcre2_match_context *</B><I>mcontext</I>,
<B>  int (*</B><I>callout_function</I>)(pcre2_callout_block *, void *),
<B>  void *</B><I>callout_data</I>);

<B>int pcre2_set_substitute_callout(pcre2_match_context *</B><I>mcontext</I>,
<B>  int (*</B><I>callout_function</I>)(pcre2_substitute_callout_block *, void *),
<B>  void *</B><I>callout_data</I>);

<B>int pcre2_set_offset_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  PCRE2_SIZE </B><I>value</I>);

<B>int pcre2_set_heap_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_match_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_depth_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<A NAME="lbAH">&nbsp;</A>
<H2>PCRE2 NATIVE API STRING EXTRACTION FUNCTIONS</H2>


<P>
<PRE>
<B>int pcre2_substring_copy_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_UCHAR *<I>buffer</I>, PCRE2_SIZE *<I>bufflen</I>);

<B>int pcre2_substring_copy_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_UCHAR *<I>buffer</I>,
<B>  PCRE2_SIZE *</B><I>bufflen</I>);

<B>void pcre2_substring_free(PCRE2_UCHAR *</B><I>buffer</I>);

<B>int pcre2_substring_get_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_UCHAR **<I>bufferptr</I>, PCRE2_SIZE *<I>bufflen</I>);

<B>int pcre2_substring_get_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_UCHAR **<I>bufferptr</I>,
<B>  PCRE2_SIZE *</B><I>bufflen</I>);

<B>int pcre2_substring_length_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_SIZE *<I>length</I>);

<B>int pcre2_substring_length_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_SIZE *<I>length</I>);

<B>int pcre2_substring_nametable_scan(const pcre2_code *</B><I>code</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_SPTR *<I>first</I>, PCRE2_SPTR *<I>last</I>);

<B>int pcre2_substring_number_from_name(const pcre2_code *</B><I>code</I>,
<B>  PCRE2_SPTR </B><I>name</I>);

<B>void pcre2_substring_list_free(PCRE2_SPTR *</B><I>list</I>);

<B>int pcre2_substring_list_get(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_UCHAR ***</B><I>listptr</I>, PCRE2_SIZE **<I>lengthsptr</I>);
</PRE>

<A NAME="lbAI">&nbsp;</A>
<H2>PCRE2 NATIVE API STRING SUBSTITUTION FUNCTION</H2>


<P>
<PRE>
<B>int pcre2_substitute(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>, PCRE2_SPTR <I>replacementzfP,</I>
<B>  PCRE2_SIZE </B><I>rlength</I>, PCRE2_UCHAR *<I>outputbuffer</I>,
<B>  PCRE2_SIZE *</B><I>outlengthptr</I>);
</PRE>

<A NAME="lbAJ">&nbsp;</A>
<H2>PCRE2 NATIVE API JIT FUNCTIONS</H2>


<P>
<PRE>
<B>int pcre2_jit_compile(pcre2_code *</B><I>code</I>, uint32_t <I>options</I>);

<B>int pcre2_jit_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>);

<B>void pcre2_jit_free_unused_memory(pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_jit_stack *pcre2_jit_stack_create(PCRE2_SIZE </B><I>startsize</I>,
<B>  PCRE2_SIZE </B><I>maxsize</I>, pcre2_general_context *<I>gcontext</I>);

<B>void pcre2_jit_stack_assign(pcre2_match_context *</B><I>mcontext</I>,
<B>  pcre2_jit_callback </B><I>callback_function</I>, void *<I>callback_data</I>);

<B>void pcre2_jit_stack_free(pcre2_jit_stack *</B><I>jit_stack</I>);
</PRE>

<A NAME="lbAK">&nbsp;</A>
<H2>PCRE2 NATIVE API SERIALIZATION FUNCTIONS</H2>


<P>
<PRE>
<B>int32_t pcre2_serialize_decode(pcre2_code **</B><I>codes</I>,
<B>  int32_t </B><I>number_of_codes</I>, const uint8_t *<I>bytes</I>,
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>int32_t pcre2_serialize_encode(const pcre2_code **</B><I>codes</I>,
<B>  int32_t </B><I>number_of_codes</I>, uint8_t **<I>serialized_bytes</I>,
<B>  PCRE2_SIZE *</B><I>serialized_size</I>, pcre2_general_context *<I>gcontext</I>);

<B>void pcre2_serialize_free(uint8_t *</B><I>bytes</I>);

<B>int32_t pcre2_serialize_get_number_of_codes(const uint8_t *</B><I>bytes</I>);
</PRE>

<A NAME="lbAL">&nbsp;</A>
<H2>PCRE2 NATIVE API AUXILIARY FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_code *pcre2_code_copy(const pcre2_code *</B><I>code</I>);

<B>pcre2_code *pcre2_code_copy_with_tables(const pcre2_code *</B><I>code</I>);

<B>int pcre2_get_error_message(int </B><I>errorcode</I>, PCRE2_UCHAR *<I>buffer</I>,
<B>  PCRE2_SIZE </B><I>bufflen</I>);

<B>const uint8_t *pcre2_maketables(pcre2_general_context *</B><I>gcontext</I>);

<B>void pcre2_maketables_free(pcre2_general_context *</B><I>gcontext</I>,
<B>  const uint8_t *</B><I>tables</I>);

<B>int pcre2_pattern_info(const pcre2_code *</B><I>code</I>, uint32_t <I>what</I>,
<B>  void *</B><I>where</I>);

<B>int pcre2_callout_enumerate(const pcre2_code *</B><I>code</I>,
<B>  int (*</B><I>callback</I>)(pcre2_callout_enumerate_block *, void *),
<B>  void *</B><I>user_data</I>);

<B>int pcre2_config(uint32_t </B><I>what</I>, void *<I>where</I>);
</PRE>

<A NAME="lbAM">&nbsp;</A>
<H2>PCRE2 NATIVE API OBSOLETE FUNCTIONS</H2>


<P>
<PRE>
<B>int pcre2_set_recursion_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);

<B>int pcre2_set_recursion_memory_management(</B>
<B>  pcre2_match_context *</B><I>mcontext</I>,
<B>  void *(*</B><I>private_malloc</I>)(PCRE2_SIZE, void *),
<B>  void (*</B><I>private_free</I>)(void *, void *), void *<I>memory_data</I>);
</PRE>

<P>
These functions became obsolete at release 10.30 and are retained only for
backward compatibility. They should not be used in new code. The first is
replaced by <B>pcre2_set_depth_limit()</B>; the second is no longer needed and
has no effect (it always returns zero).
<A NAME="lbAN">&nbsp;</A>
<H2>PCRE2 EXPERIMENTAL PATTERN CONVERSION FUNCTIONS</H2>


<P>
<PRE>
<B>pcre2_convert_context *pcre2_convert_context_create(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_convert_context *pcre2_convert_context_copy(</B>
<B>  pcre2_convert_context *</B><I>cvcontext</I>);

<B>void pcre2_convert_context_free(pcre2_convert_context *</B><I>cvcontext</I>);

<B>int pcre2_set_glob_escape(pcre2_convert_context *</B><I>cvcontext</I>,
<B>  uint32_t </B><I>escape_char</I>);

<B>int pcre2_set_glob_separator(pcre2_convert_context *</B><I>cvcontext</I>,
<B>  uint32_t </B><I>separator_char</I>);

<B>int pcre2_pattern_convert(PCRE2_SPTR </B><I>pattern</I>, PCRE2_SIZE <I>length</I>,
<B>  uint32_t </B><I>options</I>, PCRE2_UCHAR **<I>buffer</I>,
<B>  PCRE2_SIZE *</B><I>blength</I>, pcre2_convert_context *<I>cvcontext</I>);

<B>void pcre2_converted_pattern_free(PCRE2_UCHAR *</B><I>converted_pattern</I>);
</PRE>

<P>
These functions provide a way of converting non-PCRE2 patterns into
patterns that can be processed by <B>pcre2_compile()</B>. This facility is
experimental and may be changed in future releases. At present, &quot;globs&quot; and
POSIX basic and extended patterns can be converted. Details are given in the

<B>pcre2convert</B>

documentation.
<A NAME="lbAO">&nbsp;</A>
<H2>PCRE2 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</H2>


<P>
There are three PCRE2 libraries, supporting 8-bit, 16-bit, and 32-bit code
units, respectively. However, there is just one header file, <B>pcre2.h</B>.
This contains the function prototypes and other definitions for all three
libraries. One, two, or all three can be installed simultaneously. On Unix-like
systems the libraries are called <B>libpcre2-8</B>, <B>libpcre2-16</B>, and
<B>libpcre2-32</B>, and they can also co-exist with the original PCRE libraries.
<P>

Character strings are passed to and from a PCRE2 library as a sequence of
unsigned integers in code units of the appropriate width. Every PCRE2 function
comes in three different forms, one for each library, for example:
<P>
<BR>&nbsp;&nbsp;<B>pcre2_compile_8()</B>
<BR>&nbsp;&nbsp;<B>pcre2_compile_16()</B>
<BR>&nbsp;&nbsp;<B>pcre2_compile_32()</B>
<P>
There are also three different sets of data types:
<P>
<BR>&nbsp;&nbsp;<B>PCRE2_UCHAR8,&nbsp;PCRE2_UCHAR16,&nbsp;PCRE2_UCHAR32</B>
<BR>&nbsp;&nbsp;<B>PCRE2_SPTR8,&nbsp;&nbsp;PCRE2_SPTR16,&nbsp;&nbsp;PCRE2_SPTR32</B>
<P>
The UCHAR types define unsigned code units of the appropriate widths. For
example, PCRE2_UCHAR16 is usually defined as `uint16_t'. The SPTR types are
constant pointers to the equivalent UCHAR types, that is, they are pointers to
vectors of unsigned code units.
<P>

Many applications use only one code unit width. For their convenience, macros
are defined whose names are the generic forms such as <B>pcre2_compile()</B> and
PCRE2_SPTR. These macros use the value of the macro PCRE2_CODE_UNIT_WIDTH to
generate the appropriate width-specific function and macro names.
PCRE2_CODE_UNIT_WIDTH is not defined by default. An application must define it
to be 8, 16, or 32 before including <B>pcre2.h</B> in order to make use of the
generic names.
<P>

Applications that use more than one code unit width can be linked with more
than one PCRE2 library, but must define PCRE2_CODE_UNIT_WIDTH to be 0 before
including <B>pcre2.h</B>, and then use the real function names. Any code that is
to be included in an environment where the value of PCRE2_CODE_UNIT_WIDTH is
unknown should also use the real function names. (Unfortunately, it is not
possible in C code to save and restore the value of a macro.)
<P>

If PCRE2_CODE_UNIT_WIDTH is not defined before including <B>pcre2.h</B>, a
compiler error occurs.
<P>

When using multiple libraries in an application, you must take care when
processing any particular pattern to use only functions from a single library.
For example, if you want to run a match using a pattern that was compiled with
<B>pcre2_compile_16()</B>, you must do so with <B>pcre2_match_16()</B>, not
<B>pcre2_match_8()</B> or <B>pcre2_match_32()</B>.
<P>

In the function summaries above, and in the rest of this document and other
PCRE2 documents, functions and data types are described using their generic
names, without the _8, _16, or _32 suffix.
<A NAME="lbAP">&nbsp;</A>
<H2>PCRE2 API OVERVIEW</H2>


<P>
PCRE2 has its own native API, which is described in this document. There are
also some wrapper functions for the 8-bit library that correspond to the
POSIX regular expression API, but they do not give access to all the
functionality of PCRE2. They are described in the

<B>pcre2posix</B>

documentation. Both these APIs define a set of C function calls.
<P>

The native API C data types, function prototypes, option values, and error
codes are defined in the header file <B>pcre2.h</B>, which also contains
definitions of PCRE2_MAJOR and PCRE2_MINOR, the major and minor release numbers
for the library. Applications can use these to include support for different
releases of PCRE2.
<P>

In a Windows environment, if you want to statically link an application program
against a non-dll PCRE2 library, you must define PCRE2_STATIC before including
<B>pcre2.h</B>.
<P>

The functions <B>pcre2_compile()</B> and <B>pcre2_match()</B> are used for
compiling and matching regular expressions in a Perl-compatible manner. A
sample program that demonstrates the simplest way of using them is provided in
the file called <I>pcre2demo.c</I> in the PCRE2 source distribution. A listing
of this program is given in the

<B>pcre2demo</B>

documentation, and the

<B>pcre2sample</B>

documentation describes how to compile and run it.
<P>

The compiling and matching functions recognize various options that are passed
as bits in an options argument. There are also some more complicated parameters
such as custom memory management functions and resource limits that are passed
in &quot;contexts&quot; (which are just memory blocks, described below). Simple
applications do not need to make use of contexts.
<P>

Just-in-time (JIT) compiler support is an optional feature of PCRE2 that can be
built in appropriate hardware environments. It greatly speeds up the matching
performance of many patterns. Programs can request that it be used if
available by calling <B>pcre2_jit_compile()</B> after a pattern has been
successfully compiled by <B>pcre2_compile()</B>. This does nothing if JIT
support is not available.
<P>

More complicated programs might need to make use of the specialist functions
<B>pcre2_jit_stack_create()</B>, <B>pcre2_jit_stack_free()</B>, and
<B>pcre2_jit_stack_assign()</B> in order to control the JIT code's memory usage.
<P>

JIT matching is automatically used by <B>pcre2_match()</B> if it is available,
unless the PCRE2_NO_JIT option is set. There is also a direct interface for JIT
matching, which gives improved performance at the expense of less sanity
checking. The JIT-specific functions are discussed in the

<B>pcre2jit</B>

documentation.
<P>

A second matching function, <B>pcre2_dfa_match()</B>, which is not
Perl-compatible, is also provided. This uses a different algorithm for the
matching. The alternative algorithm finds all possible matches (at a given
point in the subject), and scans the subject just once (unless there are
lookaround assertions). However, this algorithm does not return captured
substrings. A description of the two matching algorithms and their advantages
and disadvantages is given in the

<B>pcre2matching</B>

documentation. There is no JIT support for <B>pcre2_dfa_match()</B>.
<P>

In addition to the main compiling and matching functions, there are convenience
functions for extracting captured substrings from a subject string that has
been matched by <B>pcre2_match()</B>. They are:
<P>
<BR>&nbsp;&nbsp;<B>pcre2_substring_copy_byname()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_copy_bynumber()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_get_byname()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_get_bynumber()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_list_get()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_length_byname()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_length_bynumber()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_nametable_scan()</B>
<BR>&nbsp;&nbsp;<B>pcre2_substring_number_from_name()</B>
<P>
<B>pcre2_substring_free()</B> and <B>pcre2_substring_list_free()</B> are also
provided, to free memory used for extracted strings. If either of these
functions is called with a NULL argument, the function returns immediately
without doing anything.
<P>

The function <B>pcre2_substitute()</B> can be called to match a pattern and
return a copy of the subject string with substitutions for parts that were
matched.
<P>

Functions whose names begin with <B>pcre2_serialize_</B> are used for saving
compiled patterns on disc or elsewhere, and reloading them later.
<P>

Finally, there are functions for finding out information about a compiled
pattern (<B>pcre2_pattern_info()</B>) and about the configuration with which
PCRE2 was built (<B>pcre2_config()</B>).
<P>

Functions with names ending with <B>_free()</B> are used for freeing memory
blocks of various sorts. In all cases, if one of these functions is called with
a NULL argument, it does nothing.
<A NAME="lbAQ">&nbsp;</A>
<H2>STRING LENGTHS AND OFFSETS</H2>


<P>
The PCRE2 API uses string lengths and offsets into strings of code units in
several places. These values are always of type PCRE2_SIZE, which is an
unsigned integer type, currently always defined as <I>size_t</I>. The largest
value that can be stored in such a type (that is ~(PCRE2_SIZE)0) is reserved
as a special indicator for zero-terminated strings and unset offsets.
Therefore, the longest string that can be handled is one less than this
maximum.

<A NAME="lbAR">&nbsp;</A>
<H2>NEWLINES</H2>


<P>
PCRE2 supports five different conventions for indicating line breaks in
strings: a single CR (carriage return) character, a single LF (linefeed)
character, the two-character sequence CRLF, any of the three preceding, or any
Unicode newline sequence. The Unicode newline sequences are the three just
mentioned, plus the single characters VT (vertical tab, U+000B), FF (form feed,
U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS
(paragraph separator, U+2029).
<P>

Each of the first three conventions is used by at least one operating system as
its standard newline sequence. When PCRE2 is built, a default can be specified.
If it is not, the default is set to LF, which is the Unix standard. However,
the newline convention can be changed by an application when calling
<B>pcre2_compile()</B>, or it can be specified by special text at the start of
the pattern itself; this overrides any other settings. See the

<B>pcre2pattern</B>

page for details of the special character sequences.
<P>

In the PCRE2 documentation the word &quot;newline&quot; is used to mean &quot;the character or
pair of characters that indicate a line break&quot;. The choice of newline
convention affects the handling of the dot, circumflex, and dollar
metacharacters, the handling of #-comments in /x mode, and, when CRLF is a
recognized line ending sequence, the match position advancement for a
non-anchored pattern. There is more detail about this in the


section on <B>pcre2_match()</B> options

below.
<P>

The choice of newline convention does not affect the interpretation of
the \n or \r escape sequences, nor does it affect what \R matches; this has
its own separate convention.
<A NAME="lbAS">&nbsp;</A>
<H2>MULTITHREADING</H2>


<P>
In a multithreaded application it is important to keep thread-specific data
separate from data that can be shared between threads. The PCRE2 library code
itself is thread-safe: it contains no static or global variables. The API is
designed to be fairly simple for non-threaded applications while at the same
time ensuring that multithreaded applications can use it.
<P>

There are several different blocks of data that are used to pass information
between the application and the PCRE2 libraries.
<A NAME="lbAT">&nbsp;</A>
<H3>The compiled pattern</H3>


<P>
A pointer to the compiled form of a pattern is returned to the user when
<B>pcre2_compile()</B> is successful. The data in the compiled pattern is fixed,
and does not change when the pattern is matched. Therefore, it is thread-safe,
that is, the same compiled pattern can be used by more than one thread
simultaneously. For example, an application can compile all its patterns at the
start, before forking off multiple threads that use them. However, if the
just-in-time (JIT) optimization feature is being used, it needs separate memory
stack areas for each thread. See the

<B>pcre2jit</B>

documentation for more details.
<P>

In a more complicated situation, where patterns are compiled only when they are
first needed, but are still shared between threads, pointers to compiled
patterns must be protected from simultaneous writing by multiple threads, at
least until a pattern has been compiled. The logic can be something like this:
<P>
<BR>&nbsp;&nbsp;Get&nbsp;a&nbsp;read-only&nbsp;(shared)&nbsp;lock&nbsp;(mutex)&nbsp;for&nbsp;pointer
<BR>&nbsp;&nbsp;if&nbsp;(pointer&nbsp;==&nbsp;NULL)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Get&nbsp;a&nbsp;write&nbsp;(unique)&nbsp;lock&nbsp;for&nbsp;pointer
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;=&nbsp;pcre2_compile(...
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;Release&nbsp;the&nbsp;lock
<BR>&nbsp;&nbsp;Use&nbsp;pointer&nbsp;in&nbsp;pcre2_match()
<P>
Of course, testing for compilation errors should also be included in the code.
<P>

If JIT is being used, but the JIT compilation is not being done immediately,
(perhaps waiting to see if the pattern is used often enough) similar logic is
required. JIT compilation updates a pointer within the compiled code block, so
a thread must gain unique write access to the pointer before calling
<B>pcre2_jit_compile()</B>. Alternatively, <B>pcre2_code_copy()</B> or
<B>pcre2_code_copy_with_tables()</B> can be used to obtain a private copy of the
compiled code before calling the JIT compiler.
<A NAME="lbAU">&nbsp;</A>
<H3>Context blocks</H3>


<P>
The next main section below introduces the idea of &quot;contexts&quot; in which PCRE2
functions are called. A context is nothing more than a collection of parameters
that control the way PCRE2 operates. Grouping a number of parameters together
in a context is a convenient way of passing them to a PCRE2 function without
using lots of arguments. The parameters that are stored in contexts are in some
sense &quot;advanced features&quot; of the API. Many straightforward applications will
not need to use contexts.
<P>

In a multithreaded application, if the parameters in a context are values that
are never changed, the same context can be used by all the threads. However, if
any thread needs to change any value in a context, it must make its own
thread-specific copy.
<A NAME="lbAV">&nbsp;</A>
<H3>Match blocks</H3>


<P>
The matching functions need a block of memory for storing the results of a
match. This includes details of what was matched, as well as additional
information such as the name of a (*MARK) setting. Each thread must provide its
own copy of this memory.
<A NAME="lbAW">&nbsp;</A>
<H2>PCRE2 CONTEXTS</H2>


<P>
Some PCRE2 functions have a lot of parameters, many of which are used only by
specialist applications, for example, those that use custom memory management
or non-standard character tables. To keep function argument lists at a
reasonable size, and at the same time to keep the API extensible, &quot;uncommon&quot;
parameters are passed to certain functions in a <B>context</B> instead of
directly. A context is just a block of memory that holds the parameter values.
Applications that do not need to adjust any of the context parameters can pass
NULL when a context pointer is required.
<P>

There are three different types of context: a general context that is relevant
for several PCRE2 operations, a compile-time context, and a match-time context.
<A NAME="lbAX">&nbsp;</A>
<H3>The general context</H3>


<P>
At present, this context just contains pointers to (and data for) external
memory management functions that are called from several places in the PCRE2
library. The context is named `general' rather than specifically `memory'
because in future other fields may be added. If you do not want to supply your
own custom memory management functions, you do not need to bother with a
general context. A general context is created by:
<P>
<PRE>
<B>pcre2_general_context *pcre2_general_context_create(</B>
<B>  void *(*</B><I>private_malloc</I>)(PCRE2_SIZE, void *),
<B>  void (*</B><I>private_free</I>)(void *, void *), void *<I>memory_data</I>);
</PRE>

<P>
The two function pointers specify custom memory management functions, whose
prototypes are:
<P>
<BR>&nbsp;&nbsp;<B>void&nbsp;*private_malloc(PCRE2_SIZE,&nbsp;void&nbsp;*);</B>
<BR>&nbsp;&nbsp;<B>void&nbsp;&nbsp;private_free(void&nbsp;*,&nbsp;void&nbsp;*);</B>
<P>
Whenever code in PCRE2 calls these functions, the final argument is the value
of <I>memory_data</I>. Either of the first two arguments of the creation
function may be NULL, in which case the system memory management functions
<I>malloc()</I> and <I>free()</I> are used. (This is not currently useful, as
there are no other fields in a general context, but in future there might be.)
The <I>private_malloc()</I> function is used (if supplied) to obtain memory for
storing the context, and all three values are saved as part of the context.
<P>

Whenever PCRE2 creates a data block of any kind, the block contains a pointer
to the <I>free()</I> function that matches the <I>malloc()</I> function that was
used. When the time comes to free the block, this function is called.
<P>

A general context can be copied by calling:
<P>
<PRE>
<B>pcre2_general_context *pcre2_general_context_copy(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);
</PRE>

<P>
The memory used for a general context should be freed by calling:
<P>
<PRE>
<B>void pcre2_general_context_free(pcre2_general_context *</B><I>gcontext</I>);
</PRE>

<P>
If this function is passed a NULL argument, it returns immediately without
doing anything.

<A NAME="lbAY">&nbsp;</A>
<H3>The compile context</H3>


<P>
A compile context is required if you want to provide an external function for
stack checking during compilation or to change the default values of any of the
following compile-time parameters:
<P>
<BR>&nbsp;&nbsp;What&nbsp;\R&nbsp;matches&nbsp;(Unicode&nbsp;newlines&nbsp;or&nbsp;CR,&nbsp;LF,&nbsp;CRLF&nbsp;only)
<BR>&nbsp;&nbsp;PCRE2's&nbsp;character&nbsp;tables
<BR>&nbsp;&nbsp;The&nbsp;newline&nbsp;character&nbsp;sequence
<BR>&nbsp;&nbsp;The&nbsp;compile&nbsp;time&nbsp;nested&nbsp;parentheses&nbsp;limit
<BR>&nbsp;&nbsp;The&nbsp;maximum&nbsp;length&nbsp;of&nbsp;the&nbsp;pattern&nbsp;string
<BR>&nbsp;&nbsp;The&nbsp;extra&nbsp;options&nbsp;bits&nbsp;(none&nbsp;set&nbsp;by&nbsp;default)
<P>
A compile context is also required if you are using custom memory management.
If none of these apply, just pass NULL as the context argument of
<I>pcre2_compile()</I>.
<P>

A compile context is created, copied, and freed by the following functions:
<P>
<PRE>
<B>pcre2_compile_context *pcre2_compile_context_create(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_compile_context *pcre2_compile_context_copy(</B>
<B>  pcre2_compile_context *</B><I>ccontext</I>);

<B>void pcre2_compile_context_free(pcre2_compile_context *</B><I>ccontext</I>);
</PRE>

<P>
A compile context is created with default values for its parameters. These can
be changed by calling the following functions, which return 0 on success, or
PCRE2_ERROR_BADDATA if invalid data is detected.
<P>
<PRE>
<B>int pcre2_set_bsr(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
The value must be PCRE2_BSR_ANYCRLF, to specify that \R matches only CR, LF,
or CRLF, or PCRE2_BSR_UNICODE, to specify that \R matches any Unicode line
ending sequence. The value is used by the JIT compiler and by the two
interpreted matching functions, <I>pcre2_match()</I> and
<I>pcre2_dfa_match()</I>.
<P>
<PRE>
<B>int pcre2_set_character_tables(pcre2_compile_context *</B><I>ccontext</I>,
<B>  const uint8_t *</B><I>tables</I>);
</PRE>

<P>
The value must be the result of a call to <B>pcre2_maketables()</B>, whose only
argument is a general context. This function builds a set of character tables
in the current locale.
<P>
<PRE>
<B>int pcre2_set_compile_extra_options(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>extra_options</I>);
</PRE>

<P>
As PCRE2 has developed, almost all the 32 option bits that are available in
the <I>options</I> argument of <B>pcre2_compile()</B> have been used up. To avoid
running out, the compile context contains a set of extra option bits which are
used for some newer, assumed rarer, options. This function sets those bits. It
always sets all the bits (either on or off). It does not modify any existing
setting. The available options are defined in the section entitled &quot;Extra
compile options&quot;


below.

<P>
<PRE>
<B>int pcre2_set_max_pattern_length(pcre2_compile_context *</B><I>ccontext</I>,
<B>  PCRE2_SIZE </B><I>value</I>);
</PRE>

<P>
This sets a maximum length, in code units, for any pattern string that is
compiled with this context. If the pattern is longer, an error is generated.
This facility is provided so that applications that accept patterns from
external sources can limit their size. The default is the largest number that a
PCRE2_SIZE variable can hold, which is effectively unlimited.
<P>
<PRE>
<B>int pcre2_set_newline(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
This specifies which characters or character sequences are to be recognized as
newlines. The value must be one of PCRE2_NEWLINE_CR (carriage return only),
PCRE2_NEWLINE_LF (linefeed only), PCRE2_NEWLINE_CRLF (the two-character
sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of the above),
PCRE2_NEWLINE_ANY (any Unicode newline sequence), or PCRE2_NEWLINE_NUL (the
NUL character, that is a binary zero).
<P>

A pattern can override the value set in the compile context by starting with a
sequence such as (*CRLF). See the

<B>pcre2pattern</B>

page for details.
<P>

When a pattern is compiled with the PCRE2_EXTENDED or PCRE2_EXTENDED_MORE
option, the newline convention affects the recognition of the end of internal
comments starting with #. The value is saved with the compiled pattern for
subsequent use by the JIT compiler and by the two interpreted matching
functions, <I>pcre2_match()</I> and <I>pcre2_dfa_match()</I>.
<P>
<PRE>
<B>int pcre2_set_parens_nest_limit(pcre2_compile_context *</B><I>ccontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
This parameter adjusts the limit, set when PCRE2 is built (default 250), on the
depth of parenthesis nesting in a pattern. This limit stops rogue patterns
using up too much system stack when being compiled. The limit applies to
parentheses of all kinds, not just capturing parentheses.
<P>
<PRE>
<B>int pcre2_set_compile_recursion_guard(pcre2_compile_context *</B><I>ccontext</I>,
<B>  int (*</B><I>guard_function</I>)(uint32_t, void *), void *<I>user_data</I>);
</PRE>

<P>
There is at least one application that runs PCRE2 in threads with very limited
system stack, where running out of stack is to be avoided at all costs. The
parenthesis limit above cannot take account of how much stack is actually
available during compilation. For a finer control, you can supply a function
that is called whenever <B>pcre2_compile()</B> starts to compile a parenthesized
part of a pattern. This function can check the actual stack size (or anything
else that it wants to, of course).
<P>

The first argument to the callout function gives the current depth of
nesting, and the second is user data that is set up by the last argument of
<B>pcre2_set_compile_recursion_guard()</B>. The callout function should return
zero if all is well, or non-zero to force an error.

<A NAME="lbAZ">&nbsp;</A>
<H3>The match context</H3>


<P>
A match context is required if you want to:
<P>
<BR>&nbsp;&nbsp;Set&nbsp;up&nbsp;a&nbsp;callout&nbsp;function
<BR>&nbsp;&nbsp;Set&nbsp;an&nbsp;offset&nbsp;limit&nbsp;for&nbsp;matching&nbsp;an&nbsp;unanchored&nbsp;pattern
<BR>&nbsp;&nbsp;Change&nbsp;the&nbsp;limit&nbsp;on&nbsp;the&nbsp;amount&nbsp;of&nbsp;heap&nbsp;used&nbsp;when&nbsp;matching
<BR>&nbsp;&nbsp;Change&nbsp;the&nbsp;backtracking&nbsp;match&nbsp;limit
<BR>&nbsp;&nbsp;Change&nbsp;the&nbsp;backtracking&nbsp;depth&nbsp;limit
<BR>&nbsp;&nbsp;Set&nbsp;custom&nbsp;memory&nbsp;management&nbsp;specifically&nbsp;for&nbsp;the&nbsp;match
<P>
If none of these apply, just pass NULL as the context argument of
<B>pcre2_match()</B>, <B>pcre2_dfa_match()</B>, or <B>pcre2_jit_match()</B>.
<P>

A match context is created, copied, and freed by the following functions:
<P>
<PRE>
<B>pcre2_match_context *pcre2_match_context_create(</B>
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_match_context *pcre2_match_context_copy(</B>
<B>  pcre2_match_context *</B><I>mcontext</I>);

<B>void pcre2_match_context_free(pcre2_match_context *</B><I>mcontext</I>);
</PRE>

<P>
A match context is created with default values for its parameters. These can
be changed by calling the following functions, which return 0 on success, or
PCRE2_ERROR_BADDATA if invalid data is detected.
<P>
<PRE>
<B>int pcre2_set_callout(pcre2_match_context *</B><I>mcontext</I>,
<B>  int (*</B><I>callout_function</I>)(pcre2_callout_block *, void *),
<B>  void *</B><I>callout_data</I>);
</PRE>

<P>
This sets up a callout function for PCRE2 to call at specified points
during a matching operation. Details are given in the

<B>pcre2callout</B>

documentation.
<P>
<PRE>
<B>int pcre2_set_substitute_callout(pcre2_match_context *</B><I>mcontext</I>,
<B>  int (*</B><I>callout_function</I>)(pcre2_substitute_callout_block *, void *),
<B>  void *</B><I>callout_data</I>);
</PRE>

<P>
This sets up a callout function for PCRE2 to call after each substitution
made by <B>pcre2_substitute()</B>. Details are given in the section entitled
&quot;Creating a new string with substitutions&quot;


below.

<P>
<PRE>
<B>int pcre2_set_offset_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  PCRE2_SIZE </B><I>value</I>);
</PRE>

<P>
The <I>offset_limit</I> parameter limits how far an unanchored search can
advance in the subject string. The default value is PCRE2_UNSET. The
<B>pcre2_match()</B> and <B>pcre2_dfa_match()</B> functions return
PCRE2_ERROR_NOMATCH if a match with a starting point before or at the given
offset is not found. The <B>pcre2_substitute()</B> function makes no more
substitutions.
<P>

For example, if the pattern /abc/ is matched against &quot;123abc&quot; with an offset
limit less than 3, the result is PCRE2_ERROR_NOMATCH. A match can never be
found if the <I>startoffset</I> argument of <B>pcre2_match()</B>,
<B>pcre2_dfa_match()</B>, or <B>pcre2_substitute()</B> is greater than the offset
limit set in the match context.
<P>

When using this facility, you must set the PCRE2_USE_OFFSET_LIMIT option when
calling <B>pcre2_compile()</B> so that when JIT is in use, different code can be
compiled. If a match is started with a non-default match limit when
PCRE2_USE_OFFSET_LIMIT is not set, an error is generated.
<P>

The offset limit facility can be used to track progress when searching large
subject strings or to limit the extent of global substitutions. See also the
PCRE2_FIRSTLINE option, which requires a match to start before or at the first
newline that follows the start of matching in the subject. If this is set with
an offset limit, a match must occur in the first line and also within the
offset limit. In other words, whichever limit comes first is used.
<P>
<PRE>
<B>int pcre2_set_heap_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
The <I>heap_limit</I> parameter specifies, in units of kibibytes (1024 bytes),
the maximum amount of heap memory that <B>pcre2_match()</B> may use to hold
backtracking information when running an interpretive match. This limit also
applies to <B>pcre2_dfa_match()</B>, which may use the heap when processing
patterns with a lot of nested pattern recursion or lookarounds or atomic
groups. This limit does not apply to matching with the JIT optimization, which
has its own memory control arrangements (see the

<B>pcre2jit</B>

documentation for more details). If the limit is reached, the negative error
code PCRE2_ERROR_HEAPLIMIT is returned. The default limit can be set when PCRE2
is built; if it is not, the default is set very large and is essentially
&quot;unlimited&quot;.
<P>

A value for the heap limit may also be supplied by an item at the start of a
pattern of the form
<P>
<BR>&nbsp;&nbsp;(*LIMIT_HEAP=ddd)
<P>
where ddd is a decimal number. However, such a setting is ignored unless ddd is
less than the limit set by the caller of <B>pcre2_match()</B> or, if no such
limit is set, less than the default.
<P>

The <B>pcre2_match()</B> function starts out using a 20KiB vector on the system
stack for recording backtracking points. The more nested backtracking points
there are (that is, the deeper the search tree), the more memory is needed.
Heap memory is used only if the initial vector is too small. If the heap limit
is set to a value less than 21 (in particular, zero) no heap memory will be
used. In this case, only patterns that do not have a lot of nested backtracking
can be successfully processed.
<P>

Similarly, for <B>pcre2_dfa_match()</B>, a vector on the system stack is used
when processing pattern recursions, lookarounds, or atomic groups, and only if
this is not big enough is heap memory used. In this case, too, setting a value
of zero disables the use of the heap.
<P>
<PRE>
<B>int pcre2_set_match_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
The <I>match_limit</I> parameter provides a means of preventing PCRE2 from using
up too many computing resources when processing patterns that are not going to
match, but which have a very large number of possibilities in their search
trees. The classic example is a pattern that uses nested unlimited repeats.
<P>

There is an internal counter in <B>pcre2_match()</B> that is incremented each
time round its main matching loop. If this value reaches the match limit,
<B>pcre2_match()</B> returns the negative value PCRE2_ERROR_MATCHLIMIT. This has
the effect of limiting the amount of backtracking that can take place. For
patterns that are not anchored, the count restarts from zero for each position
in the subject string. This limit also applies to <B>pcre2_dfa_match()</B>,
though the counting is done in a different way.
<P>

When <B>pcre2_match()</B> is called with a pattern that was successfully
processed by <B>pcre2_jit_compile()</B>, the way in which matching is executed
is entirely different. However, there is still the possibility of runaway
matching that goes on for a very long time, and so the <I>match_limit</I> value
is also used in this case (but in a different way) to limit how long the
matching can continue.
<P>

The default value for the limit can be set when PCRE2 is built; the default
default is 10 million, which handles all but the most extreme cases. A value
for the match limit may also be supplied by an item at the start of a pattern
of the form
<P>
<BR>&nbsp;&nbsp;(*LIMIT_MATCH=ddd)
<P>
where ddd is a decimal number. However, such a setting is ignored unless ddd is
less than the limit set by the caller of <B>pcre2_match()</B> or
<B>pcre2_dfa_match()</B> or, if no such limit is set, less than the default.
<P>
<PRE>
<B>int pcre2_set_depth_limit(pcre2_match_context *</B><I>mcontext</I>,
<B>  uint32_t </B><I>value</I>);
</PRE>

<P>
This parameter limits the depth of nested backtracking in <B>pcre2_match()</B>.
Each time a nested backtracking point is passed, a new memory &quot;frame&quot; is used
to remember the state of matching at that point. Thus, this parameter
indirectly limits the amount of memory that is used in a match. However,
because the size of each memory &quot;frame&quot; depends on the number of capturing
parentheses, the actual memory limit varies from pattern to pattern. This limit
was more useful in versions before 10.30, where function recursion was used for
backtracking.
<P>

The depth limit is not relevant, and is ignored, when matching is done using
JIT compiled code. However, it is supported by <B>pcre2_dfa_match()</B>, which
uses it to limit the depth of nested internal recursive function calls that
implement atomic groups, lookaround assertions, and pattern recursions. This
limits, indirectly, the amount of system stack that is used. It was more useful
in versions before 10.32, when stack memory was used for local workspace
vectors for recursive function calls. From version 10.32, only local variables
are allocated on the stack and as each call uses only a few hundred bytes, even
a small stack can support quite a lot of recursion.
<P>

If the depth of internal recursive function calls is great enough, local
workspace vectors are allocated on the heap from version 10.32 onwards, so the
depth limit also indirectly limits the amount of heap memory that is used. A
recursive pattern such as /(.(?2))((?1)|)/, when matched to a very long string
using <B>pcre2_dfa_match()</B>, can use a great deal of memory. However, it is
probably better to limit heap usage directly by calling
<B>pcre2_set_heap_limit()</B>.
<P>

The default value for the depth limit can be set when PCRE2 is built; if it is
not, the default is set to the same value as the default for the match limit.
If the limit is exceeded, <B>pcre2_match()</B> or <B>pcre2_dfa_match()</B>
returns PCRE2_ERROR_DEPTHLIMIT. A value for the depth limit may also be
supplied by an item at the start of a pattern of the form
<P>
<BR>&nbsp;&nbsp;(*LIMIT_DEPTH=ddd)
<P>
where ddd is a decimal number. However, such a setting is ignored unless ddd is
less than the limit set by the caller of <B>pcre2_match()</B> or
<B>pcre2_dfa_match()</B> or, if no such limit is set, less than the default.
<A NAME="lbBA">&nbsp;</A>
<H2>CHECKING BUILD-TIME OPTIONS</H2>


<P>
<B>int pcre2_config(uint32_t </B><I>what</I>, void *<I>where</I>);

<P>

The function <B>pcre2_config()</B> makes it possible for a PCRE2 client to
discover which optional features have been compiled into the PCRE2 library. The

<B>pcre2build</B>

documentation has more details about these optional features.
<P>

The first argument for <B>pcre2_config()</B> specifies which information is
required. The second argument is a pointer to memory into which the information
is placed. If NULL is passed, the function returns the amount of memory that is
needed for the requested information. For calls that return numerical values,
the value is in bytes; when requesting these values, <I>where</I> should point
to appropriately aligned memory. For calls that return strings, the required
length is given in code units, not counting the terminating zero.
<P>

When requesting information, the returned value from <B>pcre2_config()</B> is
non-negative on success, or the negative error code PCRE2_ERROR_BADOPTION if
the value in the first argument is not recognized. The following information is
available:
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_BSR
<P>
The output is a uint32_t integer whose value indicates what character
sequences the \R escape sequence matches by default. A value of
PCRE2_BSR_UNICODE means that \R matches any Unicode line ending sequence; a
value of PCRE2_BSR_ANYCRLF means that \R matches only CR, LF, or CRLF. The
default can be overridden when a pattern is compiled.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_COMPILED_WIDTHS
<P>
The output is a uint32_t integer whose lower bits indicate which code unit
widths were selected when PCRE2 was built. The 1-bit indicates 8-bit support,
and the 2-bit and 4-bit indicate 16-bit and 32-bit support, respectively.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_DEPTHLIMIT
<P>
The output is a uint32_t integer that gives the default limit for the depth of
nested backtracking in <B>pcre2_match()</B> or the depth of nested recursions,
lookarounds, and atomic groups in <B>pcre2_dfa_match()</B>. Further details are
given with <B>pcre2_set_depth_limit()</B> above.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_HEAPLIMIT
<P>
The output is a uint32_t integer that gives, in kibibytes, the default limit
for the amount of heap memory used by <B>pcre2_match()</B> or
<B>pcre2_dfa_match()</B>. Further details are given with
<B>pcre2_set_heap_limit()</B> above.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_JIT
<P>
The output is a uint32_t integer that is set to one if support for just-in-time
compiling is available; otherwise it is set to zero.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_JITTARGET
<P>
The <I>where</I> argument should point to a buffer that is at least 48 code
units long. (The exact length required can be found by calling
<B>pcre2_config()</B> with <B>where</B> set to NULL.) The buffer is filled with a
string that contains the name of the architecture for which the JIT compiler is
configured, for example &quot;x86 32bit (little endian + unaligned)&quot;. If JIT support
is not available, PCRE2_ERROR_BADOPTION is returned, otherwise the number of
code units used is returned. This is the length of the string, plus one unit
for the terminating zero.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_LINKSIZE
<P>
The output is a uint32_t integer that contains the number of bytes used for
internal linkage in compiled regular expressions. When PCRE2 is configured, the
value can be set to 2, 3, or 4, with the default being 2. This is the value
that is returned by <B>pcre2_config()</B>. However, when the 16-bit library is
compiled, a value of 3 is rounded up to 4, and when the 32-bit library is
compiled, internal linkages always use 4 bytes, so the configured value is not
relevant.
<P>

The default value of 2 for the 8-bit and 16-bit libraries is sufficient for all
but the most massive patterns, since it allows the size of the compiled pattern
to be up to 65535 code units. Larger values allow larger regular expressions to
be compiled by those two libraries, but at the expense of slower matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_MATCHLIMIT
<P>
The output is a uint32_t integer that gives the default match limit for
<B>pcre2_match()</B>. Further details are given with
<B>pcre2_set_match_limit()</B> above.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_NEWLINE
<P>
The output is a uint32_t integer whose value specifies the default character
sequence that is recognized as meaning &quot;newline&quot;. The values are:
<P>
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_CR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carriage&nbsp;return&nbsp;(CR)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_LF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linefeed&nbsp;(LF)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_CRLF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carriage&nbsp;return,&nbsp;linefeed&nbsp;(CRLF)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_ANY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Any&nbsp;Unicode&nbsp;line&nbsp;ending
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_ANYCRLF&nbsp;&nbsp;Any&nbsp;of&nbsp;CR,&nbsp;LF,&nbsp;or&nbsp;CRLF
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_NUL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;NUL&nbsp;character&nbsp;(binary&nbsp;zero)
<P>
The default should normally correspond to the standard sequence for your
operating system.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_NEVER_BACKSLASH_C
<P>
The output is a uint32_t integer that is set to one if the use of \C was
permanently disabled when PCRE2 was built; otherwise it is set to zero.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_PARENSLIMIT
<P>
The output is a uint32_t integer that gives the maximum depth of nesting
of parentheses (of any kind) in a pattern. This limit is imposed to cap the
amount of system stack used when a pattern is compiled. It is specified when
PCRE2 is built; the default is 250. This limit does not take into account the
stack that may already be used by the calling application. For finer control
over compilation stack usage, see <B>pcre2_set_compile_recursion_guard()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_STACKRECURSE
<P>
This parameter is obsolete and should not be used in new code. The output is a
uint32_t integer that is always set to zero.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_UNICODE_VERSION
<P>
The <I>where</I> argument should point to a buffer that is at least 24 code
units long. (The exact length required can be found by calling
<B>pcre2_config()</B> with <B>where</B> set to NULL.) If PCRE2 has been compiled
without Unicode support, the buffer is filled with the text &quot;Unicode not
supported&quot;. Otherwise, the Unicode version string (for example, &quot;8.0.0&quot;) is
inserted. The number of code units used is returned. This is the length of the
string plus one unit for the terminating zero.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_UNICODE
<P>
The output is a uint32_t integer that is set to one if Unicode support is
available; otherwise it is set to zero. Unicode support implies UTF support.
<P>
<BR>&nbsp;&nbsp;PCRE2_CONFIG_VERSION
<P>
The <I>where</I> argument should point to a buffer that is at least 24 code
units long. (The exact length required can be found by calling
<B>pcre2_config()</B> with <B>where</B> set to NULL.) The buffer is filled with
the PCRE2 version string, zero-terminated. The number of code units used is
returned. This is the length of the string plus one unit for the terminating
zero.

<A NAME="lbBB">&nbsp;</A>
<H2>COMPILING A PATTERN</H2>


<P>
<PRE>
<B>pcre2_code *pcre2_compile(PCRE2_SPTR </B><I>pattern</I>, PCRE2_SIZE <I>length</I>,
<B>  uint32_t </B><I>options</I>, int *<I>errorcode</I>, PCRE2_SIZE *<I>erroroffset,</I>
<B>  pcre2_compile_context *</B><I>ccontext</I>);

<B>void pcre2_code_free(pcre2_code *</B><I>code</I>);

<B>pcre2_code *pcre2_code_copy(const pcre2_code *</B><I>code</I>);

<B>pcre2_code *pcre2_code_copy_with_tables(const pcre2_code *</B><I>code</I>);
</PRE>

<P>

The <B>pcre2_compile()</B> function compiles a pattern into an internal form.
The pattern is defined by a pointer to a string of code units and a length (in
code units). If the pattern is zero-terminated, the length can be specified as
PCRE2_ZERO_TERMINATED. The function returns a pointer to a block of memory that
contains the compiled pattern and related data, or NULL if an error occurred.
<P>

If the compile context argument <I>ccontext</I> is NULL, memory for the compiled
pattern is obtained by calling <B>malloc()</B>. Otherwise, it is obtained from
the same memory function that was used for the compile context. The caller must
free the memory by calling <B>pcre2_code_free()</B> when it is no longer needed.
If <B>pcre2_code_free()</B> is called with a NULL argument, it returns
immediately, without doing anything.
<P>

The function <B>pcre2_code_copy()</B> makes a copy of the compiled code in new
memory, using the same memory allocator as was used for the original. However,
if the code has been processed by the JIT compiler (see


below),

the JIT information cannot be copied (because it is position-dependent).
The new copy can initially be used only for non-JIT matching, though it can be
passed to <B>pcre2_jit_compile()</B> if required. If <B>pcre2_code_copy()</B> is
called with a NULL argument, it returns NULL.
<P>

The <B>pcre2_code_copy()</B> function provides a way for individual threads in a
multithreaded application to acquire a private copy of shared compiled code.
However, it does not make a copy of the character tables used by the compiled
pattern; the new pattern code points to the same tables as the original code.
(See


&quot;Locale Support&quot;

below for details of these character tables.) In many applications the same
tables are used throughout, so this behaviour is appropriate. Nevertheless,
there are occasions when a copy of a compiled pattern and the relevant tables
are needed. The <B>pcre2_code_copy_with_tables()</B> provides this facility.
Copies of both the code and the tables are made, with the new code pointing to
the new tables. The memory for the new tables is automatically freed when
<B>pcre2_code_free()</B> is called for the new copy of the compiled code. If
<B>pcre2_code_copy_with_tables()</B> is called with a NULL argument, it returns
NULL.
<P>

NOTE: When one of the matching functions is called, pointers to the compiled
pattern and the subject string are set in the match data block so that they can
be referenced by the substring extraction functions after a successful match.
After running a match, you must not free a compiled pattern or a subject string
until after all operations on the


match data block

have taken place, unless, in the case of the subject string, you have used the
PCRE2_COPY_MATCHED_SUBJECT option, which is described in the section entitled
&quot;Option bits for <B>pcre2_match()</B>&quot;


below.

<P>

The <I>options</I> argument for <B>pcre2_compile()</B> contains various bit
settings that affect the compilation. It should be zero if none of them are
required. The available options are described below. Some of them (in
particular, those that are compatible with Perl, but some others as well) can
also be set and unset from within the pattern (see the detailed description in
the

<B>pcre2pattern</B>

documentation).
<P>

For those options that can be different in different parts of the pattern, the
contents of the <I>options</I> argument specifies their settings at the start of
compilation. The PCRE2_ANCHORED, PCRE2_ENDANCHORED, and PCRE2_NO_UTF_CHECK
options can be set at the time of matching as well as at compile time.
<P>

Some additional options and less frequently required compile-time parameters
(for example, the newline setting) can be provided in a compile context (as
described


above).

<P>

If <I>errorcode</I> or <I>erroroffset</I> is NULL, <B>pcre2_compile()</B> returns
NULL immediately. Otherwise, the variables to which these point are set to an
error code and an offset (number of code units) within the pattern,
respectively, when <B>pcre2_compile()</B> returns NULL because a compilation
error has occurred. The values are not defined when compilation is successful
and <B>pcre2_compile()</B> returns a non-NULL value.
<P>

There are nearly 100 positive error codes that <B>pcre2_compile()</B> may return
if it finds an error in the pattern. There are also some negative error codes
that are used for invalid UTF strings when validity checking is in force. These
are the same as given by <B>pcre2_match()</B> and <B>pcre2_dfa_match()</B>, and
are described in the

<B>pcre2unicode</B>

documentation. There is no separate documentation for the positive error codes,
because the textual error messages that are obtained by calling the
<B>pcre2_get_error_message()</B> function (see &quot;Obtaining a textual error
message&quot;


below)

should be self-explanatory. Macro names starting with PCRE2_ERROR_ are defined
for both positive and negative error codes in <B>pcre2.h</B>.
<P>

The value returned in <I>erroroffset</I> is an indication of where in the
pattern the error occurred. It is not necessarily the furthest point in the
pattern that was read. For example, after the error &quot;lookbehind assertion is
not fixed length&quot;, the error offset points to the start of the failing
assertion. For an invalid UTF-8 or UTF-16 string, the offset is that of the
first code unit of the failing character.
<P>

Some errors are not detected until the whole pattern has been scanned; in these
cases, the offset passed back is the length of the pattern. Note that the
offset is in code units, not characters, even in a UTF mode. It may sometimes
point into the middle of a UTF-8 or UTF-16 character.
<P>

This code fragment shows a typical straightforward call to
<B>pcre2_compile()</B>:
<P>
<BR>&nbsp;&nbsp;pcre2_code&nbsp;*re;
<BR>&nbsp;&nbsp;PCRE2_SIZE&nbsp;erroffset;
<BR>&nbsp;&nbsp;int&nbsp;errorcode;
<BR>&nbsp;&nbsp;re&nbsp;=&nbsp;pcre2_compile(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;^A.*Z&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;pattern&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;PCRE2_ZERO_TERMINATED,&nbsp;&nbsp;/*&nbsp;the&nbsp;pattern&nbsp;is&nbsp;zero-terminated&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;errorcode,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;error&nbsp;code&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;erroffset,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;error&nbsp;offset&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;no&nbsp;compile&nbsp;context&nbsp;*/
<P>
<A NAME="lbBC">&nbsp;</A>
<H3>Main compile options</H3>


<P>
The following names for option bits are defined in the <B>pcre2.h</B> header
file:
<P>
<BR>&nbsp;&nbsp;PCRE2_ANCHORED
<P>
If this bit is set, the pattern is forced to be &quot;anchored&quot;, that is, it is
constrained to match only at the first matching point in the string that is
being searched (the &quot;subject string&quot;). This effect can also be achieved by
appropriate constructs in the pattern itself, which is the only way to do it in
Perl.
<P>
<BR>&nbsp;&nbsp;PCRE2_ALLOW_EMPTY_CLASS
<P>
By default, for compatibility with Perl, a closing square bracket that
immediately follows an opening one is treated as a data character for the
class. When PCRE2_ALLOW_EMPTY_CLASS is set, it terminates the class, which
therefore contains no characters and so can never match.
<P>
<BR>&nbsp;&nbsp;PCRE2_ALT_BSUX
<P>
This option request alternative handling of three escape sequences, which
makes PCRE2's behaviour more like ECMAscript (aka JavaScript). When it is set:
<P>

(1) \U matches an upper case &quot;U&quot; character; by default \U causes a compile
time error (Perl uses \U to upper case subsequent characters).
<P>

(2) \u matches a lower case &quot;u&quot; character unless it is followed by four
hexadecimal digits, in which case the hexadecimal number defines the code point
to match. By default, \u causes a compile time error (Perl uses it to upper
case the following character).
<P>

(3) \x matches a lower case &quot;x&quot; character unless it is followed by two
hexadecimal digits, in which case the hexadecimal number defines the code point
to match. By default, as in Perl, a hexadecimal number is always expected after
\x, but it may have zero, one, or two digits (so, for example, \xz matches a
binary zero character followed by z).
<P>

ECMAscript 6 added additional functionality to \u. This can be accessed using
the PCRE2_EXTRA_ALT_BSUX extra option (see &quot;Extra compile options&quot;


below).

Note that this alternative escape handling applies only to patterns. Neither of
these options affects the processing of replacement strings passed to
<B>pcre2_substitute()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE2_ALT_CIRCUMFLEX
<P>
In multiline mode (when PCRE2_MULTILINE is set), the circumflex metacharacter
matches at the start of the subject (unless PCRE2_NOTBOL is set), and also
after any internal newline. However, it does not match after a newline at the
end of the subject, for compatibility with Perl. If you want a multiline
circumflex also to match after a terminating newline, you must set
PCRE2_ALT_CIRCUMFLEX.
<P>
<BR>&nbsp;&nbsp;PCRE2_ALT_VERBNAMES
<P>
By default, for compatibility with Perl, the name in any verb sequence such as
(*MARK:NAME) is any sequence of characters that does not include a closing
parenthesis. The name is not processed in any way, and it is not possible to
include a closing parenthesis in the name. However, if the PCRE2_ALT_VERBNAMES
option is set, normal backslash processing is applied to verb names and only an
unescaped closing parenthesis terminates the name. A closing parenthesis can be
included in a name either as \) or between \Q and \E. If the PCRE2_EXTENDED
or PCRE2_EXTENDED_MORE option is set with PCRE2_ALT_VERBNAMES, unescaped
whitespace in verb names is skipped and #-comments are recognized, exactly as
in the rest of the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_AUTO_CALLOUT
<P>
If this bit is set, <B>pcre2_compile()</B> automatically inserts callout items,
all with number 255, before each pattern item, except immediately before or
after an explicit callout in the pattern. For discussion of the callout
facility, see the

<B>pcre2callout</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE2_CASELESS
<P>
If this bit is set, letters in the pattern match both upper and lower case
letters in the subject. It is equivalent to Perl's /i option, and it can be
changed within a pattern by a (?i) option setting. If PCRE2_UTF is set, Unicode
properties are used for all characters with more than one other case, and for
all characters whose code points are greater than U+007F. For lower valued
characters with only one other case, a lookup table is used for speed. When
PCRE2_UTF is not set, a lookup table is used for all code points less than 256,
and higher code points (available only in 16-bit or 32-bit mode) are treated as
not having another case.
<P>
<BR>&nbsp;&nbsp;PCRE2_DOLLAR_ENDONLY
<P>
If this bit is set, a dollar metacharacter in the pattern matches only at the
end of the subject string. Without this option, a dollar also matches
immediately before a newline at the end of the string (but not before any other
newlines). The PCRE2_DOLLAR_ENDONLY option is ignored if PCRE2_MULTILINE is
set. There is no equivalent to this option in Perl, and no way to set it within
a pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_DOTALL
<P>
If this bit is set, a dot metacharacter in the pattern matches any character,
including one that indicates a newline. However, it only ever matches one
character, even if newlines are coded as CRLF. Without this option, a dot does
not match when the current position in the subject is at a newline. This option
is equivalent to Perl's /s option, and it can be changed within a pattern by a
(?s) option setting. A negative class such as [^a] always matches newline
characters, and the \N escape sequence always matches a non-newline character,
independent of the setting of PCRE2_DOTALL.
<P>
<BR>&nbsp;&nbsp;PCRE2_DUPNAMES
<P>
If this bit is set, names used to identify capture groups need not be unique.
This can be helpful for certain types of pattern when it is known that only one
instance of the named group can ever be matched. There are more details of
named capture groups below; see also the

<B>pcre2pattern</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE2_ENDANCHORED
<P>
If this bit is set, the end of any pattern match must be right at the end of
the string being searched (the &quot;subject string&quot;). If the pattern match
succeeds by reaching (*ACCEPT), but does not reach the end of the subject, the
match fails at the current starting point. For unanchored patterns, a new match
is then tried at the next starting point. However, if the match succeeds by
reaching the end of the pattern, but not the end of the subject, backtracking
occurs and an alternative match may be found. Consider these two patterns:
<P>
<BR>&nbsp;&nbsp;.(*ACCEPT)|..
<BR>&nbsp;&nbsp;.|..
<P>
If matched against &quot;abc&quot; with PCRE2_ENDANCHORED set, the first matches &quot;c&quot;
whereas the second matches &quot;bc&quot;. The effect of PCRE2_ENDANCHORED can also be
achieved by appropriate constructs in the pattern itself, which is the only way
to do it in Perl.
<P>

For DFA matching with <B>pcre2_dfa_match()</B>, PCRE2_ENDANCHORED applies only
to the first (that is, the longest) matched string. Other parallel matches,
which are necessarily substrings of the first one, must obviously end before
the end of the subject.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTENDED
<P>
If this bit is set, most white space characters in the pattern are totally
ignored except when escaped or inside a character class. However, white space
is not allowed within sequences such as (?&gt; that introduce various
parenthesized groups, nor within numerical quantifiers such as {1,3}. Ignorable
white space is permitted between an item and a following quantifier and between
a quantifier and a following + that indicates possessiveness. PCRE2_EXTENDED is
equivalent to Perl's /x option, and it can be changed within a pattern by a
(?x) option setting.
<P>

When PCRE2 is compiled without Unicode support, PCRE2_EXTENDED recognizes as
white space only those characters with code points less than 256 that are
flagged as white space in its low-character table. The table is normally
created by

<B>pcre2_maketables()</B>,

which uses the <B>isspace()</B> function to identify space characters. In most
ASCII environments, the relevant characters are those with code points 0x0009
(tab), 0x000A (linefeed), 0x000B (vertical tab), 0x000C (formfeed), 0x000D
(carriage return), and 0x0020 (space).
<P>

When PCRE2 is compiled with Unicode support, in addition to these characters,
five more Unicode &quot;Pattern White Space&quot; characters are recognized by
PCRE2_EXTENDED. These are U+0085 (next line), U+200E (left-to-right mark),
U+200F (right-to-left mark), U+2028 (line separator), and U+2029 (paragraph
separator). This set of characters is the same as recognized by Perl's /x
option. Note that the horizontal and vertical space characters that are matched
by the \h and \v escapes in patterns are a much bigger set.
<P>

As well as ignoring most white space, PCRE2_EXTENDED also causes characters
between an unescaped # outside a character class and the next newline,
inclusive, to be ignored, which makes it possible to include comments inside
complicated patterns. Note that the end of this type of comment is a literal
newline sequence in the pattern; escape sequences that happen to represent a
newline do not count.
<P>

Which characters are interpreted as newlines can be specified by a setting in
the compile context that is passed to <B>pcre2_compile()</B> or by a special
sequence at the start of the pattern, as described in the section entitled


&quot;Newline conventions&quot;

in the <B>pcre2pattern</B> documentation. A default is defined when PCRE2 is
built.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTENDED_MORE
<P>
This option has the effect of PCRE2_EXTENDED, but, in addition, unescaped space
and horizontal tab characters are ignored inside a character class. Note: only
these two characters are ignored, not the full set of pattern white space
characters that are ignored outside a character class. PCRE2_EXTENDED_MORE is
equivalent to Perl's /xx option, and it can be changed within a pattern by a
(?xx) option setting.
<P>
<BR>&nbsp;&nbsp;PCRE2_FIRSTLINE
<P>
If this option is set, the start of an unanchored pattern match must be before
or at the first newline in the subject string following the start of matching,
though the matched text may continue over the newline. If <I>startoffset</I> is
non-zero, the limiting newline is not necessarily the first newline in the
subject. For example, if the subject string is &quot;abc\nxyz&quot; (where \n
represents a single-character newline) a pattern match for &quot;yz&quot; succeeds with
PCRE2_FIRSTLINE if <I>startoffset</I> is greater than 3. See also
PCRE2_USE_OFFSET_LIMIT, which provides a more general limiting facility. If
PCRE2_FIRSTLINE is set with an offset limit, a match must occur in the first
line and also within the offset limit. In other words, whichever limit comes
first is used.
<P>
<BR>&nbsp;&nbsp;PCRE2_LITERAL
<P>
If this option is set, all meta-characters in the pattern are disabled, and it
is treated as a literal string. Matching literal strings with a regular
expression engine is not the most efficient way of doing it. If you are doing a
lot of literal matching and are worried about efficiency, you should consider
using other approaches. The only other main options that are allowed with
PCRE2_LITERAL are: PCRE2_ANCHORED, PCRE2_ENDANCHORED, PCRE2_AUTO_CALLOUT,
PCRE2_CASELESS, PCRE2_FIRSTLINE, PCRE2_MATCH_INVALID_UTF,
PCRE2_NO_START_OPTIMIZE, PCRE2_NO_UTF_CHECK, PCRE2_UTF, and
PCRE2_USE_OFFSET_LIMIT. The extra options PCRE2_EXTRA_MATCH_LINE and
PCRE2_EXTRA_MATCH_WORD are also supported. Any other options cause an error.
<P>
<BR>&nbsp;&nbsp;PCRE2_MATCH_INVALID_UTF
<P>
This option forces PCRE2_UTF (see below) and also enables support for matching
by <B>pcre2_match()</B> in subject strings that contain invalid UTF sequences.
This facility is not supported for DFA matching. For details, see the

<B>pcre2unicode</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE2_MATCH_UNSET_BACKREF
<P>
If this option is set, a backreference to an unset capture group matches an
empty string (by default this causes the current matching alternative to fail).
A pattern such as (\1)(a) succeeds when this option is set (assuming it can
find an &quot;a&quot; in the subject), whereas it fails by default, for Perl
compatibility. Setting this option makes PCRE2 behave more like ECMAscript (aka
JavaScript).
<P>
<BR>&nbsp;&nbsp;PCRE2_MULTILINE
<P>
By default, for the purposes of matching &quot;start of line&quot; and &quot;end of line&quot;,
PCRE2 treats the subject string as consisting of a single line of characters,
even if it actually contains newlines. The &quot;start of line&quot; metacharacter (^)
matches only at the start of the string, and the &quot;end of line&quot; metacharacter
($) matches only at the end of the string, or before a terminating newline
(except when PCRE2_DOLLAR_ENDONLY is set). Note, however, that unless
PCRE2_DOTALL is set, the &quot;any character&quot; metacharacter (.) does not match at a
newline. This behaviour (for ^, $, and dot) is the same as Perl.
<P>

When PCRE2_MULTILINE it is set, the &quot;start of line&quot; and &quot;end of line&quot;
constructs match immediately following or immediately before internal newlines
in the subject string, respectively, as well as at the very start and end. This
is equivalent to Perl's /m option, and it can be changed within a pattern by a
(?m) option setting. Note that the &quot;start of line&quot; metacharacter does not match
after a newline at the end of the subject, for compatibility with Perl.
However, you can change this by setting the PCRE2_ALT_CIRCUMFLEX option. If
there are no newlines in a subject string, or no occurrences of ^ or $ in a
pattern, setting PCRE2_MULTILINE has no effect.
<P>
<BR>&nbsp;&nbsp;PCRE2_NEVER_BACKSLASH_C
<P>
This option locks out the use of \C in the pattern that is being compiled.
This escape can cause unpredictable behaviour in UTF-8 or UTF-16 modes, because
it may leave the current matching point in the middle of a multi-code-unit
character. This option may be useful in applications that process patterns from
external sources. Note that there is also a build-time option that permanently
locks out the use of \C.
<P>
<BR>&nbsp;&nbsp;PCRE2_NEVER_UCP
<P>
This option locks out the use of Unicode properties for handling \B, \b, \D,
\d, \S, \s, \W, \w, and some of the POSIX character classes, as described
for the PCRE2_UCP option below. In particular, it prevents the creator of the
pattern from enabling this facility by starting the pattern with (*UCP). This
option may be useful in applications that process patterns from external
sources. The option combination PCRE_UCP and PCRE_NEVER_UCP causes an error.
<P>
<BR>&nbsp;&nbsp;PCRE2_NEVER_UTF
<P>
This option locks out interpretation of the pattern as UTF-8, UTF-16, or
UTF-32, depending on which library is in use. In particular, it prevents the
creator of the pattern from switching to UTF interpretation by starting the
pattern with (*UTF). This option may be useful in applications that process
patterns from external sources. The combination of PCRE2_UTF and
PCRE2_NEVER_UTF causes an error.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_AUTO_CAPTURE
<P>
If this option is set, it disables the use of numbered capturing parentheses in
the pattern. Any opening parenthesis that is not followed by ? behaves as if it
were followed by ?: but named parentheses can still be used for capturing (and
they acquire numbers in the usual way). This is the same as Perl's /n option.
Note that, when this option is set, references to capture groups
(backreferences or recursion/subroutine calls) may only refer to named groups,
though the reference can be by name or by number.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_AUTO_POSSESS
<P>
If this option is set, it disables &quot;auto-possessification&quot;, which is an
optimization that, for example, turns a+b into a++b in order to avoid
backtracks into a+ that can never be successful. However, if callouts are in
use, auto-possessification means that some callouts are never taken. You can
set this option if you want the matching functions to do a full unoptimized
search and run all the callouts, but it is mainly provided for testing
purposes.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_DOTSTAR_ANCHOR
<P>
If this option is set, it disables an optimization that is applied when .* is
the first significant item in a top-level branch of a pattern, and all the
other branches also start with .* or with \A or \G or ^. The optimization is
automatically disabled for .* if it is inside an atomic group or a capture
group that is the subject of a backreference, or if the pattern contains
(*PRUNE) or (*SKIP). When the optimization is not disabled, such a pattern is
automatically anchored if PCRE2_DOTALL is set for all the .* items and
PCRE2_MULTILINE is not set for any ^ items. Otherwise, the fact that any match
must start either at the start of the subject or following a newline is
remembered. Like other optimizations, this can cause callouts to be skipped.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_START_OPTIMIZE
<P>
This is an option whose main effect is at matching time. It does not change
what <B>pcre2_compile()</B> generates, but it does affect the output of the JIT
compiler.
<P>

There are a number of optimizations that may occur at the start of a match, in
order to speed up the process. For example, if it is known that an unanchored
match must start with a specific code unit value, the matching code searches
the subject for that value, and fails immediately if it cannot find it, without
actually running the main matching function. This means that a special item
such as (*COMMIT) at the start of a pattern is not considered until after a
suitable starting point for the match has been found. Also, when callouts or
(*MARK) items are in use, these &quot;start-up&quot; optimizations can cause them to be
skipped if the pattern is never actually used. The start-up optimizations are
in effect a pre-scan of the subject that takes place before the pattern is run.
<P>

The PCRE2_NO_START_OPTIMIZE option disables the start-up optimizations,
possibly causing performance to suffer, but ensuring that in cases where the
result is &quot;no match&quot;, the callouts do occur, and that items such as (*COMMIT)
and (*MARK) are considered at every possible starting position in the subject
string.
<P>

Setting PCRE2_NO_START_OPTIMIZE may change the outcome of a matching operation.
Consider the pattern
<P>
<BR>&nbsp;&nbsp;(*COMMIT)ABC
<P>
When this is compiled, PCRE2 records the fact that a match must start with the
character &quot;A&quot;. Suppose the subject string is &quot;DEFABC&quot;. The start-up
optimization scans along the subject, finds &quot;A&quot; and runs the first match
attempt from there. The (*COMMIT) item means that the pattern must match the
current starting position, which in this case, it does. However, if the same
match is run with PCRE2_NO_START_OPTIMIZE set, the initial scan along the
subject string does not happen. The first match attempt is run starting from
&quot;D&quot; and when this fails, (*COMMIT) prevents any further matches being tried, so
the overall result is &quot;no match&quot;.
<P>

As another start-up optimization makes use of a minimum length for a matching
subject, which is recorded when possible. Consider the pattern
<P>
<BR>&nbsp;&nbsp;(*MARK:1)B(*MARK:2)(X|Y)
<P>
The minimum length for a match is two characters. If the subject is &quot;XXBB&quot;, the
&quot;starting character&quot; optimization skips &quot;XX&quot;, then tries to match &quot;BB&quot;, which
is long enough. In the process, (*MARK:2) is encountered and remembered. When
the match attempt fails, the next &quot;B&quot; is found, but there is only one character
left, so there are no more attempts, and &quot;no match&quot; is returned with the &quot;last
mark seen&quot; set to &quot;2&quot;. If NO_START_OPTIMIZE is set, however, matches are tried
at every possible starting position, including at the end of the subject, where
(*MARK:1) is encountered, but there is no &quot;B&quot;, so the &quot;last mark seen&quot; that is
returned is &quot;1&quot;. In this case, the optimizations do not affect the overall
match result, which is still &quot;no match&quot;, but they do affect the auxiliary
information that is returned.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_UTF_CHECK
<P>
When PCRE2_UTF is set, the validity of the pattern as a UTF string is
automatically checked. There are discussions about the validity of


UTF-8 strings,



UTF-16 strings,

and


UTF-32 strings

in the

<B>pcre2unicode</B>

document. If an invalid UTF sequence is found, <B>pcre2_compile()</B> returns a
negative error code.
<P>

If you know that your pattern is a valid UTF string, and you want to skip this
check for performance reasons, you can set the PCRE2_NO_UTF_CHECK option. When
it is set, the effect of passing an invalid UTF string as a pattern is
undefined. It may cause your program to crash or loop.
<P>

Note that this option can also be passed to <B>pcre2_match()</B> and
<B>pcre_dfa_match()</B>, to suppress UTF validity checking of the subject
string.
<P>

Note also that setting PCRE2_NO_UTF_CHECK at compile time does not disable the
error that is given if an escape sequence for an invalid Unicode code point is
encountered in the pattern. In particular, the so-called &quot;surrogate&quot; code
points (0xd800 to 0xdfff) are invalid. If you want to allow escape sequences
such as \x{d800} you can set the PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES extra
option, as described in the section entitled &quot;Extra compile options&quot;


below.

However, this is possible only in UTF-8 and UTF-32 modes, because these values
are not representable in UTF-16.
<P>
<BR>&nbsp;&nbsp;PCRE2_UCP
<P>
This option changes the way PCRE2 processes \B, \b, \D, \d, \S, \s, \W,
\w, and some of the POSIX character classes. By default, only ASCII characters
are recognized, but if PCRE2_UCP is set, Unicode properties are used instead to
classify characters. More details are given in the section on


generic character types

in the

<B>pcre2pattern</B>

page. If you set PCRE2_UCP, matching one of the items it affects takes much
longer. The option is available only if PCRE2 has been compiled with Unicode
support (which is the default).
<P>
<BR>&nbsp;&nbsp;PCRE2_UNGREEDY
<P>
This option inverts the &quot;greediness&quot; of the quantifiers so that they are not
greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible
with Perl. It can also be set by a (?U) option setting within the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_USE_OFFSET_LIMIT
<P>
This option must be set for <B>pcre2_compile()</B> if
<B>pcre2_set_offset_limit()</B> is going to be used to set a non-default offset
limit in a match context for matches that use this pattern. An error is
generated if an offset limit is set without this option. For more details, see
the description of <B>pcre2_set_offset_limit()</B> in the


section

that describes match contexts. See also the PCRE2_FIRSTLINE
option above.
<P>
<BR>&nbsp;&nbsp;PCRE2_UTF
<P>
This option causes PCRE2 to regard both the pattern and the subject strings
that are subsequently processed as strings of UTF characters instead of
single-code-unit strings. It is available when PCRE2 is built to include
Unicode support (which is the default). If Unicode support is not available,
the use of this option provokes an error. Details of how PCRE2_UTF changes the
behaviour of PCRE2 are given in the

<B>pcre2unicode</B>

page. In particular, note that it changes the way PCRE2_CASELESS handles
characters with code points greater than 127.

<A NAME="lbBD">&nbsp;</A>
<H3>Extra compile options</H3>


<P>
The option bits that can be set in a compile context by calling the
<B>pcre2_set_compile_extra_options()</B> function are as follows:
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES
<P>
This option applies when compiling a pattern in UTF-8 or UTF-32 mode. It is
forbidden in UTF-16 mode, and ignored in non-UTF modes. Unicode &quot;surrogate&quot;
code points in the range 0xd800 to 0xdfff are used in pairs in UTF-16 to encode
code points with values in the range 0x10000 to 0x10ffff. The surrogates cannot
therefore be represented in UTF-16. They can be represented in UTF-8 and
UTF-32, but are defined as invalid code points, and cause errors if encountered
in a UTF-8 or UTF-32 string that is being checked for validity by PCRE2.
<P>

These values also cause errors if encountered in escape sequences such as
\x{d912} within a pattern. However, it seems that some applications, when
using PCRE2 to check for unwanted characters in UTF-8 strings, explicitly test
for the surrogates using escape sequences. The PCRE2_NO_UTF_CHECK option does
not disable the error that occurs, because it applies only to the testing of
input strings for UTF validity.
<P>

If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is set, surrogate code
point values in UTF-8 and UTF-32 patterns no longer provoke errors and are
incorporated in the compiled pattern. However, they can only match subject
characters if the matching function is called with PCRE2_NO_UTF_CHECK set.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_ALT_BSUX
<P>
The original option PCRE2_ALT_BSUX causes PCRE2 to process \U, \u, and \x in
the way that ECMAscript (aka JavaScript) does. Additional functionality was
defined by ECMAscript 6; setting PCRE2_EXTRA_ALT_BSUX has the effect of
PCRE2_ALT_BSUX, but in addition it recognizes \u{hhh..} as a hexadecimal
character code, where hhh.. is any number of hexadecimal digits.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL
<P>
This is a dangerous option. Use with care. By default, an unrecognized escape
such as \j or a malformed one such as \x{2z} causes a compile-time error when
detected by <B>pcre2_compile()</B>. Perl is somewhat inconsistent in handling
such items: for example, \j is treated as a literal &quot;j&quot;, and non-hexadecimal
digits in \x{} are just ignored, though warnings are given in both cases if
Perl's warning switch is enabled. However, a malformed octal number after \o{
always causes an error in Perl.
<P>

If the PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL extra option is passed to
<B>pcre2_compile()</B>, all unrecognized or malformed escape sequences are
treated as single-character escapes. For example, \j is a literal &quot;j&quot; and
\x{2z} is treated as the literal string &quot;x{2z}&quot;. Setting this option means
that typos in patterns may go undetected and have unexpected results. Also note
that a sequence such as [\N{] is interpreted as a malformed attempt at
[\N{...}] and so is treated as [N{] whereas [\N] gives an error because an
unqualified \N is a valid escape sequence but is not supported in a character
class. To reiterate: this is a dangerous option. Use with great care.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_ESCAPED_CR_IS_LF
<P>
There are some legacy applications where the escape sequence \r in a pattern
is expected to match a newline. If this option is set, \r in a pattern is
converted to \n so that it matches a LF (linefeed) instead of a CR (carriage
return) character. The option does not affect a literal CR in the pattern, nor
does it affect CR specified as an explicit code point such as \x{0D}.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_MATCH_LINE
<P>
This option is provided for use by the <B>-x</B> option of <B>pcre2grep</B>. It
causes the pattern only to match complete lines. This is achieved by
automatically inserting the code for &quot;^(?:&quot; at the start of the compiled
pattern and &quot;)$&quot; at the end. Thus, when PCRE2_MULTILINE is set, the matched
line may be in the middle of the subject string. This option can be used with
PCRE2_LITERAL.
<P>
<BR>&nbsp;&nbsp;PCRE2_EXTRA_MATCH_WORD
<P>
This option is provided for use by the <B>-w</B> option of <B>pcre2grep</B>. It
causes the pattern only to match strings that have a word boundary at the start
and the end. This is achieved by automatically inserting the code for &quot;\b(?:&quot;
at the start of the compiled pattern and &quot;)\b&quot; at the end. The option may be
used with PCRE2_LITERAL. However, it is ignored if PCRE2_EXTRA_MATCH_LINE is
also set.

<A NAME="lbBE">&nbsp;</A>
<H2>JUST-IN-TIME (JIT) COMPILATION</H2>


<P>
<PRE>
<B>int pcre2_jit_compile(pcre2_code *</B><I>code</I>, uint32_t <I>options</I>);

<B>int pcre2_jit_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>);

<B>void pcre2_jit_free_unused_memory(pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_jit_stack *pcre2_jit_stack_create(PCRE2_SIZE </B><I>startsize</I>,
<B>  PCRE2_SIZE </B><I>maxsize</I>, pcre2_general_context *<I>gcontext</I>);

<B>void pcre2_jit_stack_assign(pcre2_match_context *</B><I>mcontext</I>,
<B>  pcre2_jit_callback </B><I>callback_function</I>, void *<I>callback_data</I>);

<B>void pcre2_jit_stack_free(pcre2_jit_stack *</B><I>jit_stack</I>);
</PRE>

<P>

These functions provide support for JIT compilation, which, if the just-in-time
compiler is available, further processes a compiled pattern into machine code
that executes much faster than the <B>pcre2_match()</B> interpretive matching
function. Full details are given in the

<B>pcre2jit</B>

documentation.
<P>

JIT compilation is a heavyweight optimization. It can take some time for
patterns to be analyzed, and for one-off matches and simple patterns the
benefit of faster execution might be offset by a much slower compilation time.
Most (but not all) patterns can be optimized by the JIT compiler.

<A NAME="lbBF">&nbsp;</A>
<H2>LOCALE SUPPORT</H2>


<P>
<PRE>
<B>const uint8_t *pcre2_maketables(pcre2_general_context *</B><I>gcontext</I>);

<B>void pcre2_maketables_free(pcre2_general_context *</B><I>gcontext</I>,
<B>  const uint8_t *</B><I>tables</I>);
</PRE>

<P>

PCRE2 handles caseless matching, and determines whether characters are letters,
digits, or whatever, by reference to a set of tables, indexed by character code
point. However, this applies only to characters whose code points are less than
256. By default, higher-valued code points never match escapes such as \w or
\d. When PCRE2 is built with Unicode support (the default), all characters can
be tested with \p and \P, or, alternatively, the PCRE2_UCP option can be set
when a pattern is compiled; this causes \w and friends to use Unicode property
support instead of the built-in tables.
<P>

The use of locales with Unicode is discouraged. If you are handling characters
with code points greater than 128, you should either use Unicode support, or
use locales, but not try to mix the two.
<P>

PCRE2 contains a built-in set of character tables that are used by default.
These are sufficient for many applications. Normally, the internal tables
recognize only ASCII characters. However, when PCRE2 is built, it is possible
to cause the internal tables to be rebuilt in the default &quot;C&quot; locale of the
local system, which may cause them to be different.
<P>

The built-in tables can be overridden by tables supplied by the application
that calls PCRE2. These may be created in a different locale from the default.
As more and more applications change to using Unicode, the need for this locale
support is expected to die away.
<P>

External tables are built by calling the <B>pcre2_maketables()</B> function, in
the relevant locale. The only argument to this function is a general context,
which can be used to pass a custom memory allocator. If the argument is NULL,
the system <B>malloc()</B> is used. The result can be passed to
<B>pcre2_compile()</B> as often as necessary, by creating a compile context and
calling <B>pcre2_set_character_tables()</B> to set the tables pointer therein.
<P>

For example, to build and use tables that are appropriate for the French locale
(where accented characters with values greater than 128 are treated as
letters), the following code could be used:
<P>
<BR>&nbsp;&nbsp;setlocale(LC_CTYPE,&nbsp;&quot;fr_FR&quot;);
<BR>&nbsp;&nbsp;tables&nbsp;=&nbsp;pcre2_maketables(NULL);
<BR>&nbsp;&nbsp;ccontext&nbsp;=&nbsp;pcre2_compile_context_create(NULL);
<BR>&nbsp;&nbsp;pcre2_set_character_tables(ccontext,&nbsp;tables);
<BR>&nbsp;&nbsp;re&nbsp;=&nbsp;pcre2_compile(...,&nbsp;ccontext);
<P>
The locale name &quot;fr_FR&quot; is used on Linux and other Unix-like systems; if you
are using Windows, the name for the French locale is &quot;french&quot;.
<P>

The pointer that is passed (via the compile context) to <B>pcre2_compile()</B>
is saved with the compiled pattern, and the same tables are used by
<B>pcre2_match()</B> and <B>pcre_dfa_match()</B>. Thus, for any single pattern,
compilation and matching both happen in the same locale, but different patterns
can be processed in different locales.
<P>

It is the caller's responsibility to ensure that the memory containing the
tables remains available while they are still in use. When they are no longer
needed, you can discard them using <B>pcre2_maketables_free()</B>, which should
pass as its first parameter the same global context that was used to create the
tables.

<A NAME="lbBG">&nbsp;</A>
<H2>INFORMATION ABOUT A COMPILED PATTERN</H2>


<P>
<PRE>
<B>int pcre2_pattern_info(const pcre2 *</B><I>code</I>, uint32_t <I>what</I>, void *<I>where</I>);
</PRE>

<P>

The <B>pcre2_pattern_info()</B> function returns general information about a
compiled pattern. For information about callouts, see the


next section.

The first argument for <B>pcre2_pattern_info()</B> is a pointer to the compiled
pattern. The second argument specifies which piece of information is required,
and the third argument is a pointer to a variable to receive the data. If the
third argument is NULL, the first argument is ignored, and the function returns
the size in bytes of the variable that is required for the information
requested. Otherwise, the yield of the function is zero for success, or one of
the following negative numbers:
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;argument&nbsp;<I>code</I>&nbsp;was&nbsp;NULL
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADMAGIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;&quot;magic&nbsp;number&quot;&nbsp;was&nbsp;not&nbsp;found
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADOPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;value&nbsp;of&nbsp;<I>what</I>&nbsp;was&nbsp;invalid
<BR>&nbsp;&nbsp;PCRE2_ERROR_UNSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;requested&nbsp;field&nbsp;is&nbsp;not&nbsp;set
<P>
The &quot;magic number&quot; is placed at the start of each compiled pattern as a simple
check against passing an arbitrary memory pointer. Here is a typical call of
<B>pcre2_pattern_info()</B>, to obtain the length of the compiled pattern:
<P>
<BR>&nbsp;&nbsp;int&nbsp;rc;
<BR>&nbsp;&nbsp;size_t&nbsp;length;
<BR>&nbsp;&nbsp;rc&nbsp;=&nbsp;pcre2_pattern_info(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre2_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;PCRE2_INFO_SIZE,&nbsp;&nbsp;/*&nbsp;what&nbsp;is&nbsp;required&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;where&nbsp;to&nbsp;put&nbsp;the&nbsp;data&nbsp;*/
<P>
The possible values for the second argument are defined in <B>pcre2.h</B>, and
are as follows:
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_ALLOPTIONS
<BR>&nbsp;&nbsp;PCRE2_INFO_ARGOPTIONS
<BR>&nbsp;&nbsp;PCRE2_INFO_EXTRAOPTIONS
<P>
Return copies of the pattern's options. The third argument should point to a
<B>uint32_t</B> variable. PCRE2_INFO_ARGOPTIONS returns exactly the options that
were passed to <B>pcre2_compile()</B>, whereas PCRE2_INFO_ALLOPTIONS returns
the compile options as modified by any top-level (*XXX) option settings such as
(*UTF) at the start of the pattern itself. PCRE2_INFO_EXTRAOPTIONS returns the
extra options that were set in the compile context by calling the
pcre2_set_compile_extra_options() function.
<P>

For example, if the pattern /(*UTF)abc/ is compiled with the PCRE2_EXTENDED
option, the result for PCRE2_INFO_ALLOPTIONS is PCRE2_EXTENDED and PCRE2_UTF.
Option settings such as (?i) that can change within a pattern do not affect the
result of PCRE2_INFO_ALLOPTIONS, even if they appear right at the start of the
pattern. (This was different in some earlier releases.)
<P>

A pattern compiled without PCRE2_ANCHORED is automatically anchored by PCRE2 if
the first significant item in every top-level branch is one of the following:
<P>
<BR>&nbsp;&nbsp;^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless&nbsp;PCRE2_MULTILINE&nbsp;is&nbsp;set
<BR>&nbsp;&nbsp;\A&nbsp;&nbsp;&nbsp;&nbsp;always
<BR>&nbsp;&nbsp;\G&nbsp;&nbsp;&nbsp;&nbsp;always
<BR>&nbsp;&nbsp;.*&nbsp;&nbsp;&nbsp;&nbsp;sometimes&nbsp;-&nbsp;see&nbsp;below
<P>
When .* is the first significant item, anchoring is possible only when all the
following are true:
<P>
<BR>&nbsp;&nbsp;.*&nbsp;is&nbsp;not&nbsp;in&nbsp;an&nbsp;atomic&nbsp;group

<BR>&nbsp;&nbsp;.*&nbsp;is&nbsp;not&nbsp;in&nbsp;a&nbsp;capture&nbsp;group&nbsp;that&nbsp;is&nbsp;the&nbsp;subject
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;a&nbsp;backreference
<BR>&nbsp;&nbsp;PCRE2_DOTALL&nbsp;is&nbsp;in&nbsp;force&nbsp;for&nbsp;.*
<BR>&nbsp;&nbsp;Neither&nbsp;(*PRUNE)&nbsp;nor&nbsp;(*SKIP)&nbsp;appears&nbsp;in&nbsp;the&nbsp;pattern
<BR>&nbsp;&nbsp;PCRE2_NO_DOTSTAR_ANCHOR&nbsp;is&nbsp;not&nbsp;set
<P>
For patterns that are auto-anchored, the PCRE2_ANCHORED bit is set in the
options returned for PCRE2_INFO_ALLOPTIONS.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_BACKREFMAX
<P>
Return the number of the highest backreference in the pattern. The third
argument should point to a <B>uint32_t</B> variable. Named capture groups
acquire numbers as well as names, and these count towards the highest
backreference. Backreferences such as \4 or \g{12} match the captured
characters of the given group, but in addition, the check that a capture
group is set in a conditional group such as (?(3)a|b) is also a backreference.
Zero is returned if there are no backreferences.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_BSR
<P>
The output is a uint32_t integer whose value indicates what character sequences
the \R escape sequence matches. A value of PCRE2_BSR_UNICODE means that \R
matches any Unicode line ending sequence; a value of PCRE2_BSR_ANYCRLF means
that \R matches only CR, LF, or CRLF.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_CAPTURECOUNT
<P>
Return the highest capture group number in the pattern. In patterns where (?|
is not used, this is also the total number of capture groups. The third
argument should point to a <B>uint32_t</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_DEPTHLIMIT
<P>
If the pattern set a backtracking depth limit by including an item of the form
(*LIMIT_DEPTH=nnnn) at the start, the value is returned. The third argument
should point to a uint32_t integer. If no such value has been set, the call to
<B>pcre2_pattern_info()</B> returns the error PCRE2_ERROR_UNSET. Note that this
limit will only be used during matching if it is less than the limit set or
defaulted by the caller of the match function.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_FIRSTBITMAP
<P>
In the absence of a single first code unit for a non-anchored pattern,
<B>pcre2_compile()</B> may construct a 256-bit table that defines a fixed set of
values for the first code unit in any match. For example, a pattern that starts
with [abc] results in a table with three bits set. When code unit values
greater than 255 are supported, the flag bit for 255 means &quot;any code unit of
value 255 or above&quot;. If such a table was constructed, a pointer to it is
returned. Otherwise NULL is returned. The third argument should point to a
<B>const uint8_t *</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_FIRSTCODETYPE
<P>
Return information about the first code unit of any matched string, for a
non-anchored pattern. The third argument should point to a <B>uint32_t</B>
variable. If there is a fixed first value, for example, the letter &quot;c&quot; from a
pattern such as (cat|cow|coyote), 1 is returned, and the value can be retrieved
using PCRE2_INFO_FIRSTCODEUNIT. If there is no fixed first value, but it is
known that a match can occur only at the start of the subject or following a
newline in the subject, 2 is returned. Otherwise, and for anchored patterns, 0
is returned.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_FIRSTCODEUNIT
<P>
Return the value of the first code unit of any matched string for a pattern
where PCRE2_INFO_FIRSTCODETYPE returns 1; otherwise return 0. The third
argument should point to a <B>uint32_t</B> variable. In the 8-bit library, the
value is always less than 256. In the 16-bit library the value can be up to
0xffff. In the 32-bit library in UTF-32 mode the value can be up to 0x10ffff,
and up to 0xffffffff when not using UTF-32 mode.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_FRAMESIZE
<P>
Return the size (in bytes) of the data frames that are used to remember
backtracking positions when the pattern is processed by <B>pcre2_match()</B>
without the use of JIT. The third argument should point to a <B>size_t</B>
variable. The frame size depends on the number of capturing parentheses in the
pattern. Each additional capture group adds two PCRE2_SIZE variables.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_HASBACKSLASHC
<P>
Return 1 if the pattern contains any instances of \C, otherwise 0. The third
argument should point to a <B>uint32_t</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_HASCRORLF
<P>
Return 1 if the pattern contains any explicit matches for CR or LF characters,
otherwise 0. The third argument should point to a <B>uint32_t</B> variable. An
explicit match is either a literal CR or LF character, or \r or \n or one of
the equivalent hexadecimal or octal escape sequences.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_HEAPLIMIT
<P>
If the pattern set a heap memory limit by including an item of the form
(*LIMIT_HEAP=nnnn) at the start, the value is returned. The third argument
should point to a uint32_t integer. If no such value has been set, the call to
<B>pcre2_pattern_info()</B> returns the error PCRE2_ERROR_UNSET. Note that this
limit will only be used during matching if it is less than the limit set or
defaulted by the caller of the match function.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_JCHANGED
<P>
Return 1 if the (?J) or (?-J) option setting is used in the pattern, otherwise
0. The third argument should point to a <B>uint32_t</B> variable. (?J) and
(?-J) set and unset the local PCRE2_DUPNAMES option, respectively.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_JITSIZE
<P>
If the compiled pattern was successfully processed by
<B>pcre2_jit_compile()</B>, return the size of the JIT compiled code, otherwise
return zero. The third argument should point to a <B>size_t</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_LASTCODETYPE
<P>
Returns 1 if there is a rightmost literal code unit that must exist in any
matched string, other than at its start. The third argument should  point to a
<B>uint32_t</B> variable. If there is no such value, 0 is returned. When 1 is
returned, the code unit value itself can be retrieved using
PCRE2_INFO_LASTCODEUNIT. For anchored patterns, a last literal value is
recorded only if it follows something of variable length. For example, for the
pattern /^a\d+z\d+/ the returned value is 1 (with &quot;z&quot; returned from
PCRE2_INFO_LASTCODEUNIT), but for /^a\dz\d/ the returned value is 0.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_LASTCODEUNIT
<P>
Return the value of the rightmost literal code unit that must exist in any
matched string, other than at its start, for a pattern where
PCRE2_INFO_LASTCODETYPE returns 1. Otherwise, return 0. The third argument
should point to a <B>uint32_t</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_MATCHEMPTY
<P>
Return 1 if the pattern might match an empty string, otherwise 0. The third
argument should point to a <B>uint32_t</B> variable. When a pattern contains
recursive subroutine calls it is not always possible to determine whether or
not it can match an empty string. PCRE2 takes a cautious approach and returns 1
in such cases.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_MATCHLIMIT
<P>
If the pattern set a match limit by including an item of the form
(*LIMIT_MATCH=nnnn) at the start, the value is returned. The third argument
should point to a uint32_t integer. If no such value has been set, the call to
<B>pcre2_pattern_info()</B> returns the error PCRE2_ERROR_UNSET. Note that this
limit will only be used during matching if it is less than the limit set or
defaulted by the caller of the match function.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_MAXLOOKBEHIND
<P>
A lookbehind assertion moves back a certain number of characters (not code
units) when it starts to process each of its branches. This request returns the
largest of these backward moves. The third argument should point to a uint32_t
integer. The simple assertions \b and \B require a one-character lookbehind
and cause PCRE2_INFO_MAXLOOKBEHIND to return 1 in the absence of anything
longer. \A also registers a one-character lookbehind, though it does not
actually inspect the previous character.
<P>

Note that this information is useful for multi-segment matching only
if the pattern contains no nested lookbehinds. For example, the pattern
(?&lt;=a(?&lt;=ba)c) returns a maximum lookbehind of 2, but when it is processed, the
first lookbehind moves back by two characters, matches one character, then the
nested lookbehind also moves back by two characters. This puts the matching
point three characters earlier than it was at the start.
PCRE2_INFO_MAXLOOKBEHIND is really only useful as a debugging tool. See the

<B>pcre2partial</B>

documentation for a discussion of multi-segment matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_MINLENGTH
<P>
If a minimum length for matching subject strings was computed, its value is
returned. Otherwise the returned value is 0. This value is not computed when
PCRE2_NO_START_OPTIMIZE is set. The value is a number of characters, which in
UTF mode may be different from the number of code units. The third argument
should point to a <B>uint32_t</B> variable. The value is a lower bound to the
length of any matching string. There may not be any strings of that length that
do actually match, but every string that does match is at least that long.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_NAMECOUNT
<BR>&nbsp;&nbsp;PCRE2_INFO_NAMEENTRYSIZE
<BR>&nbsp;&nbsp;PCRE2_INFO_NAMETABLE
<P>
PCRE2 supports the use of named as well as numbered capturing parentheses. The
names are just an additional way of identifying the parentheses, which still
acquire numbers. Several convenience functions such as
<B>pcre2_substring_get_byname()</B> are provided for extracting captured
substrings by name. It is also possible to extract the data directly, by first
converting the name to a number in order to access the correct pointers in the
output vector (described with <B>pcre2_match()</B> below). To do the conversion,
you need to use the name-to-number map, which is described by these three
values.
<P>

The map consists of a number of fixed-size entries. PCRE2_INFO_NAMECOUNT gives
the number of entries, and PCRE2_INFO_NAMEENTRYSIZE gives the size of each
entry in code units; both of these return a <B>uint32_t</B> value. The entry
size depends on the length of the longest name.
<P>

PCRE2_INFO_NAMETABLE returns a pointer to the first entry of the table. This is
a PCRE2_SPTR pointer to a block of code units. In the 8-bit library, the first
two bytes of each entry are the number of the capturing parenthesis, most
significant byte first. In the 16-bit library, the pointer points to 16-bit
code units, the first of which contains the parenthesis number. In the 32-bit
library, the pointer points to 32-bit code units, the first of which contains
the parenthesis number. The rest of the entry is the corresponding name, zero
terminated.
<P>

The names are in alphabetical order. If (?| is used to create multiple capture
groups with the same number, as described in the


section on duplicate group numbers

in the

<B>pcre2pattern</B>

page, the groups may be given the same name, but there is only one entry in the
table. Different names for groups of the same number are not permitted.
<P>

Duplicate names for capture groups with different numbers are permitted, but
only if PCRE2_DUPNAMES is set. They appear in the table in the order in which
they were found in the pattern. In the absence of (?| this is the order of
increasing number; when (?| is used this is not necessarily the case because
later capture groups may have lower numbers.
<P>

As a simple example of the name/number table, consider the following pattern
after compilation by the 8-bit library (assume PCRE2_EXTENDED is set, so white
space - including newlines - is ignored):
<P>

<BR>&nbsp;&nbsp;(?&lt;date&gt;&nbsp;(?&lt;year&gt;(\d\d)?\d\d)&nbsp;-
<BR>&nbsp;&nbsp;(?&lt;month&gt;\d\d)&nbsp;-&nbsp;(?&lt;day&gt;\d\d)&nbsp;)
<P>
There are four named capture groups, so the table has four entries, and each
entry in the table is eight bytes long. The table is as follows, with
non-printing bytes shows in hexadecimal, and undefined bytes shown as ??:
<P>
<BR>&nbsp;&nbsp;00&nbsp;01&nbsp;d&nbsp;&nbsp;a&nbsp;&nbsp;t&nbsp;&nbsp;e&nbsp;&nbsp;00&nbsp;??
<BR>&nbsp;&nbsp;00&nbsp;05&nbsp;d&nbsp;&nbsp;a&nbsp;&nbsp;y&nbsp;&nbsp;00&nbsp;??&nbsp;??
<BR>&nbsp;&nbsp;00&nbsp;04&nbsp;m&nbsp;&nbsp;o&nbsp;&nbsp;n&nbsp;&nbsp;t&nbsp;&nbsp;h&nbsp;&nbsp;00
<BR>&nbsp;&nbsp;00&nbsp;02&nbsp;y&nbsp;&nbsp;e&nbsp;&nbsp;a&nbsp;&nbsp;r&nbsp;&nbsp;00&nbsp;??
<P>
When writing code to extract data from named capture groups using the
name-to-number map, remember that the length of the entries is likely to be
different for each compiled pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_NEWLINE
<P>
The output is one of the following <B>uint32_t</B> values:
<P>
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_CR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carriage&nbsp;return&nbsp;(CR)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_LF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linefeed&nbsp;(LF)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_CRLF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Carriage&nbsp;return,&nbsp;linefeed&nbsp;(CRLF)
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_ANY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Any&nbsp;Unicode&nbsp;line&nbsp;ending
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_ANYCRLF&nbsp;&nbsp;Any&nbsp;of&nbsp;CR,&nbsp;LF,&nbsp;or&nbsp;CRLF
<BR>&nbsp;&nbsp;PCRE2_NEWLINE_NUL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;NUL&nbsp;character&nbsp;(binary&nbsp;zero)
<P>
This identifies the character sequence that will be recognized as meaning
&quot;newline&quot; while matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_INFO_SIZE
<P>
Return the size of the compiled pattern in bytes (for all three libraries). The
third argument should point to a <B>size_t</B> variable. This value includes the
size of the general data block that precedes the code units of the compiled
pattern itself. The value that is used when <B>pcre2_compile()</B> is getting
memory in which to place the compiled pattern may be slightly larger than the
value returned by this option, because there are cases where the code that
calculates the size has to over-estimate. Processing a pattern with the JIT
compiler does not alter the value returned by this option.

<A NAME="lbBH">&nbsp;</A>
<H2>INFORMATION ABOUT A PATTERN'S CALLOUTS</H2>


<P>
<PRE>
<B>int pcre2_callout_enumerate(const pcre2_code *</B><I>code</I>,
<B>  int (*</B><I>callback</I>)(pcre2_callout_enumerate_block *, void *),
<B>  void *</B><I>user_data</I>);
</PRE>

<P>
A script language that supports the use of string arguments in callouts might
like to scan all the callouts in a pattern before running the match. This can
be done by calling <B>pcre2_callout_enumerate()</B>. The first argument is a
pointer to a compiled pattern, the second points to a callback function, and
the third is arbitrary user data. The callback function is called for every
callout in the pattern in the order in which they appear. Its first argument is
a pointer to a callout enumeration block, and its second argument is the
<I>user_data</I> value that was passed to <B>pcre2_callout_enumerate()</B>. The
contents of the callout enumeration block are described in the

<B>pcre2callout</B>

documentation, which also gives further details about callouts.
<A NAME="lbBI">&nbsp;</A>
<H2>SERIALIZATION AND PRECOMPILING</H2>


<P>
It is possible to save compiled patterns on disc or elsewhere, and reload them
later, subject to a number of restrictions. The host on which the patterns are
reloaded must be running the same version of PCRE2, with the same code unit
width, and must also have the same endianness, pointer width, and PCRE2_SIZE
type. Before compiled patterns can be saved, they must be converted to a
&quot;serialized&quot; form, which in the case of PCRE2 is really just a bytecode dump.
The functions whose names begin with <B>pcre2_serialize_</B> are used for
converting to and from the serialized form. They are described in the

<B>pcre2serialize</B>

documentation. Note that PCRE2 serialization does not convert compiled patterns
to an abstract format like Java or .NET serialization.

<A NAME="lbBJ">&nbsp;</A>
<H2>THE MATCH DATA BLOCK</H2>


<P>
<PRE>
<B>pcre2_match_data *pcre2_match_data_create(uint32_t </B><I>ovecsize</I>,
<B>  pcre2_general_context *</B><I>gcontext</I>);

<B>pcre2_match_data *pcre2_match_data_create_from_pattern(</B>
<B>  const pcre2_code *</B><I>code</I>, pcre2_general_context *<I>gcontext</I>);

<B>void pcre2_match_data_free(pcre2_match_data *</B><I>match_data</I>);
</PRE>

<P>

Information about a successful or unsuccessful match is placed in a match
data block, which is an opaque structure that is accessed by function calls. In
particular, the match data block contains a vector of offsets into the subject
string that define the matched part of the subject and any substrings that were
captured. This is known as the <I>ovector</I>.
<P>

Before calling <B>pcre2_match()</B>, <B>pcre2_dfa_match()</B>, or
<B>pcre2_jit_match()</B> you must create a match data block by calling one of
the creation functions above. For <B>pcre2_match_data_create()</B>, the first
argument is the number of pairs of offsets in the <I>ovector</I>. One pair of
offsets is required to identify the string that matched the whole pattern, with
an additional pair for each captured substring. For example, a value of 4
creates enough space to record the matched portion of the subject plus three
captured substrings. A minimum of at least 1 pair is imposed by
<B>pcre2_match_data_create()</B>, so it is always possible to return the overall
matched string.
<P>

The second argument of <B>pcre2_match_data_create()</B> is a pointer to a
general context, which can specify custom memory management for obtaining the
memory for the match data block. If you are not using custom memory management,
pass NULL, which causes <B>malloc()</B> to be used.
<P>

For <B>pcre2_match_data_create_from_pattern()</B>, the first argument is a
pointer to a compiled pattern. The ovector is created to be exactly the right
size to hold all the substrings a pattern might capture. The second argument is
again a pointer to a general context, but in this case if NULL is passed, the
memory is obtained using the same allocator that was used for the compiled
pattern (custom or default).
<P>

A match data block can be used many times, with the same or different compiled
patterns. You can extract information from a match data block after a match
operation has finished, using functions that are described in the sections on


matched strings

and


other match data

below.
<P>

When a call of <B>pcre2_match()</B> fails, valid data is available in the match
block only when the error is PCRE2_ERROR_NOMATCH, PCRE2_ERROR_PARTIAL, or one
of the error codes for an invalid UTF string. Exactly what is available depends
on the error, and is detailed below.
<P>

When one of the matching functions is called, pointers to the compiled pattern
and the subject string are set in the match data block so that they can be
referenced by the extraction functions after a successful match. After running
a match, you must not free a compiled pattern or a subject string until after
all operations on the match data block (for that match) have taken place,
unless, in the case of the subject string, you have used the
PCRE2_COPY_MATCHED_SUBJECT option, which is described in the section entitled
&quot;Option bits for <B>pcre2_match()</B>&quot;


below.

<P>

When a match data block itself is no longer needed, it should be freed by
calling <B>pcre2_match_data_free()</B>. If this function is called with a NULL
argument, it returns immediately, without doing anything.
<A NAME="lbBK">&nbsp;</A>
<H2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</H2>


<P>
<PRE>
<B>int pcre2_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>);
</PRE>

<P>

The function <B>pcre2_match()</B> is called to match a subject string against a
compiled pattern, which is passed in the <I>code</I> argument. You can call
<B>pcre2_match()</B> with the same <I>code</I> argument as many times as you
like, in order to find multiple matches in the subject string or to match
different subject strings with the same pattern.
<P>

This function is the main matching facility of the library, and it operates in
a Perl-like manner. For specialist use there is also an alternative matching
function, which is described


below

in the section about the <B>pcre2_dfa_match()</B> function.
<P>

Here is an example of a simple call to <B>pcre2_match()</B>:
<P>
<BR>&nbsp;&nbsp;pcre2_match_data&nbsp;*md&nbsp;=&nbsp;pcre2_match_data_create(4,&nbsp;NULL);
<BR>&nbsp;&nbsp;int&nbsp;rc&nbsp;=&nbsp;pcre2_match(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre2_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;some&nbsp;string&quot;,&nbsp;&nbsp;/*&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;11,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start&nbsp;at&nbsp;offset&nbsp;0&nbsp;in&nbsp;the&nbsp;subject&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;md,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;match&nbsp;data&nbsp;block&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;a&nbsp;match&nbsp;context;&nbsp;NULL&nbsp;means&nbsp;use&nbsp;defaults&nbsp;*/
<P>
If the subject string is zero-terminated, the length can be given as
PCRE2_ZERO_TERMINATED. A match context must be provided if certain less common
matching parameters are to be changed. For details, see the section on


the match context

above.
<A NAME="lbBL">&nbsp;</A>
<H3>The string to be matched by <B>pcre2_match()</B></H3>


<P>
The subject string is passed to <B>pcre2_match()</B> as a pointer in
<I>subject</I>, a length in <I>length</I>, and a starting offset in
<I>startoffset</I>. The length and offset are in code units, not characters.
That is, they are in bytes for the 8-bit library, 16-bit code units for the
16-bit library, and 32-bit code units for the 32-bit library, whether or not
UTF processing is enabled.
<P>

If <I>startoffset</I> is greater than the length of the subject,
<B>pcre2_match()</B> returns PCRE2_ERROR_BADOFFSET. When the starting offset is
zero, the search for a match starts at the beginning of the subject, and this
is by far the most common case. In UTF-8 or UTF-16 mode, the starting offset
must point to the start of a character, or to the end of the subject (in UTF-32
mode, one code unit equals one character, so all offsets are valid). Like the
pattern string, the subject may contain binary zeros.
<P>

A non-zero starting offset is useful when searching for another match in the
same subject by calling <B>pcre2_match()</B> again after a previous success.
Setting <I>startoffset</I> differs from passing over a shortened string and
setting PCRE2_NOTBOL in the case of a pattern that begins with any kind of
lookbehind. For example, consider the pattern
<P>
<BR>&nbsp;&nbsp;\Biss\B
<P>
which finds occurrences of &quot;iss&quot; in the middle of words. (\B matches only if
the current position in the subject is not a word boundary.) When applied to
the string &quot;Mississipi&quot; the first call to <B>pcre2_match()</B> finds the first
occurrence. If <B>pcre2_match()</B> is called again with just the remainder of
the subject, namely &quot;issipi&quot;, it does not match, because \B is always false at
the start of the subject, which is deemed to be a word boundary. However, if
<B>pcre2_match()</B> is passed the entire string again, but with
<I>startoffset</I> set to 4, it finds the second occurrence of &quot;iss&quot; because it
is able to look behind the starting point to discover that it is preceded by a
letter.
<P>

Finding all the matches in a subject is tricky when the pattern can match an
empty string. It is possible to emulate Perl's /g behaviour by first trying the
match again at the same offset, with the PCRE2_NOTEMPTY_ATSTART and
PCRE2_ANCHORED options, and then if that fails, advancing the starting offset
and trying an ordinary match again. There is some code that demonstrates how to
do this in the

<B>pcre2demo</B>

sample program. In the most general case, you have to check to see if the
newline convention recognizes CRLF as a newline, and if so, and the current
character is CR followed by LF, advance the starting offset by two characters
instead of one.
<P>

If a non-zero starting offset is passed when the pattern is anchored, a single
attempt to match at the given offset is made. This can only succeed if the
pattern does not require the match to be at the start of the subject. In other
words, the anchoring must be the result of setting the PCRE2_ANCHORED option or
the use of .* with PCRE2_DOTALL, not by starting the pattern with ^ or \A.

<A NAME="lbBM">&nbsp;</A>
<H3>Option bits for <B>pcre2_match()</B></H3>


<P>
The unused bits of the <I>options</I> argument for <B>pcre2_match()</B> must be
zero. The only bits that may be set are PCRE2_ANCHORED,
PCRE2_COPY_MATCHED_SUBJECT, PCRE2_ENDANCHORED, PCRE2_NOTBOL, PCRE2_NOTEOL,
PCRE2_NOTEMPTY, PCRE2_NOTEMPTY_ATSTART, PCRE2_NO_JIT, PCRE2_NO_UTF_CHECK,
PCRE2_PARTIAL_HARD, and PCRE2_PARTIAL_SOFT. Their action is described below.
<P>

Setting PCRE2_ANCHORED or PCRE2_ENDANCHORED at match time is not supported by
the just-in-time (JIT) compiler. If it is set, JIT matching is disabled and the
interpretive code in <B>pcre2_match()</B> is run. Apart from PCRE2_NO_JIT
(obviously), the remaining options are supported for JIT matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_ANCHORED
<P>
The PCRE2_ANCHORED option limits <B>pcre2_match()</B> to matching at the first
matching position. If a pattern was compiled with PCRE2_ANCHORED, or turned out
to be anchored by virtue of its contents, it cannot be made unachored at
matching time. Note that setting the option at match time disables JIT
matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_COPY_MATCHED_SUBJECT
<P>
By default, a pointer to the subject is remembered in the match data block so
that, after a successful match, it can be referenced by the substring
extraction functions. This means that the subject's memory must not be freed
until all such operations are complete. For some applications where the
lifetime of the subject string is not guaranteed, it may be necessary to make a
copy of the subject string, but it is wasteful to do this unless the match is
successful. After a successful match, if PCRE2_COPY_MATCHED_SUBJECT is set, the
subject is copied and the new pointer is remembered in the match data block
instead of the original subject pointer. The memory allocator that was used for
the match block itself is used. The copy is automatically freed when
<B>pcre2_match_data_free()</B> is called to free the match data block. It is also
automatically freed if the match data block is re-used for another match
operation.
<P>
<BR>&nbsp;&nbsp;PCRE2_ENDANCHORED
<P>
If the PCRE2_ENDANCHORED option is set, any string that <B>pcre2_match()</B>
matches must be right at the end of the subject string. Note that setting the
option at match time disables JIT matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_NOTBOL
<P>
This option specifies that first character of the subject string is not the
beginning of a line, so the circumflex metacharacter should not match before
it. Setting this without having set PCRE2_MULTILINE at compile time causes
circumflex never to match. This option affects only the behaviour of the
circumflex metacharacter. It does not affect \A.
<P>
<BR>&nbsp;&nbsp;PCRE2_NOTEOL
<P>
This option specifies that the end of the subject string is not the end of a
line, so the dollar metacharacter should not match it nor (except in multiline
mode) a newline immediately before it. Setting this without having set
PCRE2_MULTILINE at compile time causes dollar never to match. This option
affects only the behaviour of the dollar metacharacter. It does not affect \Z
or \z.
<P>
<BR>&nbsp;&nbsp;PCRE2_NOTEMPTY
<P>
An empty string is not considered to be a valid match if this option is set. If
there are alternatives in the pattern, they are tried. If all the alternatives
match the empty string, the entire match fails. For example, if the pattern
<P>
<BR>&nbsp;&nbsp;a?b?
<P>
is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it matches an empty
string at the start of the subject. With PCRE2_NOTEMPTY set, this match is not
valid, so <B>pcre2_match()</B> searches further into the string for occurrences
of &quot;a&quot; or &quot;b&quot;.
<P>
<BR>&nbsp;&nbsp;PCRE2_NOTEMPTY_ATSTART
<P>
This is like PCRE2_NOTEMPTY, except that it locks out an empty string match
only at the first matching position, that is, at the start of the subject plus
the starting offset. An empty string match later in the subject is permitted.
If the pattern is anchored, such a match can occur only if the pattern contains
\K.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_JIT
<P>
By default, if a pattern has been successfully processed by
<B>pcre2_jit_compile()</B>, JIT is automatically used when <B>pcre2_match()</B>
is called with options that JIT supports. Setting PCRE2_NO_JIT disables the use
of JIT; it forces matching to be done by the interpreter.
<P>
<BR>&nbsp;&nbsp;PCRE2_NO_UTF_CHECK
<P>
When PCRE2_UTF is set at compile time, the validity of the subject as a UTF
string is checked unless PCRE2_NO_UTF_CHECK is passed to <B>pcre2_match()</B> or
PCRE2_MATCH_INVALID_UTF was passed to <B>pcre2_compile()</B>. The latter special
case is discussed in detail in the

<B>pcre2unicode</B>

documentation.
<P>

In the default case, if a non-zero starting offset is given, the check is
applied only to that part of the subject that could be inspected during
matching, and there is a check that the starting offset points to the first
code unit of a character or to the end of the subject. If there are no
lookbehind assertions in the pattern, the check starts at the starting offset.
Otherwise, it starts at the length of the longest lookbehind before the
starting offset, or at the start of the subject if there are not that many
characters before the starting offset. Note that the sequences \b and \B are
one-character lookbehinds.
<P>

The check is carried out before any other processing takes place, and a
negative error code is returned if the check fails. There are several UTF error
codes for each code unit width, corresponding to different problems with the
code unit sequence. There are discussions about the validity of


UTF-8 strings,



UTF-16 strings,

and


UTF-32 strings

in the

<B>pcre2unicode</B>

documentation.
<P>

If you know that your subject is valid, and you want to skip this check for
performance reasons, you can set the PCRE2_NO_UTF_CHECK option when calling
<B>pcre2_match()</B>. You might want to do this for the second and subsequent
calls to <B>pcre2_match()</B> if you are making repeated calls to find multiple
matches in the same subject string.
<P>

<B>Warning:</B> Unless PCRE2_MATCH_INVALID_UTF was set at compile time, when
PCRE2_NO_UTF_CHECK is set at match time the effect of passing an invalid
string as a subject, or an invalid value of <I>startoffset</I>, is undefined.
Your program may crash or loop indefinitely or give wrong results.
<P>
<BR>&nbsp;&nbsp;PCRE2_PARTIAL_HARD
<BR>&nbsp;&nbsp;PCRE2_PARTIAL_SOFT
<P>
These options turn on the partial matching feature. A partial match occurs if
the end of the subject string is reached successfully, but there are not enough
subject characters to complete the match. In addition, either at least one
character must have been inspected or the pattern must contain a lookbehind, or
the pattern must be one that could match an empty string.
<P>

If this situation arises when PCRE2_PARTIAL_SOFT (but not PCRE2_PARTIAL_HARD)
is set, matching continues by testing any remaining alternatives. Only if no
complete match can be found is PCRE2_ERROR_PARTIAL returned instead of
PCRE2_ERROR_NOMATCH. In other words, PCRE2_PARTIAL_SOFT specifies that the
caller is prepared to handle a partial match, but only if no complete match can
be found.
<P>

If PCRE2_PARTIAL_HARD is set, it overrides PCRE2_PARTIAL_SOFT. In this case, if
a partial match is found, <B>pcre2_match()</B> immediately returns
PCRE2_ERROR_PARTIAL, without considering any other alternatives. In other
words, when PCRE2_PARTIAL_HARD is set, a partial match is considered to be more
important that an alternative complete match.
<P>

There is a more detailed discussion of partial and multi-segment matching, with
examples, in the

<B>pcre2partial</B>

documentation.
<A NAME="lbBN">&nbsp;</A>
<H2>NEWLINE HANDLING WHEN MATCHING</H2>


<P>
When PCRE2 is built, a default newline convention is set; this is usually the
standard convention for the operating system. The default can be overridden in
a


compile context

by calling <B>pcre2_set_newline()</B>. It can also be overridden by starting a
pattern string with, for example, (*CRLF), as described in the


section on newline conventions

in the

<B>pcre2pattern</B>

page. During matching, the newline choice affects the behaviour of the dot,
circumflex, and dollar metacharacters. It may also alter the way the match
starting position is advanced after a match failure for an unanchored pattern.
<P>

When PCRE2_NEWLINE_CRLF, PCRE2_NEWLINE_ANYCRLF, or PCRE2_NEWLINE_ANY is set as
the newline convention, and a match attempt for an unanchored pattern fails
when the current starting position is at a CRLF sequence, and the pattern
contains no explicit matches for CR or LF characters, the match position is
advanced by two characters instead of one, in other words, to after the CRLF.
<P>

The above rule is a compromise that makes the most common cases work as
expected. For example, if the pattern is .+A (and the PCRE2_DOTALL option is
not set), it does not match the string &quot;\r\nA&quot; because, after failing at the
start, it skips both the CR and the LF before retrying. However, the pattern
[\r\n]A does match that string, because it contains an explicit CR or LF
reference, and so advances only by one character after the first failure.
<P>

An explicit match for CR of LF is either a literal appearance of one of those
characters in the pattern, or one of the \r or \n or equivalent octal or
hexadecimal escape sequences. Implicit matches such as [^X] do not count, nor
does \s, even though it includes CR and LF in the characters that it matches.
<P>

Notwithstanding the above, anomalous effects may still occur when CRLF is a
valid newline sequence and explicit \r or \n escapes appear in the pattern.

<A NAME="lbBO">&nbsp;</A>
<H2>HOW PCRE2_MATCH() RETURNS A STRING AND CAPTURED SUBSTRINGS</H2>


<P>
<PRE>
<B>uint32_t pcre2_get_ovector_count(pcre2_match_data *</B><I>match_data</I>);

<B>PCRE2_SIZE *pcre2_get_ovector_pointer(pcre2_match_data *</B><I>match_data</I>);
</PRE>

<P>

In general, a pattern matches a certain portion of the subject, and in
addition, further substrings from the subject may be picked out by
parenthesized parts of the pattern. Following the usage in Jeffrey Friedl's
book, this is called &quot;capturing&quot; in what follows, and the phrase &quot;capture
group&quot; (Perl terminology) is used for a fragment of a pattern that picks out a
substring. PCRE2 supports several other kinds of parenthesized group that do
not cause substrings to be captured. The <B>pcre2_pattern_info()</B> function
can be used to find out how many capture groups there are in a compiled
pattern.
<P>

You can use auxiliary functions for accessing captured substrings


by number

or


by name,

as described in sections below.
<P>

Alternatively, you can make direct use of the vector of PCRE2_SIZE values,
called the <B>ovector</B>, which contains the offsets of captured strings. It is
part of the


match data block.

The function <B>pcre2_get_ovector_pointer()</B> returns the address of the
ovector, and <B>pcre2_get_ovector_count()</B> returns the number of pairs of
values it contains.
<P>

Within the ovector, the first in each pair of values is set to the offset of
the first code unit of a substring, and the second is set to the offset of the
first code unit after the end of a substring. These values are always code unit
offsets, not character offsets. That is, they are byte offsets in the 8-bit
library, 16-bit offsets in the 16-bit library, and 32-bit offsets in the 32-bit
library.
<P>

After a partial match (error return PCRE2_ERROR_PARTIAL), only the first pair
of offsets (that is, <I>ovector[0]</I> and <I>ovector[1]</I>) are set. They
identify the part of the subject that was partially matched. See the

<B>pcre2partial</B>

documentation for details of partial matching.
<P>

After a fully successful match, the first pair of offsets identifies the
portion of the subject string that was matched by the entire pattern. The next
pair is used for the first captured substring, and so on. The value returned by
<B>pcre2_match()</B> is one more than the highest numbered pair that has been
set. For example, if two substrings have been captured, the returned value is
3. If there are no captured substrings, the return value from a successful
match is 1, indicating that just the first pair of offsets has been set.
<P>

If a pattern uses the \K escape sequence within a positive assertion, the
reported start of a successful match can be greater than the end of the match.
For example, if the pattern (?=ab\K) is matched against &quot;ab&quot;, the start and
end offset values for the match are 2 and 0.
<P>

If a capture group is matched repeatedly within a single match operation, it is
the last portion of the subject that it matched that is returned.
<P>

If the ovector is too small to hold all the captured substring offsets, as much
as possible is filled in, and the function returns a value of zero. If captured
substrings are not of interest, <B>pcre2_match()</B> may be called with a match
data block whose ovector is of minimum length (that is, one pair).
<P>

It is possible for capture group number <I>n+1</I> to match some part of the
subject when group <I>n</I> has not been used at all. For example, if the string
&quot;abc&quot; is matched against the pattern (a|(z))(bc) the return from the function
is 4, and groups 1 and 3 are matched, but 2 is not. When this happens, both
values in the offset pairs corresponding to unused groups are set to
PCRE2_UNSET.
<P>

Offset values that correspond to unused groups at the end of the expression are
also set to PCRE2_UNSET. For example, if the string &quot;abc&quot; is matched against
the pattern (abc)(x(yz)?)? groups 2 and 3 are not matched. The return from the
function is 2, because the highest used capture group number is 1. The offsets
for for the second and third capture groupss (assuming the vector is large
enough, of course) are set to PCRE2_UNSET.
<P>

Elements in the ovector that do not correspond to capturing parentheses in the
pattern are never changed. That is, if a pattern contains <I>n</I> capturing
parentheses, no more than <I>ovector[0]</I> to <I>ovector[2n+1]</I> are set by
<B>pcre2_match()</B>. The other elements retain whatever values they previously
had. After a failed match attempt, the contents of the ovector are unchanged.

<A NAME="lbBP">&nbsp;</A>
<H2>OTHER INFORMATION ABOUT A MATCH</H2>


<P>
<PRE>
<B>PCRE2_SPTR pcre2_get_mark(pcre2_match_data *</B><I>match_data</I>);

<B>PCRE2_SIZE pcre2_get_startchar(pcre2_match_data *</B><I>match_data</I>);
</PRE>

<P>

As well as the offsets in the ovector, other information about a match is
retained in the match data block and can be retrieved by the above functions in
appropriate circumstances. If they are called at other times, the result is
undefined.
<P>

After a successful match, a partial match (PCRE2_ERROR_PARTIAL), or a failure
to match (PCRE2_ERROR_NOMATCH), a mark name may be available. The function
<B>pcre2_get_mark()</B> can be called to access this name, which can be
specified in the pattern by any of the backtracking control verbs, not just
(*MARK). The same function applies to all the verbs. It returns a pointer to
the zero-terminated name, which is within the compiled pattern. If no name is
available, NULL is returned. The length of the name (excluding the terminating
zero) is stored in the code unit that precedes the name. You should use this
length instead of relying on the terminating zero if the name might contain a
binary zero.
<P>

After a successful match, the name that is returned is the last mark name
encountered on the matching path through the pattern. Instances of backtracking
verbs without names do not count. Thus, for example, if the matching path
contains (*MARK:A)(*PRUNE), the name &quot;A&quot; is returned. After a &quot;no match&quot; or a
partial match, the last encountered name is returned. For example, consider
this pattern:
<P>
<BR>&nbsp;&nbsp;^(*MARK:A)((*MARK:B)a|b)c
<P>
When it matches &quot;bc&quot;, the returned name is A. The B mark is &quot;seen&quot; in the first
branch of the group, but it is not on the matching path. On the other hand,
when this pattern fails to match &quot;bx&quot;, the returned name is B.
<P>

<B>Warning:</B> By default, certain start-of-match optimizations are used to
give a fast &quot;no match&quot; result in some situations. For example, if the anchoring
is removed from the pattern above, there is an initial check for the presence
of &quot;c&quot; in the subject before running the matching engine. This check fails for
&quot;bx&quot;, causing a match failure without seeing any marks. You can disable the
start-of-match optimizations by setting the PCRE2_NO_START_OPTIMIZE option for
<B>pcre2_compile()</B> or by starting the pattern with (*NO_START_OPT).
<P>

After a successful match, a partial match, or one of the invalid UTF errors
(for example, PCRE2_ERROR_UTF8_ERR5), <B>pcre2_get_startchar()</B> can be
called. After a successful or partial match it returns the code unit offset of
the character at which the match started. For a non-partial match, this can be
different to the value of <I>ovector[0]</I> if the pattern contains the \K
escape sequence. After a partial match, however, this value is always the same
as <I>ovector[0]</I> because \K does not affect the result of a partial match.
<P>

After a UTF check failure, <B>pcre2_get_startchar()</B> can be used to obtain
the code unit offset of the invalid UTF character. Details are given in the

<B>pcre2unicode</B>

page.

<A NAME="lbBQ">&nbsp;</A>
<H2>ERROR RETURNS FROM <B>pcre2_match()</B></H2>


<P>
If <B>pcre2_match()</B> fails, it returns a negative number. This can be
converted to a text string by calling the <B>pcre2_get_error_message()</B>
function (see &quot;Obtaining a textual error message&quot;


below).

Negative error codes are also returned by other functions, and are documented
with them. The codes are given names in the header file. If UTF checking is in
force and an invalid UTF subject string is detected, one of a number of
UTF-specific negative error codes is returned. Details are given in the

<B>pcre2unicode</B>

page. The following are the other errors that may be returned by
<B>pcre2_match()</B>:
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NOMATCH
<P>
The subject string did not match the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_PARTIAL
<P>
The subject string did not match, but it did match partially. See the

<B>pcre2partial</B>

documentation for details of partial matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADMAGIC
<P>
PCRE2 stores a 4-byte &quot;magic number&quot; at the start of the compiled code, to
catch the case when it is passed a junk pointer. This is the error that is
returned when the magic number is not present.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADMODE
<P>
This error is given when a compiled pattern is passed to a function in a
library of a different code unit width, for example, a pattern compiled by
the 8-bit library is passed to a 16-bit or 32-bit library function.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADOFFSET
<P>
The value of <I>startoffset</I> was greater than the length of the subject.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADOPTION
<P>
An unrecognized bit was set in the <I>options</I> argument.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_BADUTFOFFSET
<P>
The UTF code unit sequence that was passed as a subject was checked and found
to be valid (the PCRE2_NO_UTF_CHECK option was not set), but the value of
<I>startoffset</I> did not point to the beginning of a UTF character or the end
of the subject.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_CALLOUT
<P>
This error is never generated by <B>pcre2_match()</B> itself. It is provided for
use by callout functions that want to cause <B>pcre2_match()</B> or
<B>pcre2_callout_enumerate()</B> to return a distinctive error code. See the

<B>pcre2callout</B>

documentation for details.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DEPTHLIMIT
<P>
The nested backtracking depth limit was reached.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_HEAPLIMIT
<P>
The heap limit was reached.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_INTERNAL
<P>
An unexpected internal error has occurred. This error could be caused by a bug
in PCRE2 or by overwriting of the compiled pattern.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_JIT_STACKLIMIT
<P>
This error is returned when a pattern that was successfully studied using JIT
is being matched, but the memory available for the just-in-time processing
stack is not large enough. See the

<B>pcre2jit</B>

documentation for more details.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_MATCHLIMIT
<P>
The backtracking match limit was reached.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NOMEMORY
<P>
If a pattern contains many nested backtracking points, heap memory is used to
remember them. This error is given when the memory allocation function (default
or custom) fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is given
if the amount of memory needed exceeds the heap limit. PCRE2_ERROR_NOMEMORY is
also returned if PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation fails.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NULL
<P>
Either the <I>code</I>, <I>subject</I>, or <I>match_data</I> argument was passed
as NULL.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_RECURSELOOP
<P>
This error is returned when <B>pcre2_match()</B> detects a recursion loop within
the pattern. Specifically, it means that either the whole pattern or a
capture group has been called recursively for the second time at the same
position in the subject string. Some simple patterns that might do this are
detected and faulted at compile time, but more complicated cases, in particular
mutual recursions between two different groups, cannot be detected until
matching is attempted.

<A NAME="lbBR">&nbsp;</A>
<H2>OBTAINING A TEXTUAL ERROR MESSAGE</H2>


<P>
<PRE>
<B>int pcre2_get_error_message(int </B><I>errorcode</I>, PCRE2_UCHAR *<I>buffer</I>,
<B>  PCRE2_SIZE </B><I>bufflen</I>);
</PRE>

<P>

A text message for an error code from any PCRE2 function (compile, match, or
auxiliary) can be obtained by calling <B>pcre2_get_error_message()</B>. The code
is passed as the first argument, with the remaining two arguments specifying a
code unit buffer and its length in code units, into which the text message is
placed. The message is returned in code units of the appropriate width for the
library that is being used.
<P>

The returned message is terminated with a trailing zero, and the function
returns the number of code units used, excluding the trailing zero. If the
error number is unknown, the negative error code PCRE2_ERROR_BADDATA is
returned. If the buffer is too small, the message is truncated (but still with
a trailing zero), and the negative error code PCRE2_ERROR_NOMEMORY is returned.
None of the messages are very long; a buffer size of 120 code units is ample.

<A NAME="lbBS">&nbsp;</A>
<H2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</H2>


<P>
<PRE>
<B>int pcre2_substring_length_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_SIZE *<I>length</I>);

<B>int pcre2_substring_copy_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_UCHAR *<I>buffer</I>,
<B>  PCRE2_SIZE *</B><I>bufflen</I>);

<B>int pcre2_substring_get_bynumber(pcre2_match_data *</B><I>match_data</I>,
<B>  uint32_t </B><I>number</I>, PCRE2_UCHAR **<I>bufferptr</I>,
<B>  PCRE2_SIZE *</B><I>bufflen</I>);

<B>void pcre2_substring_free(PCRE2_UCHAR *</B><I>buffer</I>);
</PRE>

<P>

Captured substrings can be accessed directly by using the ovector as described


above.

For convenience, auxiliary functions are provided for extracting captured
substrings as new, separate, zero-terminated strings. A substring that contains
a binary zero is correctly extracted and has a further zero added on the end,
but the result is not, of course, a C string.
<P>

The functions in this section identify substrings by number. The number zero
refers to the entire matched substring, with higher numbers referring to
substrings captured by parenthesized groups. After a partial match, only
substring zero is available. An attempt to extract any other substring gives
the error PCRE2_ERROR_PARTIAL. The next section describes similar functions for
extracting captured substrings by name.
<P>

If a pattern uses the \K escape sequence within a positive assertion, the
reported start of a successful match can be greater than the end of the match.
For example, if the pattern (?=ab\K) is matched against &quot;ab&quot;, the start and
end offset values for the match are 2 and 0. In this situation, calling these
functions with a zero substring number extracts a zero-length empty string.
<P>

You can find the length in code units of a captured substring without
extracting it by calling <B>pcre2_substring_length_bynumber()</B>. The first
argument is a pointer to the match data block, the second is the group number,
and the third is a pointer to a variable into which the length is placed. If
you just want to know whether or not the substring has been captured, you can
pass the third argument as NULL.
<P>

The <B>pcre2_substring_copy_bynumber()</B> function copies a captured substring
into a supplied buffer, whereas <B>pcre2_substring_get_bynumber()</B> copies it
into new memory, obtained using the same memory allocation function that was
used for the match data block. The first two arguments of these functions are a
pointer to the match data block and a capture group number.
<P>

The final arguments of <B>pcre2_substring_copy_bynumber()</B> are a pointer to
the buffer and a pointer to a variable that contains its length in code units.
This is updated to contain the actual number of code units used for the
extracted substring, excluding the terminating zero.
<P>

For <B>pcre2_substring_get_bynumber()</B> the third and fourth arguments point
to variables that are updated with a pointer to the new memory and the number
of code units that comprise the substring, again excluding the terminating
zero. When the substring is no longer needed, the memory should be freed by
calling <B>pcre2_substring_free()</B>.
<P>

The return value from all these functions is zero for success, or a negative
error code. If the pattern match failed, the match failure code is returned.
If a substring number greater than zero is used after a partial match,
PCRE2_ERROR_PARTIAL is returned. Other possible error codes are:
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NOMEMORY
<P>
The buffer was too small for <B>pcre2_substring_copy_bynumber()</B>, or the
attempt to get memory failed for <B>pcre2_substring_get_bynumber()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_NOSUBSTRING
<P>
There is no substring with that number in the pattern, that is, the number is
greater than the number of capturing parentheses.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_UNAVAILABLE
<P>
The substring number, though not greater than the number of captures in the
pattern, is greater than the number of slots in the ovector, so the substring
could not be captured.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_UNSET
<P>
The substring did not participate in the match. For example, if the pattern is
(abc)|(def) and the subject is &quot;def&quot;, and the ovector contains at least two
capturing slots, substring number 1 is unset.
<A NAME="lbBT">&nbsp;</A>
<H2>EXTRACTING A LIST OF ALL CAPTURED SUBSTRINGS</H2>


<P>
<PRE>
<B>int pcre2_substring_list_get(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_UCHAR ***</B><I>listptr</I>, PCRE2_SIZE **<I>lengthsptr</I>);

<B>void pcre2_substring_list_free(PCRE2_SPTR *</B><I>list</I>);
</PRE>

<P>

The <B>pcre2_substring_list_get()</B> function extracts all available substrings
and builds a list of pointers to them. It also (optionally) builds a second
list that contains their lengths (in code units), excluding a terminating zero
that is added to each of them. All this is done in a single block of memory
that is obtained using the same memory allocation function that was used to get
the match data block.
<P>

This function must be called only after a successful match. If called after a
partial match, the error code PCRE2_ERROR_PARTIAL is returned.
<P>

The address of the memory block is returned via <I>listptr</I>, which is also
the start of the list of string pointers. The end of the list is marked by a
NULL pointer. The address of the list of lengths is returned via
<I>lengthsptr</I>. If your strings do not contain binary zeros and you do not
therefore need the lengths, you may supply NULL as the <B>lengthsptr</B>
argument to disable the creation of a list of lengths. The yield of the
function is zero if all went well, or PCRE2_ERROR_NOMEMORY if the memory block
could not be obtained. When the list is no longer needed, it should be freed by
calling <B>pcre2_substring_list_free()</B>.
<P>

If this function encounters a substring that is unset, which can happen when
capture group number <I>n+1</I> matches some part of the subject, but group
<I>n</I> has not been used at all, it returns an empty string. This can be
distinguished from a genuine zero-length substring by inspecting the
appropriate offset in the ovector, which contain PCRE2_UNSET for unset
substrings, or by calling <B>pcre2_substring_length_bynumber()</B>.

<A NAME="lbBU">&nbsp;</A>
<H2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</H2>


<P>
<PRE>
<B>int pcre2_substring_number_from_name(const pcre2_code *</B><I>code</I>,
<B>  PCRE2_SPTR </B><I>name</I>);

<B>int pcre2_substring_length_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_SIZE *<I>length</I>);

<B>int pcre2_substring_copy_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_UCHAR *<I>buffer</I>, PCRE2_SIZE *<I>bufflen</I>);

<B>int pcre2_substring_get_byname(pcre2_match_data *</B><I>match_data</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_UCHAR **<I>bufferptr</I>, PCRE2_SIZE *<I>bufflen</I>);

<B>void pcre2_substring_free(PCRE2_UCHAR *</B><I>buffer</I>);
</PRE>

<P>

To extract a substring by name, you first have to find associated number.
For example, for this pattern:
<P>
<BR>&nbsp;&nbsp;(a+)b(?&lt;xxx&gt;\d+)...
<P>
the number of the capture group called &quot;xxx&quot; is 2. If the name is known to be
unique (PCRE2_DUPNAMES was not set), you can find the number from the name by
calling <B>pcre2_substring_number_from_name()</B>. The first argument is the
compiled pattern, and the second is the name. The yield of the function is the
group number, PCRE2_ERROR_NOSUBSTRING if there is no group with that name, or
PCRE2_ERROR_NOUNIQUESUBSTRING if there is more than one group with that name.
Given the number, you can extract the substring directly from the ovector, or
use one of the &quot;bynumber&quot; functions described above.
<P>

For convenience, there are also &quot;byname&quot; functions that correspond to the
&quot;bynumber&quot; functions, the only difference being that the second argument is a
name instead of a number. If PCRE2_DUPNAMES is set and there are duplicate
names, these functions scan all the groups with the given name, and return the
captured substring from the first named group that is set.
<P>

If there are no groups with the given name, PCRE2_ERROR_NOSUBSTRING is
returned. If all groups with the name have numbers that are greater than the
number of slots in the ovector, PCRE2_ERROR_UNAVAILABLE is returned. If there
is at least one group with a slot in the ovector, but no group is found to be
set, PCRE2_ERROR_UNSET is returned.
<P>

<B>Warning:</B> If the pattern uses the (?| feature to set up multiple
capture groups with the same number, as described in the


section on duplicate group numbers

in the

<B>pcre2pattern</B>

page, you cannot use names to distinguish the different capture groups, because
names are not included in the compiled code. The matching process uses only
numbers. For this reason, the use of different names for groups with the
same number causes an error at compile time.

<A NAME="lbBV">&nbsp;</A>
<H2>CREATING A NEW STRING WITH SUBSTITUTIONS</H2>


<P>
<PRE>
<B>int pcre2_substitute(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>, PCRE2_SPTR <I>replacement</I>,
<B>  PCRE2_SIZE </B><I>rlength</I>, PCRE2_UCHAR *<I>outputbuffer</I>,
<B>  PCRE2_SIZE *</B><I>outlengthptr</I>);
</PRE>

<P>

This function calls <B>pcre2_match()</B> and then makes a copy of the subject
string in <I>outputbuffer</I>, replacing one or more parts that were matched
with the <I>replacement</I> string, whose length is supplied in <B>rlength</B>.
This can be given as PCRE2_ZERO_TERMINATED for a zero-terminated string.
The default is to perform just one replacement, but there is an option that
requests multiple replacements (see PCRE2_SUBSTITUTE_GLOBAL below for details).
<P>

Matches in which a \K item in a lookahead in the pattern causes the match to
end before it starts are not supported, and give rise to an error return. For
global replacements, matches in which \K in a lookbehind causes the match to
start earlier than the point that was reached in the previous iteration are
also not supported.
<P>

The first seven arguments of <B>pcre2_substitute()</B> are the same as for
<B>pcre2_match()</B>, except that the partial matching options are not
permitted, and <I>match_data</I> may be passed as NULL, in which case a match
data block is obtained and freed within this function, using memory management
functions from the match context, if provided, or else those that were used to
allocate memory for the compiled code.
<P>

If an external <I>match_data</I> block is provided, its contents afterwards
are those set by the final call to <B>pcre2_match()</B>. For global changes,
this will have ended in a matching error. The contents of the ovector within
the match data block may or may not have been changed.
<P>

The <I>outlengthptr</I> argument must point to a variable that contains the
length, in code units, of the output buffer. If the function is successful, the
value is updated to contain the length of the new string, excluding the
trailing zero that is automatically added.
<P>

If the function is not successful, the value set via <I>outlengthptr</I> depends
on the type of error. For syntax errors in the replacement string, the value is
the offset in the replacement string where the error was detected. For other
errors, the value is PCRE2_UNSET by default. This includes the case of the
output buffer being too small, unless PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set
(see below), in which case the value is the minimum length needed, including
space for the trailing zero. Note that in order to compute the required length,
<B>pcre2_substitute()</B> has to simulate all the matching and copying, instead
of giving an error return as soon as the buffer overflows. Note also that the
length is in code units, not bytes.
<P>

In the replacement string, which is interpreted as a UTF string in UTF mode,
and is checked for UTF validity unless the PCRE2_NO_UTF_CHECK option is set, a
dollar character is an escape character that can specify the insertion of
characters from capture groups or names from (*MARK) or other control verbs
in the pattern. The following forms are always recognized:
<P>
<BR>&nbsp;&nbsp;$$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert&nbsp;a&nbsp;dollar&nbsp;character
<BR>&nbsp;&nbsp;$&lt;n&gt;&nbsp;or&nbsp;${&lt;n&gt;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert&nbsp;the&nbsp;contents&nbsp;of&nbsp;group&nbsp;&lt;n&gt;
<BR>&nbsp;&nbsp;$*MARK&nbsp;or&nbsp;${*MARK}&nbsp;&nbsp;insert&nbsp;a&nbsp;control&nbsp;verb&nbsp;name
<P>
Either a group number or a group name can be given for &lt;n&gt;. Curly brackets are
required only if the following character would be interpreted as part of the
number or name. The number may be zero to include the entire matched string.
For example, if the pattern a(b)c is matched with &quot;=abc=&quot; and the replacement
string &quot;+$1$0$1+&quot;, the result is &quot;=+babcb+=&quot;.
<P>

$*MARK inserts the name from the last encountered backtracking control verb on
the matching path that has a name. (*MARK) must always include a name, but the
other verbs need not. For example, in the case of (*MARK:A)(*PRUNE) the name
inserted is &quot;A&quot;, but for (*MARK:A)(*PRUNE:B) the relevant name is &quot;B&quot;. This
facility can be used to perform simple simultaneous substitutions, as this
<B>pcre2test</B> example shows:
<P>
<BR>&nbsp;&nbsp;/(*MARK:pear)apple|(*MARK:orange)lemon/g,replace=${*MARK}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apple&nbsp;lemon
<BR>&nbsp;&nbsp;&nbsp;2:&nbsp;pear&nbsp;orange
<P>
As well as the usual options for <B>pcre2_match()</B>, a number of additional
options can be set in the <I>options</I> argument of <B>pcre2_substitute()</B>.
<P>

PCRE2_SUBSTITUTE_GLOBAL causes the function to iterate over the subject string,
replacing every matching substring. If this option is not set, only the first
matching substring is replaced. The search for matches takes place in the
original subject string (that is, previous replacements do not affect it).
Iteration is implemented by advancing the <I>startoffset</I> value for each
search, which is always passed the entire subject string. If an offset limit is
set in the match context, searching stops when that limit is reached.
<P>

You can restrict the effect of a global substitution to a portion of the
subject string by setting either or both of <I>startoffset</I> and an offset
limit. Here is a pcre2test example:
<P>
<BR>&nbsp;&nbsp;/B/g,replace=!,use_offset_limit
<BR>&nbsp;&nbsp;ABC&nbsp;ABC&nbsp;ABC&nbsp;ABC\=offset=3,offset_limit=12
<BR>&nbsp;&nbsp;&nbsp;2:&nbsp;ABC&nbsp;A!C&nbsp;A!C&nbsp;ABC
<P>
When continuing with global substitutions after matching a substring with zero
length, an attempt to find a non-empty match at the same offset is performed.
If this is not successful, the offset is advanced by one character except when
CRLF is a valid newline sequence and the next two characters are CR, LF. In
this case, the offset is advanced by two characters.
<P>

PCRE2_SUBSTITUTE_OVERFLOW_LENGTH changes what happens when the output buffer is
too small. The default action is to return PCRE2_ERROR_NOMEMORY immediately. If
this option is set, however, <B>pcre2_substitute()</B> continues to go through
the motions of matching and substituting (without, of course, writing anything)
in order to compute the size of buffer that is needed. This value is passed
back via the <I>outlengthptr</I> variable, with the result of the function still
being PCRE2_ERROR_NOMEMORY.
<P>

Passing a buffer size of zero is a permitted way of finding out how much memory
is needed for given substitution. However, this does mean that the entire
operation is carried out twice. Depending on the application, it may be more
efficient to allocate a large buffer and free the excess afterwards, instead of
using PCRE2_SUBSTITUTE_OVERFLOW_LENGTH.
<P>

PCRE2_SUBSTITUTE_UNKNOWN_UNSET causes references to capture groups that do
not appear in the pattern to be treated as unset groups. This option should be
used with care, because it means that a typo in a group name or number no
longer causes the PCRE2_ERROR_NOSUBSTRING error.
<P>

PCRE2_SUBSTITUTE_UNSET_EMPTY causes unset capture groups (including unknown
groups when PCRE2_SUBSTITUTE_UNKNOWN_UNSET is set) to be treated as empty
strings when inserted as described above. If this option is not set, an attempt
to insert an unset group causes the PCRE2_ERROR_UNSET error. This option does
not influence the extended substitution syntax described below.
<P>

PCRE2_SUBSTITUTE_EXTENDED causes extra processing to be applied to the
replacement string. Without this option, only the dollar character is special,
and only the group insertion forms listed above are valid. When
PCRE2_SUBSTITUTE_EXTENDED is set, two things change:
<P>

Firstly, backslash in a replacement string is interpreted as an escape
character. The usual forms such as \n or \x{ddd} can be used to specify
particular character codes, and backslash followed by any non-alphanumeric
character quotes that character. Extended quoting can be coded using \Q...\E,
exactly as in pattern strings.
<P>

There are also four escape sequences for forcing the case of inserted letters.
The insertion mechanism has three states: no case forcing, force upper case,
and force lower case. The escape sequences change the current state: \U and
\L change to upper or lower case forcing, respectively, and \E (when not
terminating a \Q quoted sequence) reverts to no case forcing. The sequences
\u and \l force the next character (if it is a letter) to upper or lower
case, respectively, and then the state automatically reverts to no case
forcing. Case forcing applies to all inserted  characters, including those from
capture groups and letters within \Q...\E quoted sequences.
<P>

Note that case forcing sequences such as \U...\E do not nest. For example,
the result of processing &quot;\Uaa\LBB\Ecc\E&quot; is &quot;AAbbcc&quot;; the final \E has no
effect. Note also that the PCRE2_ALT_BSUX and PCRE2_EXTRA_ALT_BSUX options do
not apply to replacement strings.
<P>

The second effect of setting PCRE2_SUBSTITUTE_EXTENDED is to add more
flexibility to capture group substitution. The syntax is similar to that used
by Bash:
<P>
<BR>&nbsp;&nbsp;${&lt;n&gt;:-&lt;string&gt;}
<BR>&nbsp;&nbsp;${&lt;n&gt;:+&lt;string1&gt;:&lt;string2&gt;}
<P>
As before, &lt;n&gt; may be a group number or a name. The first form specifies a
default value. If group &lt;n&gt; is set, its value is inserted; if not, &lt;string&gt; is
expanded and the result inserted. The second form specifies strings that are
expanded and inserted when group &lt;n&gt; is set or unset, respectively. The first
form is just a convenient shorthand for
<P>
<BR>&nbsp;&nbsp;${&lt;n&gt;:+${&lt;n&gt;}:&lt;string&gt;}
<P>
Backslash can be used to escape colons and closing curly brackets in the
replacement strings. A change of the case forcing state within a replacement
string remains in force afterwards, as shown in this <B>pcre2test</B> example:
<P>
<BR>&nbsp;&nbsp;/(some)?(body)/substitute_extended,replace=${1:+\U:\L}HeLLo
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body
<BR>&nbsp;&nbsp;&nbsp;1:&nbsp;hello
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;somebody
<BR>&nbsp;&nbsp;&nbsp;1:&nbsp;HELLO
<P>
The PCRE2_SUBSTITUTE_UNSET_EMPTY option does not affect these extended
substitutions. However, PCRE2_SUBSTITUTE_UNKNOWN_UNSET does cause unknown
groups in the extended syntax forms to be treated as unset.
<P>

If successful, <B>pcre2_substitute()</B> returns the number of successful
matches. This may be zero if no matches were found, and is never greater than 1
unless PCRE2_SUBSTITUTE_GLOBAL is set.
<P>

In the event of an error, a negative error code is returned. Except for
PCRE2_ERROR_NOMATCH (which is never returned), errors from <B>pcre2_match()</B>
are passed straight back.
<P>

PCRE2_ERROR_NOSUBSTRING is returned for a non-existent substring insertion,
unless PCRE2_SUBSTITUTE_UNKNOWN_UNSET is set.
<P>

PCRE2_ERROR_UNSET is returned for an unset substring insertion (including an
unknown substring when PCRE2_SUBSTITUTE_UNKNOWN_UNSET is set) when the simple
(non-extended) syntax is used and PCRE2_SUBSTITUTE_UNSET_EMPTY is not set.
<P>

PCRE2_ERROR_NOMEMORY is returned if the output buffer is not big enough. If the
PCRE2_SUBSTITUTE_OVERFLOW_LENGTH option is set, the size of buffer that is
needed is returned via <I>outlengthptr</I>. Note that this does not happen by
default.
<P>

PCRE2_ERROR_BADREPLACEMENT is used for miscellaneous syntax errors in the
replacement string, with more particular errors being PCRE2_ERROR_BADREPESCAPE
(invalid escape sequence), PCRE2_ERROR_REPMISSINGBRACE (closing curly bracket
not found), PCRE2_ERROR_BADSUBSTITUTION (syntax error in extended group
substitution), and PCRE2_ERROR_BADSUBSPATTERN (the pattern match ended before
it started or the match started earlier than the current position in the
subject, which can happen if \K is used in an assertion).
<P>

As for all PCRE2 errors, a text message that describes the error can be
obtained by calling the <B>pcre2_get_error_message()</B> function (see
&quot;Obtaining a textual error message&quot;


above).

<A NAME="lbBW">&nbsp;</A>
<H3>Substitution callouts</H3>


<P>
<PRE>
<B>int pcre2_set_substitute_callout(pcre2_match_context *</B><I>mcontext</I>,
<B>  int (*</B><I>callout_function</I>)(pcre2_substitute_callout_block *, void *),
<B>  void *</B><I>callout_data</I>);
</PRE>

<P>
The <B>pcre2_set_substitution_callout()</B> function can be used to specify a
callout function for <B>pcre2_substitute()</B>. This information is passed in
a match context. The callout function is called after each substitution has
been processed, but it can cause the replacement not to happen. The callout
function is not called for simulated substitutions that happen as a result of
the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH option.
<P>

The first argument of the callout function is a pointer to a substitute callout
block structure, which contains the following fields, not necessarily in this
order:
<P>
<BR>&nbsp;&nbsp;uint32_t&nbsp;&nbsp;&nbsp;&nbsp;<I>version</I>;
<BR>&nbsp;&nbsp;uint32_t&nbsp;&nbsp;&nbsp;&nbsp;<I>subscount</I>;
<BR>&nbsp;&nbsp;PCRE2_SPTR&nbsp;&nbsp;<I>input</I>;
<BR>&nbsp;&nbsp;PCRE2_SPTR&nbsp;&nbsp;<I>output</I>;
<BR>&nbsp;&nbsp;PCRE2_SIZE&nbsp;<I>*ovector</I>;
<BR>&nbsp;&nbsp;uint32_t&nbsp;&nbsp;&nbsp;&nbsp;<I>oveccount</I>;
<BR>&nbsp;&nbsp;PCRE2_SIZE&nbsp;&nbsp;<I>output_offsets[2]</I>;
<P>
The <I>version</I> field contains the version number of the block format. The
current version is 0. The version number will increase in future if more fields
are added, but the intention is never to remove any of the existing fields.
<P>

The <I>subscount</I> field is the number of the current match. It is 1 for the
first callout, 2 for the second, and so on. The <I>input</I> and <I>output</I>
pointers are copies of the values passed to <B>pcre2_substitute()</B>.
<P>

The <I>ovector</I> field points to the ovector, which contains the result of the
most recent match. The <I>oveccount</I> field contains the number of pairs that
are set in the ovector, and is always greater than zero.
<P>

The <I>output_offsets</I> vector contains the offsets of the replacement in the
output string. This has already been processed for dollar and (if requested)
backslash substitutions as described above.
<P>

The second argument of the callout function is the value passed as
<I>callout_data</I> when the function was registered. The value returned by the
callout function is interpreted as follows:
<P>

If the value is zero, the replacement is accepted, and, if
PCRE2_SUBSTITUTE_GLOBAL is set, processing continues with a search for the next
match. If the value is not zero, the current replacement is not accepted. If
the value is greater than zero, processing continues when
PCRE2_SUBSTITUTE_GLOBAL is set. Otherwise (the value is less than zero or
PCRE2_SUBSTITUTE_GLOBAL is not set), the the rest of the input is copied to the
output and the call to <B>pcre2_substitute()</B> exits, returning the number of
matches so far.
<A NAME="lbBX">&nbsp;</A>
<H2>DUPLICATE CAPTURE GROUP NAMES</H2>


<P>
<PRE>
<B>int pcre2_substring_nametable_scan(const pcre2_code *</B><I>code</I>,
<B>  PCRE2_SPTR </B><I>name</I>, PCRE2_SPTR *<I>first</I>, PCRE2_SPTR *<I>last</I>);
</PRE>

<P>

When a pattern is compiled with the PCRE2_DUPNAMES option, names for capture
groups are not required to be unique. Duplicate names are always allowed for
groups with the same number, created by using the (?| feature. Indeed, if such
groups are named, they are required to use the same names.
<P>

Normally, patterns that use duplicate names are such that in any one match,
only one of each set of identically-named groups participates. An example is
shown in the

<B>pcre2pattern</B>

documentation.
<P>

When duplicates are present, <B>pcre2_substring_copy_byname()</B> and
<B>pcre2_substring_get_byname()</B> return the first substring corresponding to
the given name that is set. Only if none are set is PCRE2_ERROR_UNSET is
returned. The <B>pcre2_substring_number_from_name()</B> function returns the
error PCRE2_ERROR_NOUNIQUESUBSTRING when there are duplicate names.
<P>

If you want to get full details of all captured substrings for a given name,
you must use the <B>pcre2_substring_nametable_scan()</B> function. The first
argument is the compiled pattern, and the second is the name. If the third and
fourth arguments are NULL, the function returns a group number for a unique
name, or PCRE2_ERROR_NOUNIQUESUBSTRING otherwise.
<P>

When the third and fourth arguments are not NULL, they must be pointers to
variables that are updated by the function. After it has run, they point to the
first and last entries in the name-to-number table for the given name, and the
function returns the length of each entry in code units. In both cases,
PCRE2_ERROR_NOSUBSTRING is returned if there are no entries for the given name.
<P>

The format of the name table is described


above

in the section entitled <I>Information about a pattern</I>. Given all the
relevant entries for the name, you can extract each of their numbers, and hence
the captured data.
<A NAME="lbBY">&nbsp;</A>
<H2>FINDING ALL POSSIBLE MATCHES AT ONE POSITION</H2>


<P>
The traditional matching function uses a similar algorithm to Perl, which stops
when it finds the first match at a given point in the subject. If you want to
find all possible matches, or the longest possible match at a given position,
consider using the alternative matching function (see below) instead. If you
cannot use the alternative function, you can kludge it up by making use of the
callout facility, which is described in the

<B>pcre2callout</B>

documentation.
<P>

What you have to do is to insert a callout right at the end of the pattern.
When your callout function is called, extract and save the current matched
substring. Then return 1, which forces <B>pcre2_match()</B> to backtrack and try
other alternatives. Ultimately, when it runs out of matches,
<B>pcre2_match()</B> will yield PCRE2_ERROR_NOMATCH.

<A NAME="lbBZ">&nbsp;</A>
<H2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</H2>


<P>
<PRE>
<B>int pcre2_dfa_match(const pcre2_code *</B><I>code</I>, PCRE2_SPTR <I>subject</I>,
<B>  PCRE2_SIZE </B><I>length</I>, PCRE2_SIZE <I>startoffset</I>,
<B>  uint32_t </B><I>options</I>, pcre2_match_data *<I>match_data</I>,
<B>  pcre2_match_context *</B><I>mcontext</I>,
<B>  int *</B><I>workspace</I>, PCRE2_SIZE <I>wscount</I>);
</PRE>

<P>

The function <B>pcre2_dfa_match()</B> is called to match a subject string
against a compiled pattern, using a matching algorithm that scans the subject
string just once (not counting lookaround assertions), and does not backtrack.
This has different characteristics to the normal algorithm, and is not
compatible with Perl. Some of the features of PCRE2 patterns are not supported.
Nevertheless, there are times when this kind of matching can be useful. For a
discussion of the two matching algorithms, and a list of features that
<B>pcre2_dfa_match()</B> does not support, see the

<B>pcre2matching</B>

documentation.
<P>

The arguments for the <B>pcre2_dfa_match()</B> function are the same as for
<B>pcre2_match()</B>, plus two extras. The ovector within the match data block
is used in a different way, and this is described below. The other common
arguments are used in the same way as for <B>pcre2_match()</B>, so their
description is not repeated here.
<P>

The two additional arguments provide workspace for the function. The workspace
vector should contain at least 20 elements. It is used for keeping track of
multiple paths through the pattern tree. More workspace is needed for patterns
and subjects where there are a lot of potential matches.
<P>

Here is an example of a simple call to <B>pcre2_dfa_match()</B>:
<P>
<BR>&nbsp;&nbsp;int&nbsp;wspace[20];
<BR>&nbsp;&nbsp;pcre2_match_data&nbsp;*md&nbsp;=&nbsp;pcre2_match_data_create(4,&nbsp;NULL);
<BR>&nbsp;&nbsp;int&nbsp;rc&nbsp;=&nbsp;pcre2_dfa_match(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre2_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;some&nbsp;string&quot;,&nbsp;&nbsp;/*&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;11,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start&nbsp;at&nbsp;offset&nbsp;0&nbsp;in&nbsp;the&nbsp;subject&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;md,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;match&nbsp;data&nbsp;block&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;a&nbsp;match&nbsp;context;&nbsp;NULL&nbsp;means&nbsp;use&nbsp;defaults&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;wspace,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;working&nbsp;space&nbsp;vector&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;elements&nbsp;(NOT&nbsp;size&nbsp;in&nbsp;bytes)&nbsp;*/
<A NAME="lbCA">&nbsp;</A>
<H3>Option bits for <B>pcre_dfa_match()</B></H3>


<P>
The unused bits of the <I>options</I> argument for <B>pcre2_dfa_match()</B> must
be zero. The only bits that may be set are PCRE2_ANCHORED,
PCRE2_COPY_MATCHED_SUBJECT, PCRE2_ENDANCHORED, PCRE2_NOTBOL, PCRE2_NOTEOL,
PCRE2_NOTEMPTY, PCRE2_NOTEMPTY_ATSTART, PCRE2_NO_UTF_CHECK, PCRE2_PARTIAL_HARD,
PCRE2_PARTIAL_SOFT, PCRE2_DFA_SHORTEST, and PCRE2_DFA_RESTART. All but the last
four of these are exactly the same as for <B>pcre2_match()</B>, so their
description is not repeated here.
<P>
<BR>&nbsp;&nbsp;PCRE2_PARTIAL_HARD
<BR>&nbsp;&nbsp;PCRE2_PARTIAL_SOFT
<P>
These have the same general effect as they do for <B>pcre2_match()</B>, but the
details are slightly different. When PCRE2_PARTIAL_HARD is set for
<B>pcre2_dfa_match()</B>, it returns PCRE2_ERROR_PARTIAL if the end of the
subject is reached and there is still at least one matching possibility that
requires additional characters. This happens even if some complete matches have
already been found. When PCRE2_PARTIAL_SOFT is set, the return code
PCRE2_ERROR_NOMATCH is converted into PCRE2_ERROR_PARTIAL if the end of the
subject is reached, there have been no complete matches, but there is still at
least one matching possibility. The portion of the string that was inspected
when the longest partial match was found is set as the first matching string in
both cases. There is a more detailed discussion of partial and multi-segment
matching, with examples, in the

<B>pcre2partial</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE2_DFA_SHORTEST
<P>
Setting the PCRE2_DFA_SHORTEST option causes the matching algorithm to stop as
soon as it has found one match. Because of the way the alternative algorithm
works, this is necessarily the shortest possible match at the first possible
matching point in the subject string.
<P>
<BR>&nbsp;&nbsp;PCRE2_DFA_RESTART
<P>
When <B>pcre2_dfa_match()</B> returns a partial match, it is possible to call it
again, with additional subject characters, and have it continue with the same
match. The PCRE2_DFA_RESTART option requests this action; when it is set, the
<I>workspace</I> and <I>wscount</I> options must reference the same vector as
before because data about the match so far is left in them after a partial
match. There is more discussion of this facility in the

<B>pcre2partial</B>

documentation.
<A NAME="lbCB">&nbsp;</A>
<H3>Successful returns from <B>pcre2_dfa_match()</B></H3>


<P>
When <B>pcre2_dfa_match()</B> succeeds, it may have matched more than one
substring in the subject. Note, however, that all the matches from one run of
the function start at the same point in the subject. The shorter matches are
all initial substrings of the longer matches. For example, if the pattern
<P>
<BR>&nbsp;&nbsp;&lt;.*&gt;
<P>
is matched against the string
<P>
<BR>&nbsp;&nbsp;This&nbsp;is&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;&nbsp;&lt;something&nbsp;further&gt;&nbsp;no&nbsp;more
<P>
the three matched strings are
<P>
<BR>&nbsp;&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;&nbsp;&lt;something&nbsp;further&gt;
<BR>&nbsp;&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;
<BR>&nbsp;&nbsp;&lt;something&gt;
<P>
On success, the yield of the function is a number greater than zero, which is
the number of matched substrings. The offsets of the substrings are returned in
the ovector, and can be extracted by number in the same way as for
<B>pcre2_match()</B>, but the numbers bear no relation to any capture groups
that may exist in the pattern, because DFA matching does not support capturing.
<P>

Calls to the convenience functions that extract substrings by name
return the error PCRE2_ERROR_DFA_UFUNC (unsupported function) if used after a
DFA match. The convenience functions that extract substrings by number never
return PCRE2_ERROR_NOSUBSTRING.
<P>

The matched strings are stored in the ovector in reverse order of length; that
is, the longest matching string is first. If there were too many matches to fit
into the ovector, the yield of the function is zero, and the vector is filled
with the longest matches.
<P>

NOTE: PCRE2's &quot;auto-possessification&quot; optimization usually applies to character
repeats at the end of a pattern (as well as internally). For example, the
pattern &quot;a\d+&quot; is compiled as if it were &quot;a\d++&quot;. For DFA matching, this
means that only one possible match is found. If you really do want multiple
matches in such cases, either use an ungreedy repeat such as &quot;a\d+?&quot; or set
the PCRE2_NO_AUTO_POSSESS option when compiling.
<A NAME="lbCC">&nbsp;</A>
<H3>Error returns from <B>pcre2_dfa_match()</B></H3>


<P>
The <B>pcre2_dfa_match()</B> function returns a negative number when it fails.
Many of the errors are the same as for <B>pcre2_match()</B>, as described


above.

There are in addition the following errors that are specific to
<B>pcre2_dfa_match()</B>:
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_UITEM
<P>
This return is given if <B>pcre2_dfa_match()</B> encounters an item in the
pattern that it does not support, for instance, the use of \C in a UTF mode or
a backreference.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_UCOND
<P>
This return is given if <B>pcre2_dfa_match()</B> encounters a condition item
that uses a backreference for the condition, or a test for recursion in a
specific capture group. These are not supported.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_UINVALID_UTF
<P>
This return is given if <B>pcre2_dfa_match()</B> is called for a pattern that
was compiled with PCRE2_MATCH_INVALID_UTF. This is not supported for DFA
matching.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_WSSIZE
<P>
This return is given if <B>pcre2_dfa_match()</B> runs out of space in the
<I>workspace</I> vector.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_RECURSE
<P>
When a recursion or subroutine call is processed, the matching function calls
itself recursively, using private memory for the ovector and <I>workspace</I>.
This error is given if the internal ovector is not large enough. This should be
extremely rare, as a vector of size 1000 is used.
<P>
<BR>&nbsp;&nbsp;PCRE2_ERROR_DFA_BADRESTART
<P>
When <B>pcre2_dfa_match()</B> is called with the <B>PCRE2_DFA_RESTART</B> option,
some plausibility checks are made on the contents of the workspace, which
should contain data about the previous partial match. If any of these checks
fail, this error is given.
<A NAME="lbCD">&nbsp;</A>
<H2>SEE ALSO</H2>


<P>
<B><A HREF="/cgi-bin/man/man2html?3+pcre2build">pcre2build</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre2callout">pcre2callout</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre2demo">pcre2demo</A>(3)</B>,
<B><A HREF="/cgi-bin/man/man2html?3+pcre2matching">pcre2matching</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre2partial">pcre2partial</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre2posix">pcre2posix</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?3+pcre2sample">pcre2sample</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre2unicode">pcre2unicode</A></B>(3).
<A NAME="lbCE">&nbsp;</A>
<H2>AUTHOR</H2>


<P>
<PRE>
Philip Hazel
University Computing Service
Cambridge, England.
</PRE>

<A NAME="lbCF">&nbsp;</A>
<H2>REVISION</H2>


<P>
<PRE>
Last updated: 02 September 2019
Copyright (c) 1997-2019 University of Cambridge.
</PRE>

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">PCRE2 NATIVE API BASIC FUNCTIONS</A><DD>
<DT id="3"><A HREF="#lbAD">PCRE2 NATIVE API AUXILIARY MATCH FUNCTIONS</A><DD>
<DT id="4"><A HREF="#lbAE">PCRE2 NATIVE API GENERAL CONTEXT FUNCTIONS</A><DD>
<DT id="5"><A HREF="#lbAF">PCRE2 NATIVE API COMPILE CONTEXT FUNCTIONS</A><DD>
<DT id="6"><A HREF="#lbAG">PCRE2 NATIVE API MATCH CONTEXT FUNCTIONS</A><DD>
<DT id="7"><A HREF="#lbAH">PCRE2 NATIVE API STRING EXTRACTION FUNCTIONS</A><DD>
<DT id="8"><A HREF="#lbAI">PCRE2 NATIVE API STRING SUBSTITUTION FUNCTION</A><DD>
<DT id="9"><A HREF="#lbAJ">PCRE2 NATIVE API JIT FUNCTIONS</A><DD>
<DT id="10"><A HREF="#lbAK">PCRE2 NATIVE API SERIALIZATION FUNCTIONS</A><DD>
<DT id="11"><A HREF="#lbAL">PCRE2 NATIVE API AUXILIARY FUNCTIONS</A><DD>
<DT id="12"><A HREF="#lbAM">PCRE2 NATIVE API OBSOLETE FUNCTIONS</A><DD>
<DT id="13"><A HREF="#lbAN">PCRE2 EXPERIMENTAL PATTERN CONVERSION FUNCTIONS</A><DD>
<DT id="14"><A HREF="#lbAO">PCRE2 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</A><DD>
<DT id="15"><A HREF="#lbAP">PCRE2 API OVERVIEW</A><DD>
<DT id="16"><A HREF="#lbAQ">STRING LENGTHS AND OFFSETS</A><DD>
<DT id="17"><A HREF="#lbAR">NEWLINES</A><DD>
<DT id="18"><A HREF="#lbAS">MULTITHREADING</A><DD>
<DL>
<DT id="19"><A HREF="#lbAT">The compiled pattern</A><DD>
<DT id="20"><A HREF="#lbAU">Context blocks</A><DD>
<DT id="21"><A HREF="#lbAV">Match blocks</A><DD>
</DL>
<DT id="22"><A HREF="#lbAW">PCRE2 CONTEXTS</A><DD>
<DL>
<DT id="23"><A HREF="#lbAX">The general context</A><DD>
<DT id="24"><A HREF="#lbAY">The compile context</A><DD>
<DT id="25"><A HREF="#lbAZ">The match context</A><DD>
</DL>
<DT id="26"><A HREF="#lbBA">CHECKING BUILD-TIME OPTIONS</A><DD>
<DT id="27"><A HREF="#lbBB">COMPILING A PATTERN</A><DD>
<DL>
<DT id="28"><A HREF="#lbBC">Main compile options</A><DD>
<DT id="29"><A HREF="#lbBD">Extra compile options</A><DD>
</DL>
<DT id="30"><A HREF="#lbBE">JUST-IN-TIME (JIT) COMPILATION</A><DD>
<DT id="31"><A HREF="#lbBF">LOCALE SUPPORT</A><DD>
<DT id="32"><A HREF="#lbBG">INFORMATION ABOUT A COMPILED PATTERN</A><DD>
<DT id="33"><A HREF="#lbBH">INFORMATION ABOUT A PATTERN'S CALLOUTS</A><DD>
<DT id="34"><A HREF="#lbBI">SERIALIZATION AND PRECOMPILING</A><DD>
<DT id="35"><A HREF="#lbBJ">THE MATCH DATA BLOCK</A><DD>
<DT id="36"><A HREF="#lbBK">MATCHING A PATTERN: THE TRADITIONAL FUNCTION</A><DD>
<DL>
<DT id="37"><A HREF="#lbBL">The string to be matched by <B>pcre2_match()</B></A><DD>
<DT id="38"><A HREF="#lbBM">Option bits for <B>pcre2_match()</B></A><DD>
</DL>
<DT id="39"><A HREF="#lbBN">NEWLINE HANDLING WHEN MATCHING</A><DD>
<DT id="40"><A HREF="#lbBO">HOW PCRE2_MATCH() RETURNS A STRING AND CAPTURED SUBSTRINGS</A><DD>
<DT id="41"><A HREF="#lbBP">OTHER INFORMATION ABOUT A MATCH</A><DD>
<DT id="42"><A HREF="#lbBQ">ERROR RETURNS FROM <B>pcre2_match()</B></A><DD>
<DT id="43"><A HREF="#lbBR">OBTAINING A TEXTUAL ERROR MESSAGE</A><DD>
<DT id="44"><A HREF="#lbBS">EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</A><DD>
<DT id="45"><A HREF="#lbBT">EXTRACTING A LIST OF ALL CAPTURED SUBSTRINGS</A><DD>
<DT id="46"><A HREF="#lbBU">EXTRACTING CAPTURED SUBSTRINGS BY NAME</A><DD>
<DT id="47"><A HREF="#lbBV">CREATING A NEW STRING WITH SUBSTITUTIONS</A><DD>
<DL>
<DT id="48"><A HREF="#lbBW">Substitution callouts</A><DD>
</DL>
<DT id="49"><A HREF="#lbBX">DUPLICATE CAPTURE GROUP NAMES</A><DD>
<DT id="50"><A HREF="#lbBY">FINDING ALL POSSIBLE MATCHES AT ONE POSITION</A><DD>
<DT id="51"><A HREF="#lbBZ">MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</A><DD>
<DL>
<DT id="52"><A HREF="#lbCA">Option bits for <B>pcre_dfa_match()</B></A><DD>
<DT id="53"><A HREF="#lbCB">Successful returns from <B>pcre2_dfa_match()</B></A><DD>
<DT id="54"><A HREF="#lbCC">Error returns from <B>pcre2_dfa_match()</B></A><DD>
</DL>
<DT id="55"><A HREF="#lbCD">SEE ALSO</A><DD>
<DT id="56"><A HREF="#lbCE">AUTHOR</A><DD>
<DT id="57"><A HREF="#lbCF">REVISION</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:49 GMT, March 31, 2021
</BODY>
</HTML>
