
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of SD_BUS_CREDS_GET_PID</TITLE>
</HEAD><BODY>
<H1>SD_BUS_CREDS_GET_PID</H1>
Section: sd_bus_creds_get_pid (3)<BR>Updated: <BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>





















<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

sd_bus_creds_get_pid, sd_bus_creds_get_ppid, sd_bus_creds_get_tid, sd_bus_creds_get_uid, sd_bus_creds_get_euid, sd_bus_creds_get_suid, sd_bus_creds_get_fsuid, sd_bus_creds_get_gid, sd_bus_creds_get_egid, sd_bus_creds_get_sgid, sd_bus_creds_get_fsgid, sd_bus_creds_get_supplementary_gids, sd_bus_creds_get_comm, sd_bus_creds_get_tid_comm, sd_bus_creds_get_exe, sd_bus_creds_get_cmdline, sd_bus_creds_get_cgroup, sd_bus_creds_get_unit, sd_bus_creds_get_slice, sd_bus_creds_get_user_unit, sd_bus_creds_get_user_slice, sd_bus_creds_get_session, sd_bus_creds_get_owner_uid, sd_bus_creds_has_effective_cap, sd_bus_creds_has_permitted_cap, sd_bus_creds_has_inheritable_cap, sd_bus_creds_has_bounding_cap, sd_bus_creds_get_selinux_context, sd_bus_creds_get_audit_session_id, sd_bus_creds_get_audit_login_uid, sd_bus_creds_get_tty, sd_bus_creds_get_unique_name, sd_bus_creds_get_well_known_names, sd_bus_creds_get_description - Retrieve fields from a credentials object
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>
<B>
</B><PRE>
#include &lt;<A HREF="file:///usr/include/systemd/sd-bus.h">systemd/sd-bus.h</A>&gt;
</PRE>


<DL COMPACT>
<DT id="1">
<B>int sd_bus_creds_get_pid(sd_bus_creds&nbsp;*</B><I>c</I><B>, pid_t&nbsp;*</B><I>pid</I><B>);</B>

<DT id="2">
<B>int sd_bus_creds_get_ppid(sd_bus_creds&nbsp;*</B><I>c</I><B>, pid_t&nbsp;*</B><I>ppid</I><B>);</B>

<DT id="3">
<B>int sd_bus_creds_get_tid(sd_bus_creds&nbsp;*</B><I>c</I><B>, pid_t&nbsp;*</B><I>tid</I><B>);</B>

<DT id="4">
<B>int sd_bus_creds_get_uid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>uid</I><B>);</B>

<DT id="5">
<B>int sd_bus_creds_get_euid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>uid</I><B>);</B>

<DT id="6">
<B>int sd_bus_creds_get_suid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>uid</I><B>);</B>

<DT id="7">
<B>int sd_bus_creds_get_fsuid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>uid</I><B>);</B>

<DT id="8">
<B>int sd_bus_creds_get_gid(sd_bus_creds&nbsp;*</B><I>c</I><B>, gid_t&nbsp;*</B><I>gid</I><B>);</B>

<DT id="9">
<B>int sd_bus_creds_get_egid(sd_bus_creds&nbsp;*</B><I>c</I><B>, gid_t&nbsp;*</B><I>gid</I><B>);</B>

<DT id="10">
<B>int sd_bus_creds_get_sgid(sd_bus_creds&nbsp;*</B><I>c</I><B>, gid_t&nbsp;*</B><I>gid</I><B>);</B>

<DT id="11">
<B>int sd_bus_creds_get_fsgid(sd_bus_creds&nbsp;*</B><I>c</I><B>, gid_t&nbsp;*</B><I>gid</I><B>);</B>

<DT id="12">
<B>int sd_bus_creds_get_supplementary_gids(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;gid_t&nbsp;**</B><I>gids</I><B>);</B>

<DT id="13">
<B>int sd_bus_creds_get_comm(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>comm</I><B>);</B>

<DT id="14">
<B>int sd_bus_creds_get_tid_comm(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>comm</I><B>);</B>

<DT id="15">
<B>int sd_bus_creds_get_exe(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>exe</I><B>);</B>

<DT id="16">
<B>int sd_bus_creds_get_cmdline(sd_bus_creds&nbsp;*</B><I>c</I><B>, char&nbsp;***</B><I>cmdline</I><B>);</B>

<DT id="17">
<B>int sd_bus_creds_get_cgroup(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>cgroup</I><B>);</B>

<DT id="18">
<B>int sd_bus_creds_get_unit(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>unit</I><B>);</B>

<DT id="19">
<B>int sd_bus_creds_get_slice(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>slice</I><B>);</B>

<DT id="20">
<B>int sd_bus_creds_get_user_unit(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>unit</I><B>);</B>

<DT id="21">
<B>int sd_bus_creds_get_user_slice(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>slice</I><B>);</B>

<DT id="22">
<B>int sd_bus_creds_get_session(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>slice</I><B>);</B>

<DT id="23">
<B>int sd_bus_creds_get_owner_uid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>uid</I><B>);</B>

<DT id="24">
<B>int sd_bus_creds_has_effective_cap(sd_bus_creds&nbsp;*</B><I>c</I><B>, int&nbsp;</B><I>capability</I><B>);</B>

<DT id="25">
<B>int sd_bus_creds_has_permitted_cap(sd_bus_creds&nbsp;*</B><I>c</I><B>, int&nbsp;</B><I>capability</I><B>);</B>

<DT id="26">
<B>int sd_bus_creds_has_inheritable_cap(sd_bus_creds&nbsp;*</B><I>c</I><B>, int&nbsp;</B><I>capability</I><B>);</B>

<DT id="27">
<B>int sd_bus_creds_has_bounding_cap(sd_bus_creds&nbsp;*</B><I>c</I><B>, int&nbsp;</B><I>capability</I><B>);</B>

<DT id="28">
<B>int sd_bus_creds_get_selinux_context(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>context</I><B>);</B>

<DT id="29">
<B>int sd_bus_creds_get_audit_session_id(sd_bus_creds&nbsp;*</B><I>c</I><B>, uint32_t&nbsp;*</B><I>sessionid</I><B>);</B>

<DT id="30">
<B>int sd_bus_creds_get_audit_login_uid(sd_bus_creds&nbsp;*</B><I>c</I><B>, uid_t&nbsp;*</B><I>loginuid</I><B>);</B>

<DT id="31">
<B>int sd_bus_creds_get_tty(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>tty</I><B>);</B>

<DT id="32">
<B>int sd_bus_creds_get_unique_name(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>name</I><B>);</B>

<DT id="33">
<B>int sd_bus_creds_get_well_known_names(sd_bus_creds&nbsp;*</B><I>c</I><B>, char&nbsp;***</B><I>name</I><B>);</B>

<DT id="34">
<B>int sd_bus_creds_get_description(sd_bus_creds&nbsp;*</B><I>c</I><B>, const&nbsp;char&nbsp;**</B><I>name</I><B>);</B>

</DL>
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

<DD>These functions return credential information from an
<I>sd_bus_creds</I>
object. Credential objects may be created with
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_creds_new_from_pid">sd_bus_creds_new_from_pid</A></B>(3), in which case they describe the credentials of the process identified by the specified PID, with
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_get_name_creds">sd_bus_get_name_creds</A></B>(3), in which case they describe the credentials of a bus peer identified by the specified bus name, with
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_get_owner_creds">sd_bus_get_owner_creds</A></B>(3), in which case they describe the credentials of the creator of a bus, or with
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_message_get_creds">sd_bus_message_get_creds</A></B>(3), in which case they describe the credentials of the sender of the message.
<P>

Not all credential fields are part of every
&quot;sd_bus_creds&quot;
object. Use
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_creds_get_mask">sd_bus_creds_get_mask</A></B>(3)
to determine the mask of fields available.
<P>

<B>sd_bus_creds_get_pid()</B>
will retrieve the PID (process identifier). Similarly,
<B>sd_bus_creds_get_ppid()</B>
will retrieve the parent PID. Note that PID 1 has no parent process, in which case -ENXIO is returned.
<P>

<B>sd_bus_creds_get_tid()</B>
will retrieve the TID (thread identifier).
<P>

<B>sd_bus_creds_get_uid()</B>
will retrieve the numeric UID (user identifier). Similarly,
<B>sd_bus_creds_get_euid()</B>
returns the effective UID,
<B>sd_bus_creds_get_suid()</B>
the saved UID and
<B>sd_bus_creds_get_fsuid()</B>
the file system UID.
<P>

<B>sd_bus_creds_get_gid()</B>
will retrieve the numeric GID (group identifier). Similarly,
<B>sd_bus_creds_get_egid()</B>
returns the effective GID,
<B>sd_bus_creds_get_sgid()</B>
the saved GID and
<B>sd_bus_creds_get_fsgid()</B>
the file system GID.
<P>

<B>sd_bus_creds_get_supplementary_gids()</B>
will retrieve the supplementary GIDs list.
<P>

<B>sd_bus_creds_get_comm()</B>
will retrieve the comm field (truncated name of the executable, as stored in
/proc/<I>pid</I>/comm).
<P>

<B>sd_bus_creds_get_tid_comm()</B>
will retrieve the comm field of the thread (as stored in
/proc/<I>pid</I>/task/<I>tid</I>/comm).
<P>

<B>sd_bus_creds_get_exe()</B>
will retrieve the path to the program executable (as stored in the
/proc/<I>pid</I>/exe
link, but with the
&quot; (deleted)&quot;
suffix removed). Note that kernel threads do not have an executable path, in which case -ENXIO is returned. Note that this property should not be used for more than explanatory information, in particular it should not be used for security-relevant decisions. That's because the executable might have been replaced or removed by the time the value can be processed. Moreover, the kernel exports this information in an ambiguous way (i.e. a deleted executable cannot be safely distinguished from one whose name suffix is
&quot; (deleted)&quot;.
<P>

<B>sd_bus_creds_get_cmdline()</B>
will retrieve an array of command line arguments (as stored in
/proc/<I>pid</I>/cmdline). Note that kernel threads do not have a command line, in which case -ENXIO is returned.
<P>

<B>sd_bus_creds_get_cgroup()</B>
will retrieve the control group path. See
m[blue]<B>cgroups.txt</B>m[]<FONT SIZE="-2">[1]</FONT>.
<P>

<B>sd_bus_creds_get_unit()</B>
will retrieve the systemd unit name (in the system instance of systemd) that the process is a part of. See
<B><A HREF="/cgi-bin/man/man2html?5+systemd.unit">systemd.unit</A></B>(5). For processes that are not part of a unit, returns -ENXIO.
<P>

<B>sd_bus_creds_get_user_unit()</B>
will retrieve the systemd unit name (in the user instance of systemd) that the process is a part of. See
<B><A HREF="/cgi-bin/man/man2html?5+systemd.unit">systemd.unit</A></B>(5). For processes that are not part of a user unit, returns -ENXIO.
<P>

<B>sd_bus_creds_get_slice()</B>
will retrieve the systemd slice (a unit in the system instance of systemd) that the process is a part of. See
<B><A HREF="/cgi-bin/man/man2html?5+systemd.slice">systemd.slice</A></B>(5). Similarly,
<B>sd_bus_creds_get_user_slice()</B>
retrieves the systemd slice of the process, in the user instance of systemd.
<P>

<B>sd_bus_creds_get_session()</B>
will retrieve the identifier of the login session that the process is a part of. Please note the login session may be limited to a stub process or two. User processes may instead be started from their systemd user manager, e.g. GUI applications started using DBus activation, as well as service processes which are shared between multiple logins of the same user. For processes that are not part of a session, returns -ENXIO.
<P>

<B>sd_bus_creds_get_owner_uid()</B>
will retrieve the numeric UID (user identifier) of the user who owns the user unit or login session that the process is a part of. See
<B><A HREF="/cgi-bin/man/man2html?8+systemd-logind.service">systemd-logind.service</A></B>(8). For processes that are not part of a user unit or session, returns -ENXIO.
<P>

<B>sd_bus_creds_has_effective_cap()</B>
will check whether the capability specified by
<I>capability</I>
was set in the effective capabilities mask. A positive return value means that it was set, zero means that it was not set, and a negative return value indicates an error. See
<B><A HREF="/cgi-bin/man/man2html?7+capabilities">capabilities</A></B>(7)
and the
<I>AmbientCapabilities=</I>
and
<I>CapabilityBoundingSet=</I>
settings in
<B><A HREF="/cgi-bin/man/man2html?5+systemd.exec">systemd.exec</A></B>(5).
<P>

<B>sd_bus_creds_has_permitted_cap()</B>
is similar to
<B>sd_bus_creds_has_effective_cap()</B>, but will check the permitted capabilities mask.
<P>

<B>sd_bus_creds_has_inheritable_cap()</B>
is similar to
<B>sd_bus_creds_has_effective_cap()</B>, but will check the inheritable capabilities mask.
<P>

<B>sd_bus_creds_has_bounding_cap()</B>
is similar to
<B>sd_bus_creds_has_effective_cap()</B>, but will check the bounding capabilities mask.
<P>

<B>sd_bus_creds_get_selinux_context()</B>
will retrieve the SELinux security context (label) of the process.
<P>

<B>sd_bus_creds_get_audit_session_id()</B>
will retrieve the audit session identifier of the process. Returns -ENXIO for processes that are not part of an audit session.
<P>

<B>sd_bus_creds_get_audit_login_uid()</B>
will retrieve the audit user login identifier (the identifier of the user who is &quot;responsible&quot; for the session). Returns -ENXIO for processes that are not part of an audit session.
<P>

<B>sd_bus_creds_get_tty()</B>
will retrieve the controlling TTY, without the prefixing &quot;/dev/&quot;. Returns -ENXIO for processes that have no controlling TTY.
<P>

<B>sd_bus_creds_get_unique_name()</B>
will retrieve the D-Bus unique name. See
m[blue]<B>The D-Bus specification</B>m[]<FONT SIZE="-2">[2]</FONT>.
<P>

<B>sd_bus_creds_get_well_known_names()</B>
will retrieve the set of D-Bus well-known names. See
m[blue]<B>The D-Bus specification</B>m[]<FONT SIZE="-2">[2]</FONT>.
<P>

<B>sd_bus_creds_get_description()</B>
will retrieve a descriptive name of the bus connection of the peer. This name is useful to discern multiple bus connections by the same peer, and may be altered by the peer with the
<B><A HREF="/cgi-bin/man/man2html?3+sd_bus_set_description">sd_bus_set_description</A></B>(3)
call.
<P>

All functions that take a
<I>const char**</I>
parameter will store the answer there as an address of a NUL-terminated string. It will be valid as long as
<I>c</I>
remains valid, and should not be freed or modified by the caller.
<P>

All functions that take a
<I>char***</I>
parameter will store the answer there as an address of an array of strings. Each individual string is NUL-terminated, and the array is NULL-terminated as a whole. It will be valid as long as
<I>c</I>
remains valid, and should not be freed or modified by the caller.
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

<P>

On success, these calls return 0 or a positive integer. On failure, these calls return a negative errno-style error code.
<A NAME="lbAF">&nbsp;</A>
<H3>Errors</H3>

<P>

Returned errors may indicate the following problems:
<P>

<B>-ENODATA</B>
<DL COMPACT><DT id="35"><DD>
The given field is not available in the credentials object
<I>c</I>.
</DL>

<P>

<B>-ENXIO</B>
<DL COMPACT><DT id="36"><DD>
The given field is not specified for the described process or peer. This will be returned by
<B>sd_bus_creds_get_unit()</B>,
<B>sd_bus_creds_get_slice()</B>,
<B>sd_bus_creds_get_user_unit()</B>,
<B>sd_bus_creds_get_user_slice()</B>, and
<B>sd_bus_creds_get_session()</B>
if the process is not part of a systemd system unit, systemd user unit, systemd slice, or logind session. It will be returned by
<B>sd_bus_creds_get_owner_uid()</B>
if the process is not part of a systemd user unit or logind session. It will also be returned by
<B>sd_bus_creds_get_exe()</B>
and
<B>sd_bus_creds_get_cmdline()</B>
for kernel threads (since these are not started from an executable binary, nor have a command line), and by
<B>sd_bus_creds_get_audit_session_id()</B>
and
<B>sd_bus_creds_get_audit_login_uid()</B>
when the process is not part of an audit session, and
<B>sd_bus_creds_get_tty()</B>
if the process has no controlling TTY.
</DL>

<P>

<B>-EINVAL</B>
<DL COMPACT><DT id="37"><DD>
Specified pointer parameter is
<B>NULL</B>.
</DL>

<P>

<B>-ENOMEM</B>
<DL COMPACT><DT id="38"><DD>
Memory allocation failed.
</DL>

<A NAME="lbAG">&nbsp;</A>
<H2>NOTES</H2>

<P>

These APIs are implemented as a shared library, which can be compiled and linked to with the
<B>libsystemd</B>&nbsp;<B><A HREF="/cgi-bin/man/man2html?1+pkg-config">pkg-config</A></B>(1)
file.
<A NAME="lbAH">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>

<B><A HREF="/cgi-bin/man/man2html?1+systemd">systemd</A></B>(1),
<B><A HREF="/cgi-bin/man/man2html?3+sd-bus">sd-bus</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?2+sd_bus_creds_new_from_pid">sd_bus_creds_new_from_pid</A></B>(2),
<B><A HREF="/cgi-bin/man/man2html?2+fork">fork</A></B>(2),
<B><A HREF="/cgi-bin/man/man2html?2+execve">execve</A></B>(2),
<B><A HREF="/cgi-bin/man/man2html?7+credentials">credentials</A></B>(7),
<B><A HREF="/cgi-bin/man/man2html?3+free">free</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?5+proc">proc</A></B>(5),
<B><A HREF="/cgi-bin/man/man2html?7+systemd.journal-fields">systemd.journal-fields</A></B>(7)
<A NAME="lbAI">&nbsp;</A>
<H2>NOTES</H2>

<DL COMPACT>
<DT id="39"> 1.<DD>
cgroups.txt
<DL COMPACT><DT id="40"><DD>
<A HREF="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt</A>
</DL>

<DT id="41"> 2.<DD>
The D-Bus specification
<DL COMPACT><DT id="42"><DD>
<A HREF="http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus">http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus</A>
</DL>

<P>
</DL>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="43"><A HREF="#lbAB">NAME</A><DD>
<DT id="44"><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT id="45"><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT id="46"><A HREF="#lbAE">RETURN VALUE</A><DD>
<DL>
<DT id="47"><A HREF="#lbAF">Errors</A><DD>
</DL>
<DT id="48"><A HREF="#lbAG">NOTES</A><DD>
<DT id="49"><A HREF="#lbAH">SEE ALSO</A><DD>
<DT id="50"><A HREF="#lbAI">NOTES</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:54 GMT, March 31, 2021
</BODY>
</HTML>
