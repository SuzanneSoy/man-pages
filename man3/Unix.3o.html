
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Unix</TITLE>
</HEAD><BODY>
<H1>Unix</H1>
Section: OCaml library (3o)<BR>Updated: 2020-01-30<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Unix - Interface to the Unix system.
<A NAME="lbAC">&nbsp;</A>
<H2>Module</H2>

Module   Unix
<A NAME="lbAD">&nbsp;</A>
<H2>Documentation</H2>

<P>
Module
<B>Unix</B>

<BR>&nbsp;:&nbsp;
<B>sig  end</B>

<P>
<P>
Interface to the Unix system.
<P>
Note: all the functions of this module (except 
<B>Unix.error_message</B>

and
<B>Unix.handle_unix_error</B>

) are liable to raise the 
<B>Unix.Unix_error</B>

exception whenever the underlying system call signals an error.
<P>
<P>
<P>
<P>
<P>
<P>
<P>

<A NAME="lbAE">&nbsp;</A>
<H3>Error report</H3>

<P>
<P>

<I>type error </I>

=
<BR>&nbsp;|&nbsp;E2BIG&nbsp;&nbsp;(*&nbsp;Argument&nbsp;list&nbsp;too&nbsp;long
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EACCES&nbsp;&nbsp;(*&nbsp;Permission&nbsp;denied
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EAGAIN&nbsp;&nbsp;(*&nbsp;Resource&nbsp;temporarily&nbsp;unavailable;&nbsp;try&nbsp;again
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EBADF&nbsp;&nbsp;(*&nbsp;Bad&nbsp;file&nbsp;descriptor
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EBUSY&nbsp;&nbsp;(*&nbsp;Resource&nbsp;unavailable
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ECHILD&nbsp;&nbsp;(*&nbsp;No&nbsp;child&nbsp;process
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EDEADLK&nbsp;&nbsp;(*&nbsp;Resource&nbsp;deadlock&nbsp;would&nbsp;occur
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EDOM&nbsp;&nbsp;(*&nbsp;Domain&nbsp;error&nbsp;for&nbsp;math&nbsp;functions,&nbsp;etc.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EEXIST&nbsp;&nbsp;(*&nbsp;File&nbsp;exists
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EFAULT&nbsp;&nbsp;(*&nbsp;Bad&nbsp;address
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EFBIG&nbsp;&nbsp;(*&nbsp;File&nbsp;too&nbsp;large
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EINTR&nbsp;&nbsp;(*&nbsp;Function&nbsp;interrupted&nbsp;by&nbsp;signal
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EINVAL&nbsp;&nbsp;(*&nbsp;Invalid&nbsp;argument
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EIO&nbsp;&nbsp;(*&nbsp;Hardware&nbsp;I/O&nbsp;error
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EISDIR&nbsp;&nbsp;(*&nbsp;Is&nbsp;a&nbsp;directory
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EMFILE&nbsp;&nbsp;(*&nbsp;Too&nbsp;many&nbsp;open&nbsp;files&nbsp;by&nbsp;the&nbsp;process
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EMLINK&nbsp;&nbsp;(*&nbsp;Too&nbsp;many&nbsp;links
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENAMETOOLONG&nbsp;&nbsp;(*&nbsp;Filename&nbsp;too&nbsp;long
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENFILE&nbsp;&nbsp;(*&nbsp;Too&nbsp;many&nbsp;open&nbsp;files&nbsp;in&nbsp;the&nbsp;system
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENODEV&nbsp;&nbsp;(*&nbsp;No&nbsp;such&nbsp;device
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOENT&nbsp;&nbsp;(*&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOEXEC&nbsp;&nbsp;(*&nbsp;Not&nbsp;an&nbsp;executable&nbsp;file
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOLCK&nbsp;&nbsp;(*&nbsp;No&nbsp;locks&nbsp;available
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOMEM&nbsp;&nbsp;(*&nbsp;Not&nbsp;enough&nbsp;memory
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOSPC&nbsp;&nbsp;(*&nbsp;No&nbsp;space&nbsp;left&nbsp;on&nbsp;device
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOSYS&nbsp;&nbsp;(*&nbsp;Function&nbsp;not&nbsp;supported
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOTDIR&nbsp;&nbsp;(*&nbsp;Not&nbsp;a&nbsp;directory
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOTEMPTY&nbsp;&nbsp;(*&nbsp;Directory&nbsp;not&nbsp;empty
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOTTY&nbsp;&nbsp;(*&nbsp;Inappropriate&nbsp;I/O&nbsp;control&nbsp;operation
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENXIO&nbsp;&nbsp;(*&nbsp;No&nbsp;such&nbsp;device&nbsp;or&nbsp;address
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EPERM&nbsp;&nbsp;(*&nbsp;Operation&nbsp;not&nbsp;permitted
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EPIPE&nbsp;&nbsp;(*&nbsp;Broken&nbsp;pipe
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ERANGE&nbsp;&nbsp;(*&nbsp;Result&nbsp;too&nbsp;large
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EROFS&nbsp;&nbsp;(*&nbsp;Read-only&nbsp;file&nbsp;system
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ESPIPE&nbsp;&nbsp;(*&nbsp;Invalid&nbsp;seek&nbsp;e.g.&nbsp;on&nbsp;a&nbsp;pipe
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ESRCH&nbsp;&nbsp;(*&nbsp;No&nbsp;such&nbsp;process
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EXDEV&nbsp;&nbsp;(*&nbsp;Invalid&nbsp;link
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EWOULDBLOCK&nbsp;&nbsp;(*&nbsp;Operation&nbsp;would&nbsp;block
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EINPROGRESS&nbsp;&nbsp;(*&nbsp;Operation&nbsp;now&nbsp;in&nbsp;progress
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EALREADY&nbsp;&nbsp;(*&nbsp;Operation&nbsp;already&nbsp;in&nbsp;progress
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOTSOCK&nbsp;&nbsp;(*&nbsp;Socket&nbsp;operation&nbsp;on&nbsp;non-socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EDESTADDRREQ&nbsp;&nbsp;(*&nbsp;Destination&nbsp;address&nbsp;required
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EMSGSIZE&nbsp;&nbsp;(*&nbsp;Message&nbsp;too&nbsp;long
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EPROTOTYPE&nbsp;&nbsp;(*&nbsp;Protocol&nbsp;wrong&nbsp;type&nbsp;for&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOPROTOOPT&nbsp;&nbsp;(*&nbsp;Protocol&nbsp;not&nbsp;available
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EPROTONOSUPPORT&nbsp;&nbsp;(*&nbsp;Protocol&nbsp;not&nbsp;supported
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ESOCKTNOSUPPORT&nbsp;&nbsp;(*&nbsp;Socket&nbsp;type&nbsp;not&nbsp;supported
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EOPNOTSUPP&nbsp;&nbsp;(*&nbsp;Operation&nbsp;not&nbsp;supported&nbsp;on&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EPFNOSUPPORT&nbsp;&nbsp;(*&nbsp;Protocol&nbsp;family&nbsp;not&nbsp;supported
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EAFNOSUPPORT&nbsp;&nbsp;(*&nbsp;Address&nbsp;family&nbsp;not&nbsp;supported&nbsp;by&nbsp;protocol&nbsp;family
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EADDRINUSE&nbsp;&nbsp;(*&nbsp;Address&nbsp;already&nbsp;in&nbsp;use
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EADDRNOTAVAIL&nbsp;&nbsp;(*&nbsp;Can't&nbsp;assign&nbsp;requested&nbsp;address
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENETDOWN&nbsp;&nbsp;(*&nbsp;Network&nbsp;is&nbsp;down
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENETUNREACH&nbsp;&nbsp;(*&nbsp;Network&nbsp;is&nbsp;unreachable
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENETRESET&nbsp;&nbsp;(*&nbsp;Network&nbsp;dropped&nbsp;connection&nbsp;on&nbsp;reset
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ECONNABORTED&nbsp;&nbsp;(*&nbsp;Software&nbsp;caused&nbsp;connection&nbsp;abort
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ECONNRESET&nbsp;&nbsp;(*&nbsp;Connection&nbsp;reset&nbsp;by&nbsp;peer
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOBUFS&nbsp;&nbsp;(*&nbsp;No&nbsp;buffer&nbsp;space&nbsp;available
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EISCONN&nbsp;&nbsp;(*&nbsp;Socket&nbsp;is&nbsp;already&nbsp;connected
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ENOTCONN&nbsp;&nbsp;(*&nbsp;Socket&nbsp;is&nbsp;not&nbsp;connected
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ESHUTDOWN&nbsp;&nbsp;(*&nbsp;Can't&nbsp;send&nbsp;after&nbsp;socket&nbsp;shutdown
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ETOOMANYREFS&nbsp;&nbsp;(*&nbsp;Too&nbsp;many&nbsp;references:&nbsp;can't&nbsp;splice
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ETIMEDOUT&nbsp;&nbsp;(*&nbsp;Connection&nbsp;timed&nbsp;out
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ECONNREFUSED&nbsp;&nbsp;(*&nbsp;Connection&nbsp;refused
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EHOSTDOWN&nbsp;&nbsp;(*&nbsp;Host&nbsp;is&nbsp;down
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EHOSTUNREACH&nbsp;&nbsp;(*&nbsp;No&nbsp;route&nbsp;to&nbsp;host
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ELOOP&nbsp;&nbsp;(*&nbsp;Too&nbsp;many&nbsp;levels&nbsp;of&nbsp;symbolic&nbsp;links
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EOVERFLOW&nbsp;&nbsp;(*&nbsp;File&nbsp;size&nbsp;or&nbsp;position&nbsp;not&nbsp;representable
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;EUNKNOWNERR
<B>of </B>

<B>int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;Unknown&nbsp;error
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The type of error codes.
Errors defined in the POSIX standard
and additional errors from UNIX98 and BSD.
All other errors are mapped to EUNKNOWNERR.
<P>
<P>
<P>
<I>exception Unix_error </I>

<B>of </B>

<B>error * string * string</B>

<P>
<P>
Raised by the system calls below when an error is encountered.
The first component is the error code; the second component
is the function name; the third component is the string parameter
to the function, if it has one, or the empty string otherwise.
<P>
<P>
<P>
<I>val error_message </I>

: 
<B>error -&gt; string</B>

<P>
Return a string describing the given error code.
<P>
<P>
<P>
<I>val handle_unix_error </I>

: 
<B>('a -&gt; 'b) -&gt; 'a -&gt; 'b</B>

<P>
<P>
<B>handle_unix_error f x</B>

applies 
<B>f</B>

to 
<B>x</B>

and returns the result.
If the exception 
<B>Unix.Unix_error</B>

is raised, it prints a message
describing the error and exits with code 2.
<P>
<P>
<P>
<P>

<A NAME="lbAF">&nbsp;</A>
<H3>Access to the process environment</H3>

<P>
<P>

<P>
<I>val environment </I>

: 
<B>unit -&gt; string array</B>

<P>
Return the process environment, as an array of strings
with the format ``variable=value''.  The returned array
is empty if the process has special privileges.
<P>
<P>
<P>
<I>val unsafe_environment </I>

: 
<B>unit -&gt; string array</B>

<P>
Return the process environment, as an array of strings with the
format ``variable=value''.  Unlike 
<B>Unix.environment</B>

, this function
returns a populated array even if the process has special
privileges.  See the documentation for 
<B>Unix.unsafe_getenv</B>

for more
details.
<P>
<P>
<B>Since</B>

4.06.0
<P>
<P>
<P>
<I>val getenv </I>

: 
<B>string -&gt; string</B>

<P>
Return the value associated to a variable in the process
environment, unless the process has special privileges.
<P>
<P>
<B>Raises Not_found</B>

if the variable is unbound or the process has
special privileges.
<P>
(This function is identical to 
<B>Sys.getenv</B>

.
<P>
<P>
<P>
<I>val unsafe_getenv </I>

: 
<B>string -&gt; string</B>

<P>
Return the value associated to a variable in the process
environment.
<P>
Unlike 
<B>Unix.getenv</B>

, this function returns the value even if the
process has special privileges. It is considered unsafe because the
programmer of a setuid or setgid program must be careful to avoid
using maliciously crafted environment variables in the search path
for executables, the locations for temporary files or logs, and the
like.
<P>
<P>
<B>Since</B>

4.06.0
<P>
<P>
<B>Raises Not_found</B>

if the variable is unbound.
<P>
<P>
<P>
<I>val putenv </I>

: 
<B>string -&gt; string -&gt; unit</B>

<P>
<P>
<B>Unix.putenv name value</B>

sets the value associated to a
variable in the process environment.
<B>name</B>

is the name of the environment variable,
and 
<B>value</B>

its new associated value.
<P>
<P>
<P>
<P>

<A NAME="lbAG">&nbsp;</A>
<H3>Process handling</H3>

<P>
<P>

<I>type process_status </I>

=
<BR>&nbsp;|&nbsp;WEXITED
<B>of </B>

<B>int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;The&nbsp;process&nbsp;terminated&nbsp;normally&nbsp;by&nbsp;
<B>exit</B>

;
the argument is the return code.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;WSIGNALED
<B>of </B>

<B>int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;The&nbsp;process&nbsp;was&nbsp;killed&nbsp;by&nbsp;a&nbsp;signal;
the argument is the signal number.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;WSTOPPED
<B>of </B>

<B>int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;The&nbsp;process&nbsp;was&nbsp;stopped&nbsp;by&nbsp;a&nbsp;signal;&nbsp;the&nbsp;argument&nbsp;is&nbsp;the
signal number.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The termination status of a process.  See module 
<B>Sys</B>

for the
definitions of the standard signal numbers.  Note that they are
not the numbers used by the OS.
<P>
<P>
<I>type wait_flag </I>

=
<BR>&nbsp;|&nbsp;WNOHANG&nbsp;&nbsp;(*&nbsp;Do&nbsp;not&nbsp;block&nbsp;if&nbsp;no&nbsp;child&nbsp;has
died yet, but immediately return with a pid equal to 0.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;WUNTRACED&nbsp;&nbsp;(*&nbsp;Report&nbsp;also&nbsp;the&nbsp;children&nbsp;that&nbsp;receive&nbsp;stop&nbsp;signals.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Flags for 
<B>Unix.waitpid</B>

.
<P>
<P>
<P>
<I>val execv </I>

: 
<B>string -&gt; string array -&gt; 'a</B>

<P>
<P>
<B>execv prog args</B>

execute the program in file 
<B>prog</B>

, with
the arguments 
<B>args</B>

, and the current process environment.
These 
<B>execv*</B>

functions never return: on success, the current
program is replaced by the new one.
<P>
<P>
<B>Raises Unix.Unix_error</B>

on failure.
<P>
<P>
<P>
<I>val execve </I>

: 
<B>string -&gt; string array -&gt; string array -&gt; 'a</B>

<P>
Same as 
<B>Unix.execv</B>

, except that the third argument provides the
environment to the program executed.
<P>
<P>
<P>
<I>val execvp </I>

: 
<B>string -&gt; string array -&gt; 'a</B>

<P>
Same as 
<B>Unix.execv</B>

, except that
the program is searched in the path.
<P>
<P>
<P>
<I>val execvpe </I>

: 
<B>string -&gt; string array -&gt; string array -&gt; 'a</B>

<P>
Same as 
<B>Unix.execve</B>

, except that
the program is searched in the path.
<P>
<P>
<P>
<I>val fork </I>

: 
<B>unit -&gt; int</B>

<P>
Fork a new process. The returned integer is 0 for the child
process, the pid of the child process for the parent process.
<P>
On Windows: not implemented, use 
<B>Unix.create_process</B>

or threads.
<P>
<P>
<P>
<I>val wait </I>

: 
<B>unit -&gt; int * process_status</B>

<P>
Wait until one of the children processes die, and return its pid
and termination status.
<P>
On Windows: Not implemented, use 
<B>Unix.waitpid</B>

.
<P>
<P>
<P>
<I>val waitpid </I>

: 
<B>wait_flag list -&gt; int -&gt; int * process_status</B>

<P>
Same as 
<B>Unix.wait</B>

, but waits for the child process whose pid is given.
A pid of 
<B>-1</B>

means wait for any child.
A pid of 
<B>0</B>

means wait for any child in the same process group
as the current process.
Negative pid arguments represent process groups.
The list of options indicates whether 
<B>waitpid</B>

should return
immediately without waiting, and whether it should report stopped
children.
<P>
On Windows, this function can only wait for a given PID, not any
child process.
<P>
<P>
<P>
<I>val system </I>

: 
<B>string -&gt; process_status</B>

<P>
Execute the given command, wait until it terminates, and return
its termination status. The string is interpreted by the shell
<B>/bin/sh</B>

(or the command interpreter 
<B>cmd.exe</B>

on Windows) and
therefore can contain redirections, quotes, variables, etc. The
result 
<B>WEXITED 127</B>

indicates that the shell couldn't be
executed.
<P>
<P>
<P>
<I>val getpid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the pid of the process.
<P>
<P>
<P>
<I>val getppid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the pid of the parent process.
On Windows: not implemented (because it is meaningless).
<P>
<P>
<P>
<I>val nice </I>

: 
<B>int -&gt; int</B>

<P>
Change the process priority. The integer argument is added to the
``nice'' value. (Higher values of the ``nice'' value mean
lower priorities.) Return the new nice value.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<P>

<A NAME="lbAH">&nbsp;</A>
<H3>Basic file input/output</H3>

<P>
<P>

<I>type file_descr </I>

<P>
<P>
The abstract type of file descriptors.
<P>
<P>
<P>
<I>val stdin </I>

: 
<B>file_descr</B>

<P>
File descriptor for standard input.
<P>
<P>
<P>
<I>val stdout </I>

: 
<B>file_descr</B>

<P>
File descriptor for standard output.
<P>
<P>
<P>
<I>val stderr </I>

: 
<B>file_descr</B>

<P>
File descriptor for standard error.
<P>
<P>
<I>type open_flag </I>

=
<BR>&nbsp;|&nbsp;O_RDONLY&nbsp;&nbsp;(*&nbsp;Open&nbsp;for&nbsp;reading
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_WRONLY&nbsp;&nbsp;(*&nbsp;Open&nbsp;for&nbsp;writing
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_RDWR&nbsp;&nbsp;(*&nbsp;Open&nbsp;for&nbsp;reading&nbsp;and&nbsp;writing
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_NONBLOCK&nbsp;&nbsp;(*&nbsp;Open&nbsp;in&nbsp;non-blocking&nbsp;mode
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_APPEND&nbsp;&nbsp;(*&nbsp;Open&nbsp;for&nbsp;append
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_CREAT&nbsp;&nbsp;(*&nbsp;Create&nbsp;if&nbsp;nonexistent
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_TRUNC&nbsp;&nbsp;(*&nbsp;Truncate&nbsp;to&nbsp;0&nbsp;length&nbsp;if&nbsp;existing
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_EXCL&nbsp;&nbsp;(*&nbsp;Fail&nbsp;if&nbsp;existing
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_NOCTTY&nbsp;&nbsp;(*&nbsp;Don't&nbsp;make&nbsp;this&nbsp;dev&nbsp;a&nbsp;controlling&nbsp;tty
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_DSYNC&nbsp;&nbsp;(*&nbsp;Writes&nbsp;complete&nbsp;as&nbsp;`Synchronised&nbsp;I/O&nbsp;data
integrity completion'
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_SYNC&nbsp;&nbsp;(*&nbsp;Writes&nbsp;complete&nbsp;as&nbsp;`Synchronised&nbsp;I/O&nbsp;file
integrity completion'
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_RSYNC&nbsp;&nbsp;(*&nbsp;Reads&nbsp;complete&nbsp;as&nbsp;writes&nbsp;(depending&nbsp;on
O_SYNC/O_DSYNC)
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_SHARE_DELETE&nbsp;&nbsp;(*&nbsp;Windows&nbsp;only:&nbsp;allow&nbsp;the&nbsp;file&nbsp;to&nbsp;be&nbsp;deleted
while still open
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_CLOEXEC&nbsp;&nbsp;(*&nbsp;Set&nbsp;the&nbsp;close-on-exec&nbsp;flag&nbsp;on&nbsp;the
descriptor returned by 
<B>Unix.openfile</B>

.
See 
<B>Unix.set_close_on_exec</B>

for more
information.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;O_KEEPEXEC&nbsp;&nbsp;(*&nbsp;Clear&nbsp;the&nbsp;close-on-exec&nbsp;flag.
This is currently the default.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The flags to 
<B>Unix.openfile</B>

.
<P>
<P>
<I>type file_perm </I>

= 
<B>int</B>

<P>
<P>
The type of file access rights, e.g. 
<B>0o640</B>

is read and write for user,
read for group, none for others
<P>
<P>
<P>
<I>val openfile </I>

: 
<B>string -&gt; open_flag list -&gt; file_perm -&gt; file_descr</B>

<P>
Open the named file with the given flags. Third argument is the
permissions to give to the file if it is created (see
<B>Unix.umask</B>

). Return a file descriptor on the named file.
<P>
<P>
<P>
<I>val close </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Close a file descriptor.
<P>
<P>
<P>
<I>val fsync </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Flush file buffers to disk.
<P>
<P>
<P>
<I>val read </I>

: 
<B>file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int</B>

<P>
<P>
<B>read fd buff ofs len</B>

reads 
<B>len</B>

bytes from descriptor 
<B>fd</B>

,
storing them in byte sequence 
<B>buff</B>

, starting at position 
<B>ofs</B>

in
<B>buff</B>

. Return the number of bytes actually read.
<P>
<P>
<P>
<I>val write </I>

: 
<B>file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int</B>

<P>
<P>
<B>write fd buff ofs len</B>

writes 
<B>len</B>

bytes to descriptor 
<B>fd</B>

,
taking them from byte sequence 
<B>buff</B>

, starting at position 
<B>ofs</B>

in 
<B>buff</B>

. Return the number of bytes actually written.  
<B>write</B>

repeats the writing operation until all bytes have been written or
an error occurs.
<P>
<P>
<P>
<I>val single_write </I>

: 
<B>file_descr -&gt; bytes -&gt; int -&gt; int -&gt; int</B>

<P>
Same as 
<B>write</B>

, but attempts to write only once.
Thus, if an error occurs, 
<B>single_write</B>

guarantees that no data
has been written.
<P>
<P>
<P>
<I>val write_substring </I>

: 
<B>file_descr -&gt; string -&gt; int -&gt; int -&gt; int</B>

<P>
Same as 
<B>write</B>

, but take the data from a string instead of a byte
sequence.
<P>
<P>
<B>Since</B>

4.02.0
<P>
<P>
<P>
<I>val single_write_substring </I>

: 
<B>file_descr -&gt; string -&gt; int -&gt; int -&gt; int</B>

<P>
Same as 
<B>single_write</B>

, but take the data from a string instead of
a byte sequence.
<P>
<P>
<B>Since</B>

4.02.0
<P>
<P>
<P>
<P>

<A NAME="lbAI">&nbsp;</A>
<H3>Interfacing with the standard input/output library</H3>

<P>
<P>

<P>
<I>val in_channel_of_descr </I>

: 
<B>file_descr -&gt; in_channel</B>

<P>
Create an input channel reading from the given descriptor.
The channel is initially in binary mode; use
<B>set_binary_mode_in ic false</B>

if text mode is desired.
Text mode is supported only if the descriptor refers to a file
or pipe, but is not supported if it refers to a socket.
On Windows, 
<B>set_binary_mode_in</B>

always fails on channels created
with this function.
<P>
Beware that channels are buffered so more characters may have been
read from the file descriptor than those accessed using channel functions.
Channels also keep a copy of the current position in the file.
<P>
You need to explicitly close all channels created with this function.
Closing the channel also closes the underlying file descriptor (unless
it was already closed).
<P>
<P>
<P>
<I>val out_channel_of_descr </I>

: 
<B>file_descr -&gt; out_channel</B>

<P>
Create an output channel writing on the given descriptor.
The channel is initially in binary mode; use
<B>set_binary_mode_out oc false</B>

if text mode is desired.
Text mode is supported only if the descriptor refers to a file
or pipe, but is not supported if it refers to a socket.
On Windows, 
<B>set_binary_mode_out</B>

always fails on channels created
with this function.
<P>
Beware that channels are buffered so you may have to 
<B>flush</B>

them
to ensure that all data has been sent to the file descriptor.
Channels also keep a copy of the current position in the file.
<P>
You need to explicitly close all channels created with this function.
Closing the channel flushes the data and closes the underlying file
descriptor (unless it has already been closed, in which case the
buffered data is lost).
<P>
<P>
<P>
<I>val descr_of_in_channel </I>

: 
<B>in_channel -&gt; file_descr</B>

<P>
Return the descriptor corresponding to an input channel.
<P>
<P>
<P>
<I>val descr_of_out_channel </I>

: 
<B>out_channel -&gt; file_descr</B>

<P>
Return the descriptor corresponding to an output channel.
<P>
<P>
<P>
<P>

<A NAME="lbAJ">&nbsp;</A>
<H3>Seeking and truncating</H3>

<P>
<P>

<I>type seek_command </I>

=
<BR>&nbsp;|&nbsp;SEEK_SET&nbsp;&nbsp;(*&nbsp;indicates&nbsp;positions&nbsp;relative&nbsp;to&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;file
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SEEK_CUR&nbsp;&nbsp;(*&nbsp;indicates&nbsp;positions&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;position
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SEEK_END&nbsp;&nbsp;(*&nbsp;indicates&nbsp;positions&nbsp;relative&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Positioning modes for 
<B>Unix.lseek</B>

.
<P>
<P>
<P>
<I>val lseek </I>

: 
<B>file_descr -&gt; int -&gt; seek_command -&gt; int</B>

<P>
Set the current position for a file descriptor, and return the resulting
offset (from the beginning of the file).
<P>
<P>
<P>
<I>val truncate </I>

: 
<B>string -&gt; int -&gt; unit</B>

<P>
Truncates the named file to the given size.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<I>val ftruncate </I>

: 
<B>file_descr -&gt; int -&gt; unit</B>

<P>
Truncates the file corresponding to the given descriptor
to the given size.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<P>

<A NAME="lbAK">&nbsp;</A>
<H3>File status</H3>

<P>
<P>

<I>type file_kind </I>

=
<BR>&nbsp;|&nbsp;S_REG&nbsp;&nbsp;(*&nbsp;Regular&nbsp;file
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_DIR&nbsp;&nbsp;(*&nbsp;Directory
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_CHR&nbsp;&nbsp;(*&nbsp;Character&nbsp;device
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_BLK&nbsp;&nbsp;(*&nbsp;Block&nbsp;device
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_LNK&nbsp;&nbsp;(*&nbsp;Symbolic&nbsp;link
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_FIFO&nbsp;&nbsp;(*&nbsp;Named&nbsp;pipe
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;S_SOCK&nbsp;&nbsp;(*&nbsp;Socket
<BR>&nbsp;*)
<BR>&nbsp;
<P>
<P>
<P>
<I>type stats </I>

= {
<BR>&nbsp;st_dev&nbsp;:&nbsp;
<B>int</B>

;  (* Device number
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_ino&nbsp;:&nbsp;
<B>int</B>

;  (* Inode number
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_kind&nbsp;:&nbsp;
<B>file_kind</B>

;  (* Kind of the file
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_perm&nbsp;:&nbsp;
<B>file_perm</B>

;  (* Access rights
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_nlink&nbsp;:&nbsp;
<B>int</B>

;  (* Number of links
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_uid&nbsp;:&nbsp;
<B>int</B>

;  (* User id of the owner
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_gid&nbsp;:&nbsp;
<B>int</B>

;  (* Group ID of the file's group
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_rdev&nbsp;:&nbsp;
<B>int</B>

;  (* Device ID (if special file)
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_size&nbsp;:&nbsp;
<B>int</B>

;  (* Size in bytes
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_atime&nbsp;:&nbsp;
<B>float</B>

;  (* Last access time
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_mtime&nbsp;:&nbsp;
<B>float</B>

;  (* Last modification time
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;st_ctime&nbsp;:&nbsp;
<B>float</B>

;  (* Last status change time
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
The information returned by the 
<B>Unix.stat</B>

calls.
<P>
<P>
<P>
<I>val stat </I>

: 
<B>string -&gt; stats</B>

<P>
Return the information for the named file.
<P>
<P>
<P>
<I>val lstat </I>

: 
<B>string -&gt; stats</B>

<P>
Same as 
<B>Unix.stat</B>

, but in case the file is a symbolic link,
return the information for the link itself.
<P>
<P>
<P>
<I>val fstat </I>

: 
<B>file_descr -&gt; stats</B>

<P>
Return the information for the file associated with the given
descriptor.
<P>
<P>
<P>
<I>val isatty </I>

: 
<B>file_descr -&gt; bool</B>

<P>
Return 
<B>true</B>

if the given file descriptor refers to a terminal or
console window, 
<B>false</B>

otherwise.
<P>
<P>
<P>
<P>

<A NAME="lbAL">&nbsp;</A>
<H3>File operations on large files</H3>

<P>
<P>

<I>module LargeFile : </I>

<B>sig  end</B>

<P>
<P>
File operations on large files.
This sub-module provides 64-bit variants of the functions
<B>Unix.lseek</B>

(for positioning a file descriptor),
<B>Unix.truncate</B>

and 
<B>Unix.ftruncate</B>

(for changing the size of a file),
and 
<B>Unix.stat</B>

, 
<B>Unix.lstat</B>

and 
<B>Unix.fstat</B>

(for obtaining
information on files).  These alternate functions represent
positions and sizes by 64-bit integers (type 
<B>int64</B>

) instead of
regular integers (type 
<B>int</B>

), thus allowing operating on files
whose sizes are greater than 
<B>max_int</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAM">&nbsp;</A>
<H3>Mapping files into memory</H3>

<P>
<P>

<P>
<I>val map_file </I>

: 
<B>file_descr -&gt;</B>

<B>?pos:int64 -&gt;</B>

<B>('a, 'b) Bigarray.kind -&gt;</B>

<B>'c Bigarray.layout -&gt;</B>

<B>bool -&gt; int array -&gt; ('a, 'b, 'c) Bigarray.Genarray.t</B>

<P>
Memory mapping of a file as a Bigarray.
<B>map_file fd kind layout shared dims</B>

returns a Bigarray of kind 
<B>kind</B>

, layout 
<B>layout</B>

,
and dimensions as specified in 
<B>dims</B>

.  The data contained in
this Bigarray are the contents of the file referred to by
the file descriptor 
<B>fd</B>

(as opened previously with
<B>Unix.openfile</B>

, for example).  The optional 
<B>pos</B>

parameter
is the byte offset in the file of the data being mapped;
it defaults to 0 (map from the beginning of the file).
<P>
If 
<B>shared</B>

is 
<B>true</B>

, all modifications performed on the array
are reflected in the file.  This requires that 
<B>fd</B>

be opened
with write permissions.  If 
<B>shared</B>

is 
<B>false</B>

, modifications
performed on the array are done in memory only, using
copy-on-write of the modified pages; the underlying file is not
affected.
<P>
<P>
<B>Genarray.map_file</B>

is much more efficient than reading
the whole file in a Bigarray, modifying that Bigarray,
and writing it afterwards.
<P>
To adjust automatically the dimensions of the Bigarray to
the actual size of the file, the major dimension (that is,
the first dimension for an array with C layout, and the last
dimension for an array with Fortran layout) can be given as
<B>-1</B>

.  
<B>Genarray.map_file</B>

then determines the major dimension
from the size of the file.  The file must contain an integral
number of sub-arrays as determined by the non-major dimensions,
otherwise 
<B>Failure</B>

is raised.
<P>
If all dimensions of the Bigarray are given, the file size is
matched against the size of the Bigarray.  If the file is larger
than the Bigarray, only the initial portion of the file is
mapped to the Bigarray.  If the file is smaller than the big
array, the file is automatically grown to the size of the Bigarray.
This requires write permissions on 
<B>fd</B>

.
<P>
Array accesses are bounds-checked, but the bounds are determined by
the initial call to 
<B>map_file</B>

. Therefore, you should make sure no
other process modifies the mapped file while you're accessing it,
or a SIGBUS signal may be raised. This happens, for instance, if the
file is shrunk.
<P>
<P>
<B>Invalid_argument</B>

or 
<B>Failure</B>

may be raised in cases where argument
validation fails.
<P>
<P>
<B>Since</B>

4.06.0
<P>
<P>
<P>
<P>

<A NAME="lbAN">&nbsp;</A>
<H3>Operations on file names</H3>

<P>
<P>

<P>
<I>val unlink </I>

: 
<B>string -&gt; unit</B>

<P>
Removes the named file.
<P>
If the named file is a directory, raises:
<P>
-
<B>EPERM</B>

on POSIX compliant system
<P>
-
<B>EISDIR</B>

on Linux &gt;= 2.1.132
<P>
-
<B>EACCESS</B>

on Windows
<P>
<P>
<P>
<P>
<I>val rename </I>

: 
<B>string -&gt; string -&gt; unit</B>

<P>
<P>
<B>rename old new</B>

changes the name of a file from 
<B>old</B>

to 
<B>new</B>

,
moving it between directories if needed.  If 
<B>new</B>

already
exists, its contents will be replaced with those of 
<B>old</B>

.
Depending on the operating system, the metadata (permissions,
owner, etc) of 
<B>new</B>

can either be preserved or be replaced by
those of 
<B>old</B>

.
<P>
<P>
<P>
<I>val link </I>

: 
<B>?follow:bool -&gt; string -&gt; string -&gt; unit</B>

<P>
<P>
<B>link ?follow source dest</B>

creates a hard link named 
<B>dest</B>

to the file
named 
<B>source</B>

.
<P>
<P>
<B>Raises ENOSYS</B>

On Unix if 
<B>~follow:_</B>

is requested, but linkat is
unavailable.
<P>
<P>
<B>Raises ENOSYS</B>

On Windows if 
<B>~follow:false</B>

is requested.
<P>
<P>
<P>
<P>

<A NAME="lbAO">&nbsp;</A>
<H3>File permissions and ownership</H3>

<P>
<P>

<I>type access_permission </I>

=
<BR>&nbsp;|&nbsp;R_OK&nbsp;&nbsp;(*&nbsp;Read&nbsp;permission
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;W_OK&nbsp;&nbsp;(*&nbsp;Write&nbsp;permission
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;X_OK&nbsp;&nbsp;(*&nbsp;Execution&nbsp;permission
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_OK&nbsp;&nbsp;(*&nbsp;File&nbsp;exists
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Flags for the 
<B>Unix.access</B>

call.
<P>
<P>
<P>
<I>val chmod </I>

: 
<B>string -&gt; file_perm -&gt; unit</B>

<P>
Change the permissions of the named file.
<P>
<P>
<P>
<I>val fchmod </I>

: 
<B>file_descr -&gt; file_perm -&gt; unit</B>

<P>
Change the permissions of an opened file.
On Windows: not implemented.
<P>
<P>
<P>
<I>val chown </I>

: 
<B>string -&gt; int -&gt; int -&gt; unit</B>

<P>
Change the owner uid and owner gid of the named file.
On Windows: not implemented (make no sense on a DOS file system).
<P>
<P>
<P>
<I>val fchown </I>

: 
<B>file_descr -&gt; int -&gt; int -&gt; unit</B>

<P>
Change the owner uid and owner gid of an opened file.
On Windows: not implemented (make no sense on a DOS file system).
<P>
<P>
<P>
<I>val umask </I>

: 
<B>int -&gt; int</B>

<P>
Set the process's file mode creation mask, and return the previous
mask.
On Windows: not implemented.
<P>
<P>
<P>
<I>val access </I>

: 
<B>string -&gt; access_permission list -&gt; unit</B>

<P>
Check that the process has the given permissions over the named file.
<P>
<P>
<B>Raises Unix_error</B>

otherwise.
<P>
On Windows, execute permission 
<B>X_OK</B>

, cannot be tested, it just
tests for read permission instead.
<P>
<P>
<P>
<P>

<A NAME="lbAP">&nbsp;</A>
<H3>Operations on file descriptors</H3>

<P>
<P>

<P>
<I>val dup </I>

: 
<B>?cloexec:bool -&gt; file_descr -&gt; file_descr</B>

<P>
Return a new file descriptor referencing the same file as
the given descriptor.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val dup2 </I>

: 
<B>?cloexec:bool -&gt; file_descr -&gt; file_descr -&gt; unit</B>

<P>
<P>
<B>dup2 fd1 fd2</B>

duplicates 
<B>fd1</B>

to 
<B>fd2</B>

, closing 
<B>fd2</B>

if already
opened.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val set_nonblock </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Set the ``non-blocking'' flag on the given descriptor.
When the non-blocking flag is set, reading on a descriptor
on which there is temporarily no data available raises the
<B>EAGAIN</B>

or 
<B>EWOULDBLOCK</B>

error instead of blocking;
writing on a descriptor on which there is temporarily no room
for writing also raises 
<B>EAGAIN</B>

or 
<B>EWOULDBLOCK</B>

.
<P>
<P>
<P>
<I>val clear_nonblock </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Clear the ``non-blocking'' flag on the given descriptor.
See 
<B>Unix.set_nonblock</B>

.
<P>
<P>
<P>
<I>val set_close_on_exec </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Set the ``close-on-exec'' flag on the given descriptor.
A descriptor with the close-on-exec flag is automatically
closed when the current process starts another program with
one of the 
<B>exec</B>

, 
<B>create_process</B>

and 
<B>open_process</B>

functions.
<P>
It is often a security hole to leak file descriptors opened on, say,
a private file to an external program: the program, then, gets access
to the private file and can do bad things with it.  Hence, it is
highly recommended to set all file descriptors ``close-on-exec'',
except in the very few cases where a file descriptor actually needs
to be transmitted to another program.
<P>
The best way to set a file descriptor ``close-on-exec'' is to create
it in this state.  To this end, the 
<B>openfile</B>

function has
<B>O_CLOEXEC</B>

and 
<B>O_KEEPEXEC</B>

flags to enforce ``close-on-exec'' mode
or ``keep-on-exec'' mode, respectively.  All other operations in
the Unix module that create file descriptors have an optional
argument 
<B>?cloexec:bool</B>

to indicate whether the file descriptor
should be created in ``close-on-exec'' mode (by writing
<B>~cloexec:true</B>

) or in ``keep-on-exec'' mode (by writing
<B>~cloexec:false</B>

).  For historical reasons, the default file
descriptor creation mode is ``keep-on-exec'', if no 
<B>cloexec</B>

optional
argument is given.  This is not a safe default, hence it is highly
recommended to pass explicit 
<B>cloexec</B>

arguments to operations that
create file descriptors.
<P>
The 
<B>cloexec</B>

optional arguments and the 
<B>O_KEEPEXEC</B>

flag were introduced
in OCaml 4.05.  Earlier, the common practice was to create file descriptors
in the default, ``keep-on-exec'' mode, then call 
<B>set_close_on_exec</B>

on those freshly-created file descriptors.  This is not as safe as
creating the file descriptor in ``close-on-exec'' mode because, in
multithreaded programs, a window of vulnerability exists between the time
when the file descriptor is created and the time 
<B>set_close_on_exec</B>

completes.  If another thread spawns another program during this window,
the descriptor will leak, as it is still in the ``keep-on-exec'' mode.
<P>
Regarding the atomicity guarantees given by 
<B>~cloexec:true</B>

or by
the use of the 
<B>O_CLOEXEC</B>

flag: on all platforms it is guaranteed
that a concurrently-executing Caml thread cannot leak the descriptor
by starting a new process.  On Linux, this guarantee extends to
concurrently-executing C threads.  As of Feb 2017, other operating
systems lack the necessary system calls and still expose a window
of vulnerability during which a C thread can see the newly-created
file descriptor in ``keep-on-exec'' mode.
<P>
<P>
<P>
<I>val clear_close_on_exec </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Clear the ``close-on-exec'' flag on the given descriptor.
See 
<B>Unix.set_close_on_exec</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAQ">&nbsp;</A>
<H3>Directories</H3>

<P>
<P>

<P>
<I>val mkdir </I>

: 
<B>string -&gt; file_perm -&gt; unit</B>

<P>
Create a directory with the given permissions (see 
<B>Unix.umask</B>

).
<P>
<P>
<P>
<I>val rmdir </I>

: 
<B>string -&gt; unit</B>

<P>
Remove an empty directory.
<P>
<P>
<P>
<I>val chdir </I>

: 
<B>string -&gt; unit</B>

<P>
Change the process working directory.
<P>
<P>
<P>
<I>val getcwd </I>

: 
<B>unit -&gt; string</B>

<P>
Return the name of the current working directory.
<P>
<P>
<P>
<I>val chroot </I>

: 
<B>string -&gt; unit</B>

<P>
Change the process root directory.
On Windows: not implemented.
<P>
<P>
<I>type dir_handle </I>

<P>
<P>
The type of descriptors over opened directories.
<P>
<P>
<P>
<I>val opendir </I>

: 
<B>string -&gt; dir_handle</B>

<P>
Open a descriptor on a directory
<P>
<P>
<P>
<I>val readdir </I>

: 
<B>dir_handle -&gt; string</B>

<P>
Return the next entry in a directory.
<P>
<P>
<B>Raises End_of_file</B>

when the end of the directory has been reached.
<P>
<P>
<P>
<I>val rewinddir </I>

: 
<B>dir_handle -&gt; unit</B>

<P>
Reposition the descriptor to the beginning of the directory
<P>
<P>
<P>
<I>val closedir </I>

: 
<B>dir_handle -&gt; unit</B>

<P>
Close a directory descriptor.
<P>
<P>
<P>
<P>

<A NAME="lbAR">&nbsp;</A>
<H3>Pipes and redirections</H3>

<P>
<P>

<P>
<I>val pipe </I>

: 
<B>?cloexec:bool -&gt; unit -&gt; file_descr * file_descr</B>

<P>
Create a pipe. The first component of the result is opened
for reading, that's the exit to the pipe. The second component is
opened for writing, that's the entrance to the pipe.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val mkfifo </I>

: 
<B>string -&gt; file_perm -&gt; unit</B>

<P>
Create a named pipe with the given permissions (see 
<B>Unix.umask</B>

).
On Windows: not implemented.
<P>
<P>
<P>
<P>

<A NAME="lbAS">&nbsp;</A>
<H3>High-level process and redirection management</H3>

<P>
<P>

<P>
<I>val create_process </I>

: 
<B>string -&gt;</B>

<B>string array -&gt; file_descr -&gt; file_descr -&gt; file_descr -&gt; int</B>

<P>
<P>
<B>create_process prog args new_stdin new_stdout new_stderr</B>

forks a new process that executes the program
in file 
<B>prog</B>

, with arguments 
<B>args</B>

. The pid of the new
process is returned immediately; the new process executes
concurrently with the current process.
The standard input and outputs of the new process are connected
to the descriptors 
<B>new_stdin</B>

, 
<B>new_stdout</B>

and 
<B>new_stderr</B>

.
Passing e.g. 
<B>stdout</B>

for 
<B>new_stdout</B>

prevents the redirection
and causes the new process to have the same standard output
as the current process.
The executable file 
<B>prog</B>

is searched in the path.
The new process has the same environment as the current process.
<P>
<P>
<P>
<I>val create_process_env </I>

: 
<B>string -&gt;</B>

<B>string array -&gt;</B>

<B>string array -&gt; file_descr -&gt; file_descr -&gt; file_descr -&gt; int</B>

<P>
<P>
<B>create_process_env prog args env new_stdin new_stdout new_stderr</B>

works as 
<B>Unix.create_process</B>

, except that the extra argument
<B>env</B>

specifies the environment passed to the program.
<P>
<P>
<P>
<I>val open_process_in </I>

: 
<B>string -&gt; in_channel</B>

<P>
High-level pipe and process management. This function
runs the given command in parallel with the program.
The standard output of the command is redirected to a pipe,
which can be read via the returned input channel.
The command is interpreted by the shell 
<B>/bin/sh</B>

(or 
<B>cmd.exe</B>

on Windows), cf. 
<B>system</B>

.
<P>
<P>
<P>
<I>val open_process_out </I>

: 
<B>string -&gt; out_channel</B>

<P>
Same as 
<B>Unix.open_process_in</B>

, but redirect the standard input of
the command to a pipe.  Data written to the returned output channel
is sent to the standard input of the command.
Warning: writes on output channels are buffered, hence be careful
to call 
<B>flush</B>

at the right times to ensure
correct synchronization.
<P>
<P>
<P>
<I>val open_process </I>

: 
<B>string -&gt; in_channel * out_channel</B>

<P>
Same as 
<B>Unix.open_process_out</B>

, but redirects both the standard input
and standard output of the command to pipes connected to the two
returned channels.  The input channel is connected to the output
of the command, and the output channel to the input of the command.
<P>
<P>
<P>
<I>val open_process_full </I>

: 
<B>string -&gt;</B>

<B>string array -&gt; in_channel * out_channel * in_channel</B>

<P>
Similar to 
<B>Unix.open_process</B>

, but the second argument specifies
the environment passed to the command.  The result is a triple
of channels connected respectively to the standard output, standard input,
and standard error of the command.
<P>
<P>
<P>
<I>val open_process_args_in </I>

: 
<B>string -&gt; string array -&gt; in_channel</B>

<P>
High-level pipe and process management. The first argument specifies the
command to run, and the second argument specifies the argument array passed
to the command.  This function runs the command in parallel with the program.
The standard output of the command is redirected to a pipe, which can be read
via the returned input channel.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val open_process_args_out </I>

: 
<B>string -&gt; string array -&gt; out_channel</B>

<P>
Same as 
<B>Unix.open_process_args_in</B>

, but redirect the standard input of the
command to a pipe.  Data written to the returned output channel is sent to
the standard input of the command.  Warning: writes on output channels are
buffered, hence be careful to call 
<B>flush</B>

at the right times to
ensure correct synchronization.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val open_process_args </I>

: 
<B>string -&gt; string array -&gt; in_channel * out_channel</B>

<P>
Same as 
<B>Unix.open_process_args_out</B>

, but redirects both the standard input
and standard output of the command to pipes connected to the two returned
channels.  The input channel is connected to the output of the command, and
the output channel to the input of the command.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val open_process_args_full </I>

: 
<B>string -&gt;</B>

<B>string array -&gt;</B>

<B>string array -&gt; in_channel * out_channel * in_channel</B>

<P>
Similar to 
<B>Unix.open_process_args</B>

, but the third argument specifies the
environment passed to the command.  The result is a triple of channels
connected respectively to the standard output, standard input, and standard
error of the command.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val process_in_pid </I>

: 
<B>in_channel -&gt; int</B>

<P>
Return the pid of a process opened via 
<B>Unix.open_process_in</B>

or
<B>Unix.open_process_args_in</B>

.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val process_out_pid </I>

: 
<B>out_channel -&gt; int</B>

<P>
Return the pid of a process opened via 
<B>Unix.open_process_out</B>

or
<B>Unix.open_process_args_out</B>

.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val process_pid </I>

: 
<B>in_channel * out_channel -&gt; int</B>

<P>
Return the pid of a process opened via 
<B>Unix.open_process</B>

or
<B>Unix.open_process_args</B>

.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val process_full_pid </I>

: 
<B>in_channel * out_channel * in_channel -&gt; int</B>

<P>
Return the pid of a process opened via 
<B>Unix.open_process_full</B>

or
<B>Unix.open_process_args_full</B>

.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val close_process_in </I>

: 
<B>in_channel -&gt; process_status</B>

<P>
Close channels opened by 
<B>Unix.open_process_in</B>

,
wait for the associated command to terminate,
and return its termination status.
<P>
<P>
<P>
<I>val close_process_out </I>

: 
<B>out_channel -&gt; process_status</B>

<P>
Close channels opened by 
<B>Unix.open_process_out</B>

,
wait for the associated command to terminate,
and return its termination status.
<P>
<P>
<P>
<I>val close_process </I>

: 
<B>in_channel * out_channel -&gt; process_status</B>

<P>
Close channels opened by 
<B>Unix.open_process</B>

,
wait for the associated command to terminate,
and return its termination status.
<P>
<P>
<P>
<I>val close_process_full </I>

: 
<B>in_channel * out_channel * in_channel -&gt;</B>

<B>process_status</B>

<P>
Close channels opened by 
<B>Unix.open_process_full</B>

,
wait for the associated command to terminate,
and return its termination status.
<P>
<P>
<P>
<P>

<A NAME="lbAT">&nbsp;</A>
<H3>Symbolic links</H3>

<P>
<P>

<P>
<I>val symlink </I>

: 
<B>?to_dir:bool -&gt; string -&gt; string -&gt; unit</B>

<P>
<P>
<B>symlink ?to_dir source dest</B>

creates the file 
<B>dest</B>

as a symbolic link
to the file 
<B>source</B>

. On Windows, 
<B>~to_dir</B>

indicates if the symbolic link
points to a directory or a file; if omitted, 
<B>symlink</B>

examines 
<B>source</B>

using 
<B>stat</B>

and picks appropriately, if 
<B>source</B>

does not exist then 
<B>false</B>

is assumed (for this reason, it is recommended that the 
<B>~to_dir</B>

parameter
be specified in new code). On Unix, 
<B>~to_dir</B>

is ignored.
<P>
Windows symbolic links are available in Windows Vista onwards. There are some
important differences between Windows symlinks and their POSIX counterparts.
<P>
Windows symbolic links come in two flavours: directory and regular, which
designate whether the symbolic link points to a directory or a file. The type
must be correct - a directory symlink which actually points to a file cannot
be selected with chdir and a file symlink which actually points to a
directory cannot be read or written (note that Cygwin's emulation layer
ignores this distinction).
<P>
When symbolic links are created to existing targets, this distinction doesn't
matter and 
<B>symlink</B>

will automatically create the correct kind of symbolic
link. The distinction matters when a symbolic link is created to a
non-existent target.
<P>
The other caveat is that by default symbolic links are a privileged
operation. Administrators will always need to be running elevated (or with
UAC disabled) and by default normal user accounts need to be granted the
SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via
Active Directory.
<P>
<P>
<B>Unix.has_symlink</B>

can be used to check that a process is able to create symbolic
links.
<P>
<P>
<P>
<I>val has_symlink </I>

: 
<B>unit -&gt; bool</B>

<P>
Returns 
<B>true</B>

if the user is able to create symbolic links. On Windows,
this indicates that the user not only has the SeCreateSymbolicLinkPrivilege
but is also running elevated, if necessary. On other platforms, this is
simply indicates that the symlink system call is available.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val readlink </I>

: 
<B>string -&gt; string</B>

<P>
Read the contents of a symbolic link.
<P>
<P>
<P>
<P>

<A NAME="lbAU">&nbsp;</A>
<H3>Polling</H3>

<P>
<P>

<P>
<I>val select </I>

: 
<B>file_descr list -&gt;</B>

<B>file_descr list -&gt;</B>

<B>file_descr list -&gt;</B>

<B>float -&gt; file_descr list * file_descr list * file_descr list</B>

<P>
Wait until some input/output operations become possible on
some channels. The three list arguments are, respectively, a set
of descriptors to check for reading (first argument), for writing
(second argument), or for exceptional conditions (third argument).
The fourth argument is the maximal timeout, in seconds; a
negative fourth argument means no timeout (unbounded wait).
The result is composed of three sets of descriptors: those ready
for reading (first component), ready for writing (second component),
and over which an exceptional condition is pending (third
component).
<P>
<P>
<P>
<P>

<A NAME="lbAV">&nbsp;</A>
<H3>Locking</H3>

<P>
<P>

<I>type lock_command </I>

=
<BR>&nbsp;|&nbsp;F_ULOCK&nbsp;&nbsp;(*&nbsp;Unlock&nbsp;a&nbsp;region
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_LOCK&nbsp;&nbsp;(*&nbsp;Lock&nbsp;a&nbsp;region&nbsp;for&nbsp;writing,&nbsp;and&nbsp;block&nbsp;if&nbsp;already&nbsp;locked
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_TLOCK&nbsp;&nbsp;(*&nbsp;Lock&nbsp;a&nbsp;region&nbsp;for&nbsp;writing,&nbsp;or&nbsp;fail&nbsp;if&nbsp;already&nbsp;locked
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_TEST&nbsp;&nbsp;(*&nbsp;Test&nbsp;a&nbsp;region&nbsp;for&nbsp;other&nbsp;process&nbsp;locks
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_RLOCK&nbsp;&nbsp;(*&nbsp;Lock&nbsp;a&nbsp;region&nbsp;for&nbsp;reading,&nbsp;and&nbsp;block&nbsp;if&nbsp;already&nbsp;locked
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;F_TRLOCK&nbsp;&nbsp;(*&nbsp;Lock&nbsp;a&nbsp;region&nbsp;for&nbsp;reading,&nbsp;or&nbsp;fail&nbsp;if&nbsp;already&nbsp;locked
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Commands for 
<B>Unix.lockf</B>

.
<P>
<P>
<P>
<I>val lockf </I>

: 
<B>file_descr -&gt; lock_command -&gt; int -&gt; unit</B>

<P>
<P>
<B>lockf fd cmd size</B>

puts a lock on a region of the file opened
as 
<B>fd</B>

. The region starts at the current read/write position for
<B>fd</B>

(as set by 
<B>Unix.lseek</B>

), and extends 
<B>size</B>

bytes forward if
<B>size</B>

is positive, 
<B>size</B>

bytes backwards if 
<B>size</B>

is negative,
or to the end of the file if 
<B>size</B>

is zero.
A write lock prevents any other
process from acquiring a read or write lock on the region.
A read lock prevents any other
process from acquiring a write lock on the region, but lets
other processes acquire read locks on it.
<P>
The 
<B>F_LOCK</B>

and 
<B>F_TLOCK</B>

commands attempts to put a write lock
on the specified region.
The 
<B>F_RLOCK</B>

and 
<B>F_TRLOCK</B>

commands attempts to put a read lock
on the specified region.
If one or several locks put by another process prevent the current process
from acquiring the lock, 
<B>F_LOCK</B>

and 
<B>F_RLOCK</B>

block until these locks
are removed, while 
<B>F_TLOCK</B>

and 
<B>F_TRLOCK</B>

fail immediately with an
exception.
The 
<B>F_ULOCK</B>

removes whatever locks the current process has on
the specified region.
Finally, the 
<B>F_TEST</B>

command tests whether a write lock can be
acquired on the specified region, without actually putting a lock.
It returns immediately if successful, or fails otherwise.
<P>
What happens when a process tries to lock a region of a file that is
already locked by the same process depends on the OS.  On POSIX-compliant
systems, the second lock operation succeeds and may &quot;promote&quot; the older
lock from read lock to write lock.  On Windows, the second lock
operation will block or fail.
<P>
<P>
<P>
<P>

<A NAME="lbAW">&nbsp;</A>
<H3>Signals</H3>

Note: installation of signal handlers is performed via
the functions 
<B>Sys.signal</B>

and 
<B>Sys.set_signal</B>

.
<P>

<P>
<I>val kill </I>

: 
<B>int -&gt; int -&gt; unit</B>

<P>
<P>
<B>kill pid sig</B>

sends signal number 
<B>sig</B>

to the process
with id 
<B>pid</B>

.  On Windows, only the 
<B>Sys.sigkill</B>

signal
is emulated.
<P>
<P>
<I>type sigprocmask_command </I>

=
<BR>&nbsp;|&nbsp;SIG_SETMASK
<BR>&nbsp;|&nbsp;SIG_BLOCK
<BR>&nbsp;|&nbsp;SIG_UNBLOCK
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val sigprocmask </I>

: 
<B>sigprocmask_command -&gt; int list -&gt; int list</B>

<P>
<P>
<B>sigprocmask cmd sigs</B>

changes the set of blocked signals.
If 
<B>cmd</B>

is 
<B>SIG_SETMASK</B>

, blocked signals are set to those in
the list 
<B>sigs</B>

.
If 
<B>cmd</B>

is 
<B>SIG_BLOCK</B>

, the signals in 
<B>sigs</B>

are added to
the set of blocked signals.
If 
<B>cmd</B>

is 
<B>SIG_UNBLOCK</B>

, the signals in 
<B>sigs</B>

are removed
from the set of blocked signals.
<B>sigprocmask</B>

returns the set of previously blocked signals.
<P>
When the systhreads version of the 
<B>Thread</B>

module is loaded, this
function redirects to 
<B>Thread.sigmask</B>

. I.e., 
<B>sigprocmask</B>

only
changes the mask of the current thread.
<P>
On Windows: not implemented (no inter-process signals on Windows).
<P>
<P>
<P>
<I>val sigpending </I>

: 
<B>unit -&gt; int list</B>

<P>
Return the set of blocked signals that are currently pending.
<P>
On Windows: not implemented (no inter-process signals on Windows).
<P>
<P>
<P>
<I>val sigsuspend </I>

: 
<B>int list -&gt; unit</B>

<P>
<P>
<B>sigsuspend sigs</B>

atomically sets the blocked signals to 
<B>sigs</B>

and waits for a non-ignored, non-blocked signal to be delivered.
On return, the blocked signals are reset to their initial value.
<P>
On Windows: not implemented (no inter-process signals on Windows).
<P>
<P>
<P>
<I>val pause </I>

: 
<B>unit -&gt; unit</B>

<P>
Wait until a non-ignored, non-blocked signal is delivered.
<P>
On Windows: not implemented (no inter-process signals on Windows).
<P>
<P>
<P>
<P>

<A NAME="lbAX">&nbsp;</A>
<H3>Time functions</H3>

<P>
<P>

<I>type process_times </I>

= {
<BR>&nbsp;tms_utime&nbsp;:&nbsp;
<B>float</B>

;  (* User time for the process
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tms_stime&nbsp;:&nbsp;
<B>float</B>

;  (* System time for the process
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tms_cutime&nbsp;:&nbsp;
<B>float</B>

;  (* User time for the children processes
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tms_cstime&nbsp;:&nbsp;
<B>float</B>

;  (* System time for the children processes
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
The execution times (CPU times) of a process.
<P>
<P>
<I>type tm </I>

= {
<BR>&nbsp;tm_sec&nbsp;:&nbsp;
<B>int</B>

;  (* Seconds 0..60
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_min&nbsp;:&nbsp;
<B>int</B>

;  (* Minutes 0..59
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_hour&nbsp;:&nbsp;
<B>int</B>

;  (* Hours 0..23
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_mday&nbsp;:&nbsp;
<B>int</B>

;  (* Day of month 1..31
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_mon&nbsp;:&nbsp;
<B>int</B>

;  (* Month of year 0..11
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_year&nbsp;:&nbsp;
<B>int</B>

;  (* Year - 1900
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_wday&nbsp;:&nbsp;
<B>int</B>

;  (* Day of week (Sunday is 0)
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_yday&nbsp;:&nbsp;
<B>int</B>

;  (* Day of year 0..365
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;tm_isdst&nbsp;:&nbsp;
<B>bool</B>

;  (* Daylight time savings in effect
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
The type representing wallclock time and calendar date.
<P>
<P>
<P>
<I>val time </I>

: 
<B>unit -&gt; float</B>

<P>
Return the current time since 00:00:00 GMT, Jan. 1, 1970,
in seconds.
<P>
<P>
<P>
<I>val gettimeofday </I>

: 
<B>unit -&gt; float</B>

<P>
Same as 
<B>Unix.time</B>

, but with resolution better than 1 second.
<P>
<P>
<P>
<I>val gmtime </I>

: 
<B>float -&gt; tm</B>

<P>
Convert a time in seconds, as returned by 
<B>Unix.time</B>

, into a date and
a time. Assumes UTC (Coordinated Universal Time), also known as GMT.
To perform the inverse conversion, set the TZ environment variable
to &quot;UTC&quot;, use 
<B>Unix.mktime</B>

, and then restore the original value of TZ.
<P>
<P>
<P>
<I>val localtime </I>

: 
<B>float -&gt; tm</B>

<P>
Convert a time in seconds, as returned by 
<B>Unix.time</B>

, into a date and
a time. Assumes the local time zone.
The function performing the inverse conversion is 
<B>Unix.mktime</B>

.
<P>
<P>
<P>
<I>val mktime </I>

: 
<B>tm -&gt; float * tm</B>

<P>
Convert a date and time, specified by the 
<B>tm</B>

argument, into
a time in seconds, as returned by 
<B>Unix.time</B>

.  The 
<B>tm_isdst</B>

,
<B>tm_wday</B>

and 
<B>tm_yday</B>

fields of 
<B>tm</B>

are ignored.  Also return a
normalized copy of the given 
<B>tm</B>

record, with the 
<B>tm_wday</B>

,
<B>tm_yday</B>

, and 
<B>tm_isdst</B>

fields recomputed from the other fields,
and the other fields normalized (so that, e.g., 40 October is
changed into 9 November).  The 
<B>tm</B>

argument is interpreted in the
local time zone.
<P>
<P>
<P>
<I>val alarm </I>

: 
<B>int -&gt; int</B>

<P>
Schedule a 
<B>SIGALRM</B>

signal after the given number of seconds.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<I>val sleep </I>

: 
<B>int -&gt; unit</B>

<P>
Stop execution for the given number of seconds.
<P>
<P>
<P>
<I>val sleepf </I>

: 
<B>float -&gt; unit</B>

<P>
Stop execution for the given number of seconds.  Like 
<B>sleep</B>

,
but fractions of seconds are supported.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<I>val times </I>

: 
<B>unit -&gt; process_times</B>

<P>
Return the execution times of the process.
On Windows, it is partially implemented, will not report timings
for child processes.
<P>
<P>
<P>
<I>val utimes </I>

: 
<B>string -&gt; float -&gt; float -&gt; unit</B>

<P>
Set the last access time (second arg) and last modification time
(third arg) for a file. Times are expressed in seconds from
00:00:00 GMT, Jan. 1, 1970.  If both times are 
<B>0.0</B>

, the access
and last modification times are both set to the current time.
<P>
<P>
<I>type interval_timer </I>

=
<BR>&nbsp;|&nbsp;ITIMER_REAL&nbsp;&nbsp;(*&nbsp;decrements&nbsp;in&nbsp;real&nbsp;time,&nbsp;and&nbsp;sends&nbsp;the&nbsp;signal&nbsp;
<B>SIGALRM</B>

when
expired.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ITIMER_VIRTUAL&nbsp;&nbsp;(*&nbsp;decrements&nbsp;in&nbsp;process&nbsp;virtual&nbsp;time,&nbsp;and&nbsp;sends&nbsp;
<B>SIGVTALRM</B>

when expired.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;ITIMER_PROF&nbsp;&nbsp;(*&nbsp;(for&nbsp;profiling)&nbsp;decrements&nbsp;both&nbsp;when&nbsp;the&nbsp;process
is running and when the system is running on behalf of the
process; it sends 
<B>SIGPROF</B>

when expired.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The three kinds of interval timers.
<P>
<P>
<I>type interval_timer_status </I>

= {
<BR>&nbsp;it_interval&nbsp;:&nbsp;
<B>float</B>

;  (* Period
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;it_value&nbsp;:&nbsp;
<B>float</B>

;  (* Current value of the timer
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
The type describing the status of an interval timer
<P>
<P>
<P>
<I>val getitimer </I>

: 
<B>interval_timer -&gt; interval_timer_status</B>

<P>
Return the current status of the given interval timer.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<I>val setitimer </I>

: 
<B>interval_timer -&gt;</B>

<B>interval_timer_status -&gt; interval_timer_status</B>

<P>
<P>
<B>setitimer t s</B>

sets the interval timer 
<B>t</B>

and returns
its previous status. The 
<B>s</B>

argument is interpreted as follows:
<B>s.it_value</B>

, if nonzero, is the time to the next timer expiration;
<B>s.it_interval</B>

, if nonzero, specifies a value to
be used in reloading 
<B>it_value</B>

when the timer expires.
Setting 
<B>s.it_value</B>

to zero disables the timer.
Setting 
<B>s.it_interval</B>

to zero causes the timer to be disabled
after its next expiration.
<P>
On Windows: not implemented.
<P>
<P>
<P>
<P>

<A NAME="lbAY">&nbsp;</A>
<H3>User id, group id</H3>

<P>
<P>

<P>
<I>val getuid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the user id of the user executing the process.
On Windows, always return 
<B>1</B>

.
<P>
<P>
<P>
<I>val geteuid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the effective user id under which the process runs.
On Windows, always return 
<B>1</B>

.
<P>
<P>
<P>
<I>val setuid </I>

: 
<B>int -&gt; unit</B>

<P>
Set the real user id and effective user id for the process.
On Windows: not implemented.
<P>
<P>
<P>
<I>val getgid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the group id of the user executing the process.
On Windows, always return 
<B>1</B>

.
<P>
<P>
<P>
<I>val getegid </I>

: 
<B>unit -&gt; int</B>

<P>
Return the effective group id under which the process runs.
On Windows, always return 
<B>1</B>

.
<P>
<P>
<P>
<I>val setgid </I>

: 
<B>int -&gt; unit</B>

<P>
Set the real group id and effective group id for the process.
On Windows: not implemented.
<P>
<P>
<P>
<I>val getgroups </I>

: 
<B>unit -&gt; int array</B>

<P>
Return the list of groups to which the user executing the process
belongs.
On Windows, always return 
<B>[|1|]</B>

.
<P>
<P>
<P>
<I>val setgroups </I>

: 
<B>int array -&gt; unit</B>

<P>
<P>
<B>setgroups groups</B>

sets the supplementary group IDs for the
calling process. Appropriate privileges are required.
On Windows: not implemented.
<P>
<P>
<P>
<I>val initgroups </I>

: 
<B>string -&gt; int -&gt; unit</B>

<P>
<P>
<B>initgroups user group</B>

initializes the group access list by
reading the group database /etc/group and using all groups of
which 
<B>user</B>

is a member. The additional group 
<B>group</B>

is also
added to the list.
On Windows: not implemented.
<P>
<P>
<I>type passwd_entry </I>

= {
<BR>&nbsp;pw_name&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;pw_passwd&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;pw_uid&nbsp;:&nbsp;
<B>int</B>

;
<BR>&nbsp;pw_gid&nbsp;:&nbsp;
<B>int</B>

;
<BR>&nbsp;pw_gecos&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;pw_dir&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;pw_shell&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;}
<P>
<P>
Structure of entries in the 
<B>passwd</B>

database.
<P>
<P>
<I>type group_entry </I>

= {
<BR>&nbsp;gr_name&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;gr_passwd&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;gr_gid&nbsp;:&nbsp;
<B>int</B>

;
<BR>&nbsp;gr_mem&nbsp;:&nbsp;
<B>string array</B>

;
<BR>&nbsp;}
<P>
<P>
Structure of entries in the 
<B>groups</B>

database.
<P>
<P>
<P>
<I>val getlogin </I>

: 
<B>unit -&gt; string</B>

<P>
Return the login name of the user executing the process.
<P>
<P>
<P>
<I>val getpwnam </I>

: 
<B>string -&gt; passwd_entry</B>

<P>
Find an entry in 
<B>passwd</B>

with the given name.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
On Windows, always raise 
<B>Not_found</B>

.
<P>
<P>
<P>
<I>val getgrnam </I>

: 
<B>string -&gt; group_entry</B>

<P>
Find an entry in 
<B>group</B>

with the given name.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
On Windows, always raise 
<B>Not_found</B>

.
<P>
<P>
<P>
<I>val getpwuid </I>

: 
<B>int -&gt; passwd_entry</B>

<P>
Find an entry in 
<B>passwd</B>

with the given user id.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
On Windows, always raise 
<B>Not_found</B>

.
<P>
<P>
<P>
<I>val getgrgid </I>

: 
<B>int -&gt; group_entry</B>

<P>
Find an entry in 
<B>group</B>

with the given group id.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
On Windows, always raise 
<B>Not_found</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAZ">&nbsp;</A>
<H3>Internet addresses</H3>

<P>
<P>

<I>type inet_addr </I>

<P>
<P>
The abstract type of Internet addresses.
<P>
<P>
<P>
<I>val inet_addr_of_string </I>

: 
<B>string -&gt; inet_addr</B>

<P>
Conversion from the printable representation of an Internet
address to its internal representation.  The argument string
consists of 4 numbers separated by periods (
<B>XXX.YYY.ZZZ.TTT</B>

)
for IPv4 addresses, and up to 8 numbers separated by colons
for IPv6 addresses.
<P>
<P>
<B>Raises Failure</B>

when given a string that does not match these formats.
<P>
<P>
<P>
<I>val string_of_inet_addr </I>

: 
<B>inet_addr -&gt; string</B>

<P>
Return the printable representation of the given Internet address.
See 
<B>Unix.inet_addr_of_string</B>

for a description of the
printable representation.
<P>
<P>
<P>
<I>val inet_addr_any </I>

: 
<B>inet_addr</B>

<P>
A special IPv4 address, for use only with 
<B>bind</B>

, representing
all the Internet addresses that the host machine possesses.
<P>
<P>
<P>
<I>val inet_addr_loopback </I>

: 
<B>inet_addr</B>

<P>
A special IPv4 address representing the host machine (
<B>127.0.0.1</B>

).
<P>
<P>
<P>
<I>val inet6_addr_any </I>

: 
<B>inet_addr</B>

<P>
A special IPv6 address, for use only with 
<B>bind</B>

, representing
all the Internet addresses that the host machine possesses.
<P>
<P>
<P>
<I>val inet6_addr_loopback </I>

: 
<B>inet_addr</B>

<P>
A special IPv6 address representing the host machine (
<B>::1</B>

).
<P>
<P>
<P>
<P>

<A NAME="lbBA">&nbsp;</A>
<H3>Sockets</H3>

<P>
<P>

<I>type socket_domain </I>

=
<BR>&nbsp;|&nbsp;PF_UNIX&nbsp;&nbsp;(*&nbsp;Unix&nbsp;domain
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;PF_INET&nbsp;&nbsp;(*&nbsp;Internet&nbsp;domain&nbsp;(IPv4)
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;PF_INET6&nbsp;&nbsp;(*&nbsp;Internet&nbsp;domain&nbsp;(IPv6)
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The type of socket domains.  Not all platforms support
IPv6 sockets (type 
<B>PF_INET6</B>

).  Windows does not support
<B>PF_UNIX</B>

.
<P>
<P>
<I>type socket_type </I>

=
<BR>&nbsp;|&nbsp;SOCK_STREAM&nbsp;&nbsp;(*&nbsp;Stream&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SOCK_DGRAM&nbsp;&nbsp;(*&nbsp;Datagram&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SOCK_RAW&nbsp;&nbsp;(*&nbsp;Raw&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SOCK_SEQPACKET&nbsp;&nbsp;(*&nbsp;Sequenced&nbsp;packets&nbsp;socket
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The type of socket kinds, specifying the semantics of
communications.  
<B>SOCK_SEQPACKET</B>

is included for completeness,
but is rarely supported by the OS, and needs system calls that
are not available in this library.
<P>
<P>
<I>type sockaddr </I>

=
<BR>&nbsp;|&nbsp;ADDR_UNIX
<B>of </B>

<B>string</B>

<BR>&nbsp;|&nbsp;ADDR_INET
<B>of </B>

<B>inet_addr * int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;The&nbsp;type&nbsp;of&nbsp;socket&nbsp;addresses.&nbsp;
<B>ADDR_UNIX name</B>

is a socket
address in the Unix domain; 
<B>name</B>

is a file name in the file
system. 
<B>ADDR_INET(addr,port)</B>

is a socket address in the Internet
domain; 
<B>addr</B>

is the Internet address of the machine, and
<B>port</B>

is the port number.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val socket </I>

: 
<B>?cloexec:bool -&gt;</B>

<B>socket_domain -&gt; socket_type -&gt; int -&gt; file_descr</B>

<P>
Create a new socket in the given domain, and with the
given kind. The third argument is the protocol type; 0 selects
the default protocol for that kind of sockets.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val domain_of_sockaddr </I>

: 
<B>sockaddr -&gt; socket_domain</B>

<P>
Return the socket domain adequate for the given socket address.
<P>
<P>
<P>
<I>val socketpair </I>

: 
<B>?cloexec:bool -&gt;</B>

<B>socket_domain -&gt;</B>

<B>socket_type -&gt; int -&gt; file_descr * file_descr</B>

<P>
Create a pair of unnamed sockets, connected together.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val accept </I>

: 
<B>?cloexec:bool -&gt; file_descr -&gt; file_descr * sockaddr</B>

<P>
Accept connections on the given socket. The returned descriptor
is a socket connected to the client; the returned address is
the address of the connecting client.
See 
<B>Unix.set_close_on_exec</B>

for documentation on the 
<B>cloexec</B>

optional argument.
<P>
<P>
<P>
<I>val bind </I>

: 
<B>file_descr -&gt; sockaddr -&gt; unit</B>

<P>
Bind a socket to an address.
<P>
<P>
<P>
<I>val connect </I>

: 
<B>file_descr -&gt; sockaddr -&gt; unit</B>

<P>
Connect a socket to an address.
<P>
<P>
<P>
<I>val listen </I>

: 
<B>file_descr -&gt; int -&gt; unit</B>

<P>
Set up a socket for receiving connection requests. The integer
argument is the maximal number of pending requests.
<P>
<P>
<I>type shutdown_command </I>

=
<BR>&nbsp;|&nbsp;SHUTDOWN_RECEIVE&nbsp;&nbsp;(*&nbsp;Close&nbsp;for&nbsp;receiving
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SHUTDOWN_SEND&nbsp;&nbsp;(*&nbsp;Close&nbsp;for&nbsp;sending
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SHUTDOWN_ALL&nbsp;&nbsp;(*&nbsp;Close&nbsp;both
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The type of commands for 
<B>shutdown</B>

.
<P>
<P>
<P>
<I>val shutdown </I>

: 
<B>file_descr -&gt; shutdown_command -&gt; unit</B>

<P>
Shutdown a socket connection. 
<B>SHUTDOWN_SEND</B>

as second argument
causes reads on the other end of the connection to return
an end-of-file condition.
<B>SHUTDOWN_RECEIVE</B>

causes writes on the other end of the connection
to return a closed pipe condition (
<B>SIGPIPE</B>

signal).
<P>
<P>
<P>
<I>val getsockname </I>

: 
<B>file_descr -&gt; sockaddr</B>

<P>
Return the address of the given socket.
<P>
<P>
<P>
<I>val getpeername </I>

: 
<B>file_descr -&gt; sockaddr</B>

<P>
Return the address of the host connected to the given socket.
<P>
<P>
<I>type msg_flag </I>

=
<BR>&nbsp;|&nbsp;MSG_OOB
<BR>&nbsp;|&nbsp;MSG_DONTROUTE
<BR>&nbsp;|&nbsp;MSG_PEEK&nbsp;&nbsp;(*&nbsp;The&nbsp;flags&nbsp;for&nbsp;
<B>Unix.recv</B>

,  
<B>Unix.recvfrom</B>

,
<B>Unix.send</B>

and 
<B>Unix.sendto</B>

.
<BR>&nbsp;*)
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val recv </I>

: 
<B>file_descr -&gt; bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; int</B>

<P>
Receive data from a connected socket.
<P>
<P>
<P>
<I>val recvfrom </I>

: 
<B>file_descr -&gt;</B>

<B>bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; int * sockaddr</B>

<P>
Receive data from an unconnected socket.
<P>
<P>
<P>
<I>val send </I>

: 
<B>file_descr -&gt; bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; int</B>

<P>
Send data over a connected socket.
<P>
<P>
<P>
<I>val send_substring </I>

: 
<B>file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int</B>

<P>
Same as 
<B>send</B>

, but take the data from a string instead of a byte
sequence.
<P>
<P>
<B>Since</B>

4.02.0
<P>
<P>
<P>
<I>val sendto </I>

: 
<B>file_descr -&gt;</B>

<B>bytes -&gt; int -&gt; int -&gt; msg_flag list -&gt; sockaddr -&gt; int</B>

<P>
Send data over an unconnected socket.
<P>
<P>
<P>
<I>val sendto_substring </I>

: 
<B>file_descr -&gt;</B>

<B>string -&gt; int -&gt; int -&gt; msg_flag list -&gt; sockaddr -&gt; int</B>

<P>
Same as 
<B>sendto</B>

, but take the data from a string instead of a
byte sequence.
<P>
<P>
<B>Since</B>

4.02.0
<P>
<P>
<P>
<P>

<A NAME="lbBB">&nbsp;</A>
<H3>Socket options</H3>

<P>
<P>

<I>type socket_bool_option </I>

=
<BR>&nbsp;|&nbsp;SO_DEBUG&nbsp;&nbsp;(*&nbsp;Record&nbsp;debugging&nbsp;information
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_BROADCAST&nbsp;&nbsp;(*&nbsp;Permit&nbsp;sending&nbsp;of&nbsp;broadcast&nbsp;messages
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_REUSEADDR&nbsp;&nbsp;(*&nbsp;Allow&nbsp;reuse&nbsp;of&nbsp;local&nbsp;addresses&nbsp;for&nbsp;bind
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_KEEPALIVE&nbsp;&nbsp;(*&nbsp;Keep&nbsp;connection&nbsp;active
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_DONTROUTE&nbsp;&nbsp;(*&nbsp;Bypass&nbsp;the&nbsp;standard&nbsp;routing&nbsp;algorithms
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_OOBINLINE&nbsp;&nbsp;(*&nbsp;Leave&nbsp;out-of-band&nbsp;data&nbsp;in&nbsp;line
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_ACCEPTCONN&nbsp;&nbsp;(*&nbsp;Report&nbsp;whether&nbsp;socket&nbsp;listening&nbsp;is&nbsp;enabled
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;TCP_NODELAY&nbsp;&nbsp;(*&nbsp;Control&nbsp;the&nbsp;Nagle&nbsp;algorithm&nbsp;for&nbsp;TCP&nbsp;sockets
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;IPV6_ONLY&nbsp;&nbsp;(*&nbsp;Forbid&nbsp;binding&nbsp;an&nbsp;IPv6&nbsp;socket&nbsp;to&nbsp;an&nbsp;IPv4&nbsp;address
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The socket options that can be consulted with 
<B>Unix.getsockopt</B>

and modified with 
<B>Unix.setsockopt</B>

.  These options have a boolean
(
<B>true</B>

/
<B>false</B>

) value.
<P>
<P>
<I>type socket_int_option </I>

=
<BR>&nbsp;|&nbsp;SO_SNDBUF&nbsp;&nbsp;(*&nbsp;Size&nbsp;of&nbsp;send&nbsp;buffer
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_RCVBUF&nbsp;&nbsp;(*&nbsp;Size&nbsp;of&nbsp;received&nbsp;buffer
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_ERROR&nbsp;&nbsp;(*&nbsp;Deprecated.&nbsp;&nbsp;Use&nbsp;
<B>Unix.getsockopt_error</B>

instead.
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_TYPE&nbsp;&nbsp;(*&nbsp;Report&nbsp;the&nbsp;socket&nbsp;type
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_RCVLOWAT&nbsp;&nbsp;(*&nbsp;Minimum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;process&nbsp;for&nbsp;input&nbsp;operations
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_SNDLOWAT&nbsp;&nbsp;(*&nbsp;Minimum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;process&nbsp;for&nbsp;output
operations
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The socket options that can be consulted with 
<B>Unix.getsockopt_int</B>

and modified with 
<B>Unix.setsockopt_int</B>

.  These options have an
integer value.
<P>
<P>
<I>type socket_optint_option </I>

=
<BR>&nbsp;|&nbsp;SO_LINGER&nbsp;&nbsp;(*&nbsp;Whether&nbsp;to&nbsp;linger&nbsp;on&nbsp;closed&nbsp;connections
that have data present, and for how long
(in seconds)
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The socket options that can be consulted with 
<B>Unix.getsockopt_optint</B>

and modified with 
<B>Unix.setsockopt_optint</B>

.  These options have a
value of type 
<B>int option</B>

, with 
<B>None</B>

meaning ``disabled''.
<P>
<P>
<I>type socket_float_option </I>

=
<BR>&nbsp;|&nbsp;SO_RCVTIMEO&nbsp;&nbsp;(*&nbsp;Timeout&nbsp;for&nbsp;input&nbsp;operations
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;SO_SNDTIMEO&nbsp;&nbsp;(*&nbsp;Timeout&nbsp;for&nbsp;output&nbsp;operations
<BR>&nbsp;*)
<BR>&nbsp;
<P>
The socket options that can be consulted with 
<B>Unix.getsockopt_float</B>

and modified with 
<B>Unix.setsockopt_float</B>

.  These options have a
floating-point value representing a time in seconds.
The value 0 means infinite timeout.
<P>
<P>
<P>
<I>val getsockopt </I>

: 
<B>file_descr -&gt; socket_bool_option -&gt; bool</B>

<P>
Return the current status of a boolean-valued option
in the given socket.
<P>
<P>
<P>
<I>val setsockopt </I>

: 
<B>file_descr -&gt; socket_bool_option -&gt; bool -&gt; unit</B>

<P>
Set or clear a boolean-valued option in the given socket.
<P>
<P>
<P>
<I>val getsockopt_int </I>

: 
<B>file_descr -&gt; socket_int_option -&gt; int</B>

<P>
Same as 
<B>Unix.getsockopt</B>

for an integer-valued socket option.
<P>
<P>
<P>
<I>val setsockopt_int </I>

: 
<B>file_descr -&gt; socket_int_option -&gt; int -&gt; unit</B>

<P>
Same as 
<B>Unix.setsockopt</B>

for an integer-valued socket option.
<P>
<P>
<P>
<I>val getsockopt_optint </I>

: 
<B>file_descr -&gt; socket_optint_option -&gt; int option</B>

<P>
Same as 
<B>Unix.getsockopt</B>

for a socket option whose value is an
<B>int option</B>

.
<P>
<P>
<P>
<I>val setsockopt_optint </I>

: 
<B>file_descr -&gt; socket_optint_option -&gt; int option -&gt; unit</B>

<P>
Same as 
<B>Unix.setsockopt</B>

for a socket option whose value is an
<B>int option</B>

.
<P>
<P>
<P>
<I>val getsockopt_float </I>

: 
<B>file_descr -&gt; socket_float_option -&gt; float</B>

<P>
Same as 
<B>Unix.getsockopt</B>

for a socket option whose value is a
floating-point number.
<P>
<P>
<P>
<I>val setsockopt_float </I>

: 
<B>file_descr -&gt; socket_float_option -&gt; float -&gt; unit</B>

<P>
Same as 
<B>Unix.setsockopt</B>

for a socket option whose value is a
floating-point number.
<P>
<P>
<P>
<I>val getsockopt_error </I>

: 
<B>file_descr -&gt; error option</B>

<P>
Return the error condition associated with the given socket,
and clear it.
<P>
<P>
<P>
<P>

<A NAME="lbBC">&nbsp;</A>
<H3>High-level network connection functions</H3>

<P>
<P>

<P>
<I>val open_connection </I>

: 
<B>sockaddr -&gt; in_channel * out_channel</B>

<P>
Connect to a server at the given address.
Return a pair of buffered channels connected to the server.
Remember to call 
<B>flush</B>

on the output channel at the right
times to ensure correct synchronization.
<P>
<P>
<P>
<I>val shutdown_connection </I>

: 
<B>in_channel -&gt; unit</B>

<P>
``Shut down'' a connection established with 
<B>Unix.open_connection</B>

;
that is, transmit an end-of-file condition to the server reading
on the other side of the connection. This does not fully close the
file descriptor associated with the channel, which you must remember
to free via 
<B>close_in</B>

.
<P>
<P>
<P>
<I>val establish_server </I>

: 
<B>(in_channel -&gt; out_channel -&gt; unit) -&gt; sockaddr -&gt; unit</B>

<P>
Establish a server on the given address.
The function given as first argument is called for each connection
with two buffered channels connected to the client. A new process
is created for each connection. The function 
<B>Unix.establish_server</B>

never returns normally.
<P>
On Windows, it is not implemented.  Use threads.
<P>
<P>
<P>
<P>

<A NAME="lbBD">&nbsp;</A>
<H3>Host and protocol databases</H3>

<P>
<P>

<I>type host_entry </I>

= {
<BR>&nbsp;h_name&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;h_aliases&nbsp;:&nbsp;
<B>string array</B>

;
<BR>&nbsp;h_addrtype&nbsp;:&nbsp;
<B>socket_domain</B>

;
<BR>&nbsp;h_addr_list&nbsp;:&nbsp;
<B>inet_addr array</B>

;
<BR>&nbsp;}
<P>
<P>
Structure of entries in the 
<B>hosts</B>

database.
<P>
<P>
<I>type protocol_entry </I>

= {
<BR>&nbsp;p_name&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;p_aliases&nbsp;:&nbsp;
<B>string array</B>

;
<BR>&nbsp;p_proto&nbsp;:&nbsp;
<B>int</B>

;
<BR>&nbsp;}
<P>
<P>
Structure of entries in the 
<B>protocols</B>

database.
<P>
<P>
<I>type service_entry </I>

= {
<BR>&nbsp;s_name&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;s_aliases&nbsp;:&nbsp;
<B>string array</B>

;
<BR>&nbsp;s_port&nbsp;:&nbsp;
<B>int</B>

;
<BR>&nbsp;s_proto&nbsp;:&nbsp;
<B>string</B>

;
<BR>&nbsp;}
<P>
<P>
Structure of entries in the 
<B>services</B>

database.
<P>
<P>
<P>
<I>val gethostname </I>

: 
<B>unit -&gt; string</B>

<P>
Return the name of the local host.
<P>
<P>
<P>
<I>val gethostbyname </I>

: 
<B>string -&gt; host_entry</B>

<P>
Find an entry in 
<B>hosts</B>

with the given name.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<P>
<I>val gethostbyaddr </I>

: 
<B>inet_addr -&gt; host_entry</B>

<P>
Find an entry in 
<B>hosts</B>

with the given address.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<P>
<I>val getprotobyname </I>

: 
<B>string -&gt; protocol_entry</B>

<P>
Find an entry in 
<B>protocols</B>

with the given name.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<P>
<I>val getprotobynumber </I>

: 
<B>int -&gt; protocol_entry</B>

<P>
Find an entry in 
<B>protocols</B>

with the given protocol number.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<P>
<I>val getservbyname </I>

: 
<B>string -&gt; string -&gt; service_entry</B>

<P>
Find an entry in 
<B>services</B>

with the given name.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<P>
<I>val getservbyport </I>

: 
<B>int -&gt; string -&gt; service_entry</B>

<P>
Find an entry in 
<B>services</B>

with the given service number.
<P>
<P>
<B>Raises Not_found</B>

if no such entry exist.
<P>
<P>
<I>type addr_info </I>

= {
<BR>&nbsp;ai_family&nbsp;:&nbsp;
<B>socket_domain</B>

;  (* Socket domain
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;ai_socktype&nbsp;:&nbsp;
<B>socket_type</B>

;  (* Socket type
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;ai_protocol&nbsp;:&nbsp;
<B>int</B>

;  (* Socket protocol number
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;ai_addr&nbsp;:&nbsp;
<B>sockaddr</B>

;  (* Address
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;ai_canonname&nbsp;:&nbsp;
<B>string</B>

;  (* Canonical host name
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
Address information returned by 
<B>Unix.getaddrinfo</B>

.
<P>
<P>
<I>type getaddrinfo_option </I>

=
<BR>&nbsp;|&nbsp;AI_FAMILY
<B>of </B>

<B>socket_domain</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;Impose&nbsp;the&nbsp;given&nbsp;socket&nbsp;domain
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;AI_SOCKTYPE
<B>of </B>

<B>socket_type</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;Impose&nbsp;the&nbsp;given&nbsp;socket&nbsp;type
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;AI_PROTOCOL
<B>of </B>

<B>int</B>

<I>  </I>

<BR>&nbsp;&nbsp;(*&nbsp;Impose&nbsp;the&nbsp;given&nbsp;protocol
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;AI_NUMERICHOST&nbsp;&nbsp;(*&nbsp;Do&nbsp;not&nbsp;call&nbsp;name&nbsp;resolver,
expect numeric IP address
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;AI_CANONNAME&nbsp;&nbsp;(*&nbsp;Fill&nbsp;the&nbsp;
<B>ai_canonname</B>

field
of the result
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;AI_PASSIVE&nbsp;&nbsp;(*&nbsp;Set&nbsp;address&nbsp;to&nbsp;``any''&nbsp;address
for use with 
<B>Unix.bind</B>

<P>
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Options to 
<B>Unix.getaddrinfo</B>

.
<P>
<P>
<P>
<I>val getaddrinfo </I>

: 
<B>string -&gt; string -&gt; getaddrinfo_option list -&gt; addr_info list</B>

<P>
<P>
<B>getaddrinfo host service opts</B>

returns a list of 
<B>Unix.addr_info</B>

records describing socket parameters and addresses suitable for
communicating with the given host and service.  The empty list is
returned if the host or service names are unknown, or the constraints
expressed in 
<B>opts</B>

cannot be satisfied.
<P>
<P>
<B>host</B>

is either a host name or the string representation of an IP
address.  
<B>host</B>

can be given as the empty string; in this case,
the ``any'' address or the ``loopback'' address are used,
depending whether 
<B>opts</B>

contains 
<B>AI_PASSIVE</B>

.
<B>service</B>

is either a service name or the string representation of
a port number.  
<B>service</B>

can be given as the empty string;
in this case, the port field of the returned addresses is set to 0.
<B>opts</B>

is a possibly empty list of options that allows the caller
to force a particular socket domain (e.g. IPv6 only or IPv4 only)
or a particular socket type (e.g. TCP only or UDP only).
<P>
<P>
<I>type name_info </I>

= {
<BR>&nbsp;ni_hostname&nbsp;:&nbsp;
<B>string</B>

;  (* Name or IP address of host
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;ni_service&nbsp;:&nbsp;
<B>string</B>

;  (* Name of service or port number
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
Host and service information returned by 
<B>Unix.getnameinfo</B>

.
<P>
<P>
<I>type getnameinfo_option </I>

=
<BR>&nbsp;|&nbsp;NI_NOFQDN&nbsp;&nbsp;(*&nbsp;Do&nbsp;not&nbsp;qualify&nbsp;local&nbsp;host&nbsp;names
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;NI_NUMERICHOST&nbsp;&nbsp;(*&nbsp;Always&nbsp;return&nbsp;host&nbsp;as&nbsp;IP&nbsp;address
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;NI_NAMEREQD&nbsp;&nbsp;(*&nbsp;Fail&nbsp;if&nbsp;host&nbsp;name&nbsp;cannot&nbsp;be&nbsp;determined
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;NI_NUMERICSERV&nbsp;&nbsp;(*&nbsp;Always&nbsp;return&nbsp;service&nbsp;as&nbsp;port&nbsp;number
<BR>&nbsp;*)
<BR>&nbsp;|&nbsp;NI_DGRAM&nbsp;&nbsp;(*&nbsp;Consider&nbsp;the&nbsp;service&nbsp;as&nbsp;UDP-based
instead of the default TCP
<BR>&nbsp;*)
<BR>&nbsp;
<P>
Options to 
<B>Unix.getnameinfo</B>

.
<P>
<P>
<P>
<I>val getnameinfo </I>

: 
<B>sockaddr -&gt; getnameinfo_option list -&gt; name_info</B>

<P>
<P>
<B>getnameinfo addr opts</B>

returns the host name and service name
corresponding to the socket address 
<B>addr</B>

.  
<B>opts</B>

is a possibly
empty list of options that governs how these names are obtained.
<P>
<P>
<B>Raises Not_found</B>

if an error occurs.
<P>
<P>
<P>
<P>

<A NAME="lbBE">&nbsp;</A>
<H3>Terminal interface</H3>

<P>
<P>

<P>
<P>

The following functions implement the POSIX standard terminal
interface. They provide control over asynchronous communication ports
and pseudo-terminals. Refer to the 
<B>termios</B>

man page for a
complete description.
<P>

<I>type terminal_io </I>

= {
<P>
<B>mutable </B>

c_ignbrk : 
<B>bool</B>

;  (* Ignore the break condition.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_brkint : 
<B>bool</B>

;  (* Signal interrupt on break condition.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_ignpar : 
<B>bool</B>

;  (* Ignore characters with parity errors.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_parmrk : 
<B>bool</B>

;  (* Mark parity errors.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_inpck : 
<B>bool</B>

;  (* Enable parity check on input.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_istrip : 
<B>bool</B>

;  (* Strip 8th bit on input characters.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_inlcr : 
<B>bool</B>

;  (* Map NL to CR on input.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_igncr : 
<B>bool</B>

;  (* Ignore CR on input.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_icrnl : 
<B>bool</B>

;  (* Map CR to NL on input.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_ixon : 
<B>bool</B>

;  (* Recognize XON/XOFF characters on input.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_ixoff : 
<B>bool</B>

;  (* Emit XON/XOFF chars to control input flow.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_opost : 
<B>bool</B>

;  (* Enable output processing.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_obaud : 
<B>int</B>

;  (* Output baud rate (0 means close connection).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_ibaud : 
<B>int</B>

;  (* Input baud rate.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_csize : 
<B>int</B>

;  (* Number of bits per character (5-8).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_cstopb : 
<B>int</B>

;  (* Number of stop bits (1-2).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_cread : 
<B>bool</B>

;  (* Reception is enabled.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_parenb : 
<B>bool</B>

;  (* Enable parity generation and detection.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_parodd : 
<B>bool</B>

;  (* Specify odd parity instead of even.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_hupcl : 
<B>bool</B>

;  (* Hang up on last close.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_clocal : 
<B>bool</B>

;  (* Ignore modem status lines.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_isig : 
<B>bool</B>

;  (* Generate signal on INTR, QUIT, SUSP.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_icanon : 
<B>bool</B>

;  (* Enable canonical processing
(line buffering and editing)
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_noflsh : 
<B>bool</B>

;  (* Disable flush after INTR, QUIT, SUSP.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_echo : 
<B>bool</B>

;  (* Echo input characters.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_echoe : 
<B>bool</B>

;  (* Echo ERASE (to erase previous character).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_echok : 
<B>bool</B>

;  (* Echo KILL (to erase the current line).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_echonl : 
<B>bool</B>

;  (* Echo NL even if c_echo is not set.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vintr : 
<B>char</B>

;  (* Interrupt character (usually ctrl-C).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vquit : 
<B>char</B>

;  (* Quit character (usually ctrl-\).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_verase : 
<B>char</B>

;  (* Erase character (usually DEL or ctrl-H).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vkill : 
<B>char</B>

;  (* Kill line character (usually ctrl-U).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_veof : 
<B>char</B>

;  (* End-of-file character (usually ctrl-D).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_veol : 
<B>char</B>

;  (* Alternate end-of-line char. (usually none).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vmin : 
<B>int</B>

;  (* Minimum number of characters to read
before the read request is satisfied.
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vtime : 
<B>int</B>

;  (* Maximum read wait (in 0.1s units).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vstart : 
<B>char</B>

;  (* Start character (usually ctrl-Q).
<BR>&nbsp;*)&nbsp;
<P>
<B>mutable </B>

c_vstop : 
<B>char</B>

;  (* Stop character (usually ctrl-S).
<BR>&nbsp;*)&nbsp;
<BR>&nbsp;}
<P>
<P>
<P>
<P>
<P>
<I>val tcgetattr </I>

: 
<B>file_descr -&gt; terminal_io</B>

<P>
Return the status of the terminal referred to by the given
file descriptor.
On Windows, not implemented.
<P>
<P>
<I>type setattr_when </I>

=
<BR>&nbsp;|&nbsp;TCSANOW
<BR>&nbsp;|&nbsp;TCSADRAIN
<BR>&nbsp;|&nbsp;TCSAFLUSH
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val tcsetattr </I>

: 
<B>file_descr -&gt; setattr_when -&gt; terminal_io -&gt; unit</B>

<P>
Set the status of the terminal referred to by the given
file descriptor. The second argument indicates when the
status change takes place: immediately (
<B>TCSANOW</B>

),
when all pending output has been transmitted (
<B>TCSADRAIN</B>

),
or after flushing all input that has been received but not
read (
<B>TCSAFLUSH</B>

). 
<B>TCSADRAIN</B>

is recommended when changing
the output parameters; 
<B>TCSAFLUSH</B>

, when changing the input
parameters.
<P>
On Windows, not implemented.
<P>
<P>
<P>
<I>val tcsendbreak </I>

: 
<B>file_descr -&gt; int -&gt; unit</B>

<P>
Send a break condition on the given file descriptor.
The second argument is the duration of the break, in 0.1s units;
0 means standard duration (0.25s).
<P>
On Windows, not implemented.
<P>
<P>
<P>
<I>val tcdrain </I>

: 
<B>file_descr -&gt; unit</B>

<P>
Waits until all output written on the given file descriptor
has been transmitted.
<P>
On Windows, not implemented.
<P>
<P>
<I>type flush_queue </I>

=
<BR>&nbsp;|&nbsp;TCIFLUSH
<BR>&nbsp;|&nbsp;TCOFLUSH
<BR>&nbsp;|&nbsp;TCIOFLUSH
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val tcflush </I>

: 
<B>file_descr -&gt; flush_queue -&gt; unit</B>

<P>
Discard data written on the given file descriptor but not yet
transmitted, or data received but not yet read, depending on the
second argument: 
<B>TCIFLUSH</B>

flushes data received but not read,
<B>TCOFLUSH</B>

flushes data written but not transmitted, and
<B>TCIOFLUSH</B>

flushes both.
<P>
On Windows, not implemented.
<P>
<P>
<I>type flow_action </I>

=
<BR>&nbsp;|&nbsp;TCOOFF
<BR>&nbsp;|&nbsp;TCOON
<BR>&nbsp;|&nbsp;TCIOFF
<BR>&nbsp;|&nbsp;TCION
<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val tcflow </I>

: 
<B>file_descr -&gt; flow_action -&gt; unit</B>

<P>
Suspend or restart reception or transmission of data on
the given file descriptor, depending on the second argument:
<B>TCOOFF</B>

suspends output, 
<B>TCOON</B>

restarts output,
<B>TCIOFF</B>

transmits a STOP character to suspend input,
and 
<B>TCION</B>

transmits a START character to restart input.
<P>
On Windows, not implemented.
<P>
<P>
<P>
<I>val setsid </I>

: 
<B>unit -&gt; int</B>

<P>
Put the calling process in a new session and detach it from
its controlling terminal.
<P>
On Windows, not implemented.
<P>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">Module</A><DD>
<DT id="3"><A HREF="#lbAD">Documentation</A><DD>
<DL>
<DT id="4"><A HREF="#lbAE">Error report</A><DD>
<DT id="5"><A HREF="#lbAF">Access to the process environment</A><DD>
<DT id="6"><A HREF="#lbAG">Process handling</A><DD>
<DT id="7"><A HREF="#lbAH">Basic file input/output</A><DD>
<DT id="8"><A HREF="#lbAI">Interfacing with the standard input/output library</A><DD>
<DT id="9"><A HREF="#lbAJ">Seeking and truncating</A><DD>
<DT id="10"><A HREF="#lbAK">File status</A><DD>
<DT id="11"><A HREF="#lbAL">File operations on large files</A><DD>
<DT id="12"><A HREF="#lbAM">Mapping files into memory</A><DD>
<DT id="13"><A HREF="#lbAN">Operations on file names</A><DD>
<DT id="14"><A HREF="#lbAO">File permissions and ownership</A><DD>
<DT id="15"><A HREF="#lbAP">Operations on file descriptors</A><DD>
<DT id="16"><A HREF="#lbAQ">Directories</A><DD>
<DT id="17"><A HREF="#lbAR">Pipes and redirections</A><DD>
<DT id="18"><A HREF="#lbAS">High-level process and redirection management</A><DD>
<DT id="19"><A HREF="#lbAT">Symbolic links</A><DD>
<DT id="20"><A HREF="#lbAU">Polling</A><DD>
<DT id="21"><A HREF="#lbAV">Locking</A><DD>
<DT id="22"><A HREF="#lbAW">Signals</A><DD>
<DT id="23"><A HREF="#lbAX">Time functions</A><DD>
<DT id="24"><A HREF="#lbAY">User id, group id</A><DD>
<DT id="25"><A HREF="#lbAZ">Internet addresses</A><DD>
<DT id="26"><A HREF="#lbBA">Sockets</A><DD>
<DT id="27"><A HREF="#lbBB">Socket options</A><DD>
<DT id="28"><A HREF="#lbBC">High-level network connection functions</A><DD>
<DT id="29"><A HREF="#lbBD">Host and protocol databases</A><DD>
<DT id="30"><A HREF="#lbBE">Terminal interface</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:59 GMT, March 31, 2021
</BODY>
</HTML>
