
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Net::DBus::Test::MockIterator</TITLE>
</HEAD><BODY>
<H1>Net::DBus::Test::MockIterator</H1>
Section: User Contributed Perl Documentation (3pm)<BR>Updated: 2019-12-26<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>






<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Net::DBus::Test::MockIterator - Iterator over a mock message
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>



Creating a new message
<P>



<PRE>
  my $msg = new Net::DBus::Test::MockMessage
  my $iterator = $msg-&gt;iterator;

  $iterator-&gt;<A HREF="/cgi-bin/man/man2html?1+append_boolean">append_boolean</A>(1);
  $iterator-&gt;append_byte(123);

</PRE>


<P>

Reading from a message
<P>



<PRE>
  my $msg = ...get it from somewhere...
  my $iter = $msg-&gt;iterator();

  my $i = 0;
  while ($iter-&gt;has_next()) {
    $iter-&gt;next();
    $i++;
    if ($i == 1) {
       my $val = $iter-&gt;get_boolean();
    } elsif ($i == 2) {
       my $val = $iter-&gt;get_byte();
    }
  }

</PRE>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>



This module provides a ``mock'' counterpart to the Net::DBus::Binding::Iterator
object which is capable of iterating over mock message objects. Instances of this
module are not created directly, instead they are obtained via the <TT>&quot;iterator&quot;</TT>
method on the Net::DBus::Test::MockMessage module.
<A NAME="lbAE">&nbsp;</A>
<H2>METHODS</H2>



<DL COMPACT>
<DT id="1">$res = $iter-&gt;<B>has_next()</B><DD>




Determines if there are any more fields in the message
itertor to be read. Returns a positive value if there
are more fields, zero otherwise.
<DT id="2">$success = $iter-&gt;<B>next()</B><DD>




Skips the iterator onto the next field in the message.
Returns a positive value if the current field pointer
was successfully advanced, zero otherwise.
<DT id="3">my $val = $iter-&gt;<B>get_boolean()</B><DD>





<DT id="4">$iter-&gt;append_boolean($val);<DD>





Read or write a boolean value from/to the
message iterator
<DT id="5">my $val = $iter-&gt;<B>get_byte()</B><DD>





<DT id="6">$iter-&gt;append_byte($val);<DD>





Read or write a single byte value from/to the
message iterator.
<DT id="7">my $val = $iter-&gt;<B>get_string()</B><DD>





<DT id="8">$iter-&gt;append_string($val);<DD>





Read or write a <FONT SIZE="-1">UTF-8</FONT> string value from/to the
message iterator
<DT id="9">my $val = $iter-&gt;<B>get_object_path()</B><DD>





<DT id="10">$iter-&gt;append_object_path($val);<DD>





Read or write a <FONT SIZE="-1">UTF-8</FONT> string value, whose contents is
a valid object path, from/to the message iterator
<DT id="11">my $val = $iter-&gt;<B>get_signature()</B><DD>





<DT id="12">$iter-&gt;append_signature($val);<DD>





Read or write a <FONT SIZE="-1">UTF-8</FONT> string, whose contents is a
valid type signature, value from/to the message iterator
<DT id="13">my $val = $iter-&gt;<B>get_int16()</B><DD>





<DT id="14">$iter-&gt;append_int16($val);<DD>





Read or write a signed 16 bit value from/to the
message iterator
<DT id="15">my $val = $iter-&gt;<B>get_uint16()</B><DD>





<DT id="16">$iter-&gt;append_uint16($val);<DD>





Read or write an unsigned 16 bit value from/to the
message iterator
<DT id="17">my $val = $iter-&gt;<B>get_int32()</B><DD>





<DT id="18">$iter-&gt;append_int32($val);<DD>





Read or write a signed 32 bit value from/to the
message iterator
<DT id="19">my $val = $iter-&gt;<B>get_uint32()</B><DD>





<DT id="20">$iter-&gt;append_uint32($val);<DD>





Read or write an unsigned 32 bit value from/to the
message iterator
<DT id="21">my $val = $iter-&gt;<B>get_int64()</B><DD>





<DT id="22">$iter-&gt;append_int64($val);<DD>





Read or write a signed 64 bit value from/to the
message iterator. An error will be raised if this
build of Perl does not support 64 bit integers
<DT id="23">my $val = $iter-&gt;<B>get_uint64()</B><DD>





<DT id="24">$iter-&gt;append_uint64($val);<DD>





Read or write an unsigned 64 bit value from/to the
message iterator. An error will be raised if this
build of Perl does not support 64 bit integers
<DT id="25">my $val = $iter-&gt;<B>get_double()</B><DD>





<DT id="26">$iter-&gt;append_double($val);<DD>





Read or write a double precision floating point value
from/to the message iterator
<DT id="27">my $val = $iter-&gt;<B>get_unix_fd()</B><DD>





<DT id="28">$iter-&gt;append_unix_fd($val);<DD>





Read or write a unix_fd value from/to the
message iterator
<DT id="29">my $value = $iter-&gt;<B>get()</B><DD>





<DT id="30">my $value = $iter-&gt;get($type);<DD>





Get the current value pointed to by this iterator. If the optional
<TT>$type</TT> parameter is supplied, the wire type will be compared with
the desired type &amp; a warning output if their differ. The <TT>$type</TT>
value must be one of the <TT>&quot;Net::DBus::Binding::Message::TYPE*&quot;</TT>
constants.
<DT id="31">my $hashref = $iter-&gt;<B>get_dict()</B><DD>




If the iterator currently points to a dictionary value, unmarshalls
and returns the value as a hash reference.
<DT id="32">my $hashref = $iter-&gt;<B>get_array()</B><DD>




If the iterator currently points to an array value, unmarshalls
and returns the value as a array reference.
<DT id="33">my $hashref = $iter-&gt;<B>get_variant()</B><DD>




If the iterator currently points to a variant value, unmarshalls
and returns the value contained in the variant.
<DT id="34">my $hashref = $iter-&gt;<B>get_struct()</B><DD>




If the iterator currently points to an struct value, unmarshalls
and returns the value as a array reference. The values in the array
correspond to members of the struct.
<DT id="35">$iter-&gt;append($value)<DD>





<DT id="36">$iter-&gt;append($value, $type)<DD>





Appends a value to the message associated with this iterator. The
value is marshalled into wire format, according to the following
rules.


<P>


If the <TT>$value</TT> is an instance of Net::DBus::Binding::Value,
the embedded data type is used.


<P>


If the <TT>$type</TT> parameter is supplied, that is taken to represent
the data type. The type must be one of the <TT>&quot;Net::DBus::Binding::Message::TYPE_*&quot;</TT>
constants.


<P>


Otherwise, the data type is chosen to be a string, dict or array
according to the perl data types <FONT SIZE="-1">SCALAR, HASH</FONT> or <FONT SIZE="-1">ARRAY.</FONT>
<DT id="37">my $type = $iter-&gt;guess_type($value)<DD>




Make a best guess at the on the wire data type to use for
marshalling <TT>$value</TT>. If the value is a hash reference,
the dictionary type is returned; if the value is an array
reference the array type is returned; otherwise the string
type is returned.
<DT id="38">my $sig = $iter-&gt;format_signature($type)<DD>




Given a data type representation, construct a corresponding
signature string
<DT id="39">$iter-&gt;append_array($value, $type)<DD>




Append an array of values to the message. The <TT>$value</TT> parameter
must be an array reference, whose elements all have the same data
type specified by the <TT>$type</TT> parameter.
<DT id="40">$iter-&gt;append_struct($value, $type)<DD>




Append a struct to the message. The <TT>$value</TT> parameter
must be an array reference, whose elements correspond to
members of the structure. The <TT>$type</TT> parameter encodes
the type of each member of the struct.
<DT id="41">$iter-&gt;append_dict($value, $type)<DD>




Append a dictionary to the message. The <TT>$value</TT> parameter
must be an hash reference.The <TT>$type</TT> parameter encodes
the type of the key and value of the hash.
<DT id="42">$iter-&gt;append_variant($value)<DD>




Append a value to the message, encoded as a variant type. The
<TT>$value</TT> can be of any type, however, the variant will be
encoded as either a string, dictionary or array according to
the rules of the <TT>&quot;guess_type&quot;</TT> method.
<DT id="43">my $type = $iter-&gt;get_arg_type<DD>




Retrieves the type code of the value pointing to by this iterator.
The returned code will correspond to one of the constants
<TT>&quot;Net::DBus::Binding::Message::TYPE_*&quot;</TT>
<DT id="44">my $type = $iter-&gt;get_element_type<DD>




If the iterator points to an array, retrieves the type code of
array elements. The returned code will correspond to one of the
constants <TT>&quot;Net::DBus::Binding::Message::TYPE_*&quot;</TT>
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>BUGS</H2>



It doesn't completely replicate the <FONT SIZE="-1">API</FONT> of Net::DBus::Binding::Iterator,
merely enough to make the high level bindings work in a test scenario.
<A NAME="lbAG">&nbsp;</A>
<H2>AUTHOR</H2>



Daniel P. Berrange
<A NAME="lbAH">&nbsp;</A>
<H2>COPYRIGHT</H2>



Copyright (C) 2005-2009 Daniel P. Berrange
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>



Net::DBus::Test::MockMessage, Net::DBus::Binding::Iterator,
&lt;<A HREF="http://www.mockobjects.com/Faq.html">http://www.mockobjects.com/Faq.html</A>&gt;
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="45"><A HREF="#lbAB">NAME</A><DD>
<DT id="46"><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT id="47"><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT id="48"><A HREF="#lbAE">METHODS</A><DD>
<DT id="49"><A HREF="#lbAF">BUGS</A><DD>
<DT id="50"><A HREF="#lbAG">AUTHOR</A><DD>
<DT id="51"><A HREF="#lbAH">COPYRIGHT</A><DD>
<DT id="52"><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:49 GMT, March 31, 2021
</BODY>
</HTML>
