
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Stdlib.Bigarray</TITLE>
</HEAD><BODY>
<H1>Stdlib.Bigarray</H1>
Section: OCaml library (3o)<BR>Updated: 2020-01-30<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Stdlib.Bigarray - no description
<A NAME="lbAC">&nbsp;</A>
<H2>Module</H2>

Module   Stdlib.Bigarray
<A NAME="lbAD">&nbsp;</A>
<H2>Documentation</H2>

<P>
Module
<B>Bigarray</B>

<BR>&nbsp;:&nbsp;
<B>(module Stdlib__bigarray)</B>

<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>

<A NAME="lbAE">&nbsp;</A>
<H3>Element kinds</H3>

<P>
<P>

<P>
<P>

Bigarrays can contain elements of the following kinds:
<P>
-IEEE single precision (32 bits) floating-point numbers
(
<B>Bigarray.float32_elt</B>

),
<P>
-IEEE double precision (64 bits) floating-point numbers
(
<B>Bigarray.float64_elt</B>

),
<P>
-IEEE single precision (2 * 32 bits) floating-point complex numbers
(
<B>Bigarray.complex32_elt</B>

),
<P>
-IEEE double precision (2 * 64 bits) floating-point complex numbers
(
<B>Bigarray.complex64_elt</B>

),
<P>
-8-bit integers (signed or unsigned)
(
<B>Bigarray.int8_signed_elt</B>

or 
<B>Bigarray.int8_unsigned_elt</B>

),
<P>
-16-bit integers (signed or unsigned)
(
<B>Bigarray.int16_signed_elt</B>

or 
<B>Bigarray.int16_unsigned_elt</B>

),
<P>
-OCaml integers (signed, 31 bits on 32-bit architectures,
63 bits on 64-bit architectures) (
<B>Bigarray.int_elt</B>

),
<P>
-32-bit signed integers (
<B>Bigarray.int32_elt</B>

),
<P>
-64-bit signed integers (
<B>Bigarray.int64_elt</B>

),
<P>
-platform-native signed integers (32 bits on 32-bit architectures,
64 bits on 64-bit architectures) (
<B>Bigarray.nativeint_elt</B>

).
<P>
Each element kind is represented at the type level by one of the
<B>*_elt</B>

types defined below (defined with a single constructor instead
of abstract types for technical injectivity reasons).
<P>

<I>type float32_elt </I>

=
<BR>&nbsp;|&nbsp;Float32_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type float64_elt </I>

=
<BR>&nbsp;|&nbsp;Float64_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int8_signed_elt </I>

=
<BR>&nbsp;|&nbsp;Int8_signed_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int8_unsigned_elt </I>

=
<BR>&nbsp;|&nbsp;Int8_unsigned_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int16_signed_elt </I>

=
<BR>&nbsp;|&nbsp;Int16_signed_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int16_unsigned_elt </I>

=
<BR>&nbsp;|&nbsp;Int16_unsigned_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int32_elt </I>

=
<BR>&nbsp;|&nbsp;Int32_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int64_elt </I>

=
<BR>&nbsp;|&nbsp;Int64_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type int_elt </I>

=
<BR>&nbsp;|&nbsp;Int_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type nativeint_elt </I>

=
<BR>&nbsp;|&nbsp;Nativeint_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type complex32_elt </I>

=
<BR>&nbsp;|&nbsp;Complex32_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type complex64_elt </I>

=
<BR>&nbsp;|&nbsp;Complex64_elt
<BR>&nbsp;
<P>
<P>
<P>
<I>type </I>

<B>('a, 'b)</B>

<I>kind </I>

=
<BR>&nbsp;|&nbsp;Float32
<B>: </B>

<B>(float, float32_elt) kind</B>

<BR>&nbsp;|&nbsp;Float64
<B>: </B>

<B>(float, float64_elt) kind</B>

<BR>&nbsp;|&nbsp;Int8_signed
<B>: </B>

<B>(int, int8_signed_elt) kind</B>

<BR>&nbsp;|&nbsp;Int8_unsigned
<B>: </B>

<B>(int, int8_unsigned_elt) kind</B>

<BR>&nbsp;|&nbsp;Int16_signed
<B>: </B>

<B>(int, int16_signed_elt) kind</B>

<BR>&nbsp;|&nbsp;Int16_unsigned
<B>: </B>

<B>(int, int16_unsigned_elt) kind</B>

<BR>&nbsp;|&nbsp;Int32
<B>: </B>

<B>(int32, int32_elt) kind</B>

<BR>&nbsp;|&nbsp;Int64
<B>: </B>

<B>(int64, int64_elt) kind</B>

<BR>&nbsp;|&nbsp;Int
<B>: </B>

<B>(int, int_elt) kind</B>

<BR>&nbsp;|&nbsp;Nativeint
<B>: </B>

<B>(nativeint, nativeint_elt) kind</B>

<BR>&nbsp;|&nbsp;Complex32
<B>: </B>

<B>(Complex.t, complex32_elt) kind</B>

<BR>&nbsp;|&nbsp;Complex64
<B>: </B>

<B>(Complex.t, complex64_elt) kind</B>

<BR>&nbsp;|&nbsp;Char
<B>: </B>

<B>(char, int8_unsigned_elt) kind</B>

<BR>&nbsp;
<P>
To each element kind is associated an OCaml type, which is
the type of OCaml values that can be stored in the Bigarray
or read back from it.  This type is not necessarily the same
as the type of the array elements proper: for instance,
a Bigarray whose elements are of kind 
<B>float32_elt</B>

contains
32-bit single precision floats, but reading or writing one of
its elements from OCaml uses the OCaml type 
<B>float</B>

, which is
64-bit double precision floats.
<P>
The GADT type 
<B>('a, 'b) kind</B>

captures this association
of an OCaml type 
<B>'a</B>

for values read or written in the Bigarray,
and of an element kind 
<B>'b</B>

which represents the actual contents
of the Bigarray. Its constructors list all possible associations
of OCaml types with element kinds, and are re-exported below for
backward-compatibility reasons.
<P>
Using a generalized algebraic datatype (GADT) here allows writing
well-typed polymorphic functions whose return type depend on the
argument type, such as:
<P>
<P>
<B>let zero : type a b. (a, b) kind -&gt; a = function</B>



<B>| Float32 -&gt; 0.0 | Complex32 -&gt; Complex.zero</B>

<B>| Float64 -&gt; 0.0 | Complex64 -&gt; Complex.zero</B>

<B>| Int8_signed -&gt; 0 | Int8_unsigned -&gt; 0</B>

<B>| Int16_signed -&gt; 0 | Int16_unsigned -&gt; 0</B>

<B>| Int32 -&gt; 0l | Int64 -&gt; 0L</B>

<B>| Int -&gt; 0 | Nativeint -&gt; 0n</B>

<B>| Char -&gt; '\000'</B>

<B></B>

<P>
<P>
<P>
<I>val float32 </I>

: 
<B>(float, float32_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val float64 </I>

: 
<B>(float, float64_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val complex32 </I>

: 
<B>(Complex.t, complex32_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val complex64 </I>

: 
<B>(Complex.t, complex64_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int8_signed </I>

: 
<B>(int, int8_signed_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int8_unsigned </I>

: 
<B>(int, int8_unsigned_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int16_signed </I>

: 
<B>(int, int16_signed_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int16_unsigned </I>

: 
<B>(int, int16_unsigned_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int </I>

: 
<B>(int, int_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int32 </I>

: 
<B>(int32, int32_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val int64 </I>

: 
<B>(int64, int64_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val nativeint </I>

: 
<B>(nativeint, nativeint_elt) kind</B>

<P>
See 
<B>Bigarray.char</B>

.
<P>
<P>
<P>
<I>val char </I>

: 
<B>(char, int8_unsigned_elt) kind</B>

<P>
As shown by the types of the values above,
Bigarrays of kind 
<B>float32_elt</B>

and 
<B>float64_elt</B>

are
accessed using the OCaml type 
<B>float</B>

.  Bigarrays of complex kinds
<B>complex32_elt</B>

, 
<B>complex64_elt</B>

are accessed with the OCaml type
<B>Complex.t</B>

. Bigarrays of
integer kinds are accessed using the smallest OCaml integer
type large enough to represent the array elements:
<B>int</B>

for 8- and 16-bit integer Bigarrays, as well as OCaml-integer
Bigarrays; 
<B>int32</B>

for 32-bit integer Bigarrays; 
<B>int64</B>

for 64-bit integer Bigarrays; and 
<B>nativeint</B>

for
platform-native integer Bigarrays.  Finally, Bigarrays of
kind 
<B>int8_unsigned_elt</B>

can also be accessed as arrays of
characters instead of arrays of small integers, by using
the kind value 
<B>char</B>

instead of 
<B>int8_unsigned</B>

.
<P>
<P>
<P>
<I>val kind_size_in_bytes </I>

: 
<B>('a, 'b) kind -&gt; int</B>

<P>
<P>
<B>kind_size_in_bytes k</B>

is the number of bytes used to store
an element of type 
<B>k</B>

.
<P>
<P>
<B>Since</B>

4.03.0
<P>
<P>
<P>
<P>

<A NAME="lbAF">&nbsp;</A>
<H3>Array layouts</H3>

<P>
<P>

<I>type c_layout </I>

=
<BR>&nbsp;|&nbsp;C_layout_typ
<BR>&nbsp;
<P>
See 
<B>Bigarray.fortran_layout</B>

.
<P>
<P>
<I>type fortran_layout </I>

=
<BR>&nbsp;|&nbsp;Fortran_layout_typ
<BR>&nbsp;
<P>
To facilitate interoperability with existing C and Fortran code,
this library supports two different memory layouts for Bigarrays,
one compatible with the C conventions,
the other compatible with the Fortran conventions.
<P>
In the C-style layout, array indices start at 0, and
multi-dimensional arrays are laid out in row-major format.
That is, for a two-dimensional array, all elements of
row 0 are contiguous in memory, followed by all elements of
row 1, etc.  In other terms, the array elements at 
<B>(x,y)</B>

and 
<B>(x, y+1)</B>

are adjacent in memory.
<P>
In the Fortran-style layout, array indices start at 1, and
multi-dimensional arrays are laid out in column-major format.
That is, for a two-dimensional array, all elements of
column 0 are contiguous in memory, followed by all elements of
column 1, etc.  In other terms, the array elements at 
<B>(x,y)</B>

and 
<B>(x+1, y)</B>

are adjacent in memory.
<P>
Each layout style is identified at the type level by the
phantom types 
<B>Bigarray.c_layout</B>

and 
<B>Bigarray.fortran_layout</B>

respectively.
<P>
<P>
<P>
<P>

<A NAME="lbAG">&nbsp;</A>
<H3>Supported layouts</H3>

<P>
The GADT type 
<B>'a layout</B>

represents one of the two supported
memory layouts: C-style or Fortran-style. Its constructors are
re-exported as values below for backward-compatibility reasons.
<P>

<I>type </I>

<B>'a</B>

<I>layout </I>

=
<BR>&nbsp;|&nbsp;C_layout
<B>: </B>

<B>c_layout layout</B>

<BR>&nbsp;|&nbsp;Fortran_layout
<B>: </B>

<B>fortran_layout layout</B>

<BR>&nbsp;
<P>
<P>
<P>
<P>
<I>val c_layout </I>

: 
<B>c_layout layout</B>

<P>
<P>
<P>
<P>
<I>val fortran_layout </I>

: 
<B>fortran_layout layout</B>

<P>
<P>
<P>
<P>
<P>

<A NAME="lbAH">&nbsp;</A>
<H3>Generic arrays (of arbitrarily many dimensions)</H3>

<P>
<P>

<I>module Genarray : </I>

<B>sig  end</B>

<P>
<P>
<P>
<P>
<P>
<P>

<A NAME="lbAI">&nbsp;</A>
<H3>Zero-dimensional arrays</H3>

<P>
<P>

<I>module Array0 : </I>

<B>sig  end</B>

<P>
<P>
Zero-dimensional arrays. The 
<B>Array0</B>

structure provides operations
similar to those of 
<B>Bigarray.Genarray</B>

, but specialized to the case
of zero-dimensional arrays that only contain a single scalar value.
Statically knowing the number of dimensions of the array allows
faster operations, and more precise static type-checking.
<P>
<P>
<B>Since</B>

4.05.0
<P>
<P>
<P>
<P>

<A NAME="lbAJ">&nbsp;</A>
<H3>One-dimensional arrays</H3>

<P>
<P>

<I>module Array1 : </I>

<B>sig  end</B>

<P>
<P>
One-dimensional arrays. The 
<B>Array1</B>

structure provides operations
similar to those of
<B>Bigarray.Genarray</B>

, but specialized to the case of one-dimensional arrays.
(The 
<B>Bigarray.Array2</B>

and 
<B>Bigarray.Array3</B>

structures below provide operations
specialized for two- and three-dimensional arrays.)
Statically knowing the number of dimensions of the array allows
faster operations, and more precise static type-checking.
<P>
<P>
<P>
<P>

<A NAME="lbAK">&nbsp;</A>
<H3>Two-dimensional arrays</H3>

<P>
<P>

<I>module Array2 : </I>

<B>sig  end</B>

<P>
<P>
Two-dimensional arrays. The 
<B>Array2</B>

structure provides operations
similar to those of 
<B>Bigarray.Genarray</B>

, but specialized to the
case of two-dimensional arrays.
<P>
<P>
<P>
<P>

<A NAME="lbAL">&nbsp;</A>
<H3>Three-dimensional arrays</H3>

<P>
<P>

<I>module Array3 : </I>

<B>sig  end</B>

<P>
<P>
Three-dimensional arrays. The 
<B>Array3</B>

structure provides operations
similar to those of 
<B>Bigarray.Genarray</B>

, but specialized to the case
of three-dimensional arrays.
<P>
<P>
<P>
<P>

<A NAME="lbAM">&nbsp;</A>
<H3>Coercions between generic Bigarrays and fixed-dimension Bigarrays</H3>

<P>
<P>

<P>
<I>val genarray_of_array0 </I>

: 
<B>('a, 'b, 'c) Array0.t -&gt; ('a, 'b, 'c) Genarray.t</B>

<P>
Return the generic Bigarray corresponding to the given zero-dimensional
Bigarray.
<P>
<P>
<B>Since</B>

4.05.0
<P>
<P>
<P>
<I>val genarray_of_array1 </I>

: 
<B>('a, 'b, 'c) Array1.t -&gt; ('a, 'b, 'c) Genarray.t</B>

<P>
Return the generic Bigarray corresponding to the given one-dimensional
Bigarray.
<P>
<P>
<P>
<I>val genarray_of_array2 </I>

: 
<B>('a, 'b, 'c) Array2.t -&gt; ('a, 'b, 'c) Genarray.t</B>

<P>
Return the generic Bigarray corresponding to the given two-dimensional
Bigarray.
<P>
<P>
<P>
<I>val genarray_of_array3 </I>

: 
<B>('a, 'b, 'c) Array3.t -&gt; ('a, 'b, 'c) Genarray.t</B>

<P>
Return the generic Bigarray corresponding to the given three-dimensional
Bigarray.
<P>
<P>
<P>
<I>val array0_of_genarray </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array0.t</B>

<P>
Return the zero-dimensional Bigarray corresponding to the given
generic Bigarray.  Raise 
<B>Invalid_argument</B>

if the generic Bigarray
does not have exactly zero dimension.
<P>
<P>
<B>Since</B>

4.05.0
<P>
<P>
<P>
<I>val array1_of_genarray </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array1.t</B>

<P>
Return the one-dimensional Bigarray corresponding to the given
generic Bigarray.  Raise 
<B>Invalid_argument</B>

if the generic Bigarray
does not have exactly one dimension.
<P>
<P>
<P>
<I>val array2_of_genarray </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array2.t</B>

<P>
Return the two-dimensional Bigarray corresponding to the given
generic Bigarray.  Raise 
<B>Invalid_argument</B>

if the generic Bigarray
does not have exactly two dimensions.
<P>
<P>
<P>
<I>val array3_of_genarray </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array3.t</B>

<P>
Return the three-dimensional Bigarray corresponding to the given
generic Bigarray.  Raise 
<B>Invalid_argument</B>

if the generic Bigarray
does not have exactly three dimensions.
<P>
<P>
<P>
<P>

<A NAME="lbAN">&nbsp;</A>
<H3>Re-shaping Bigarrays</H3>

<P>
<P>

<P>
<I>val reshape </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt;</B>

<B>int array -&gt; ('a, 'b, 'c) Genarray.t</B>

<P>
<P>
<B>reshape b [|d1;...;dN|]</B>

converts the Bigarray 
<B>b</B>

to a
<B>N</B>

-dimensional array of dimensions 
<B>d1</B>

...
<B>dN</B>

.  The returned
array and the original array 
<B>b</B>

share their data
and have the same layout.  For instance, assuming that 
<B>b</B>

is a one-dimensional array of dimension 12, 
<B>reshape b [|3;4|]</B>

returns a two-dimensional array 
<B>b'</B>

of dimensions 3 and 4.
If 
<B>b</B>

has C layout, the element 
<B>(x,y)</B>

of 
<B>b'</B>

corresponds
to the element 
<B>x * 3 + y</B>

of 
<B>b</B>

.  If 
<B>b</B>

has Fortran layout,
the element 
<B>(x,y)</B>

of 
<B>b'</B>

corresponds to the element
<B>x + (y - 1) * 4</B>

of 
<B>b</B>

.
The returned Bigarray must have exactly the same number of
elements as the original Bigarray 
<B>b</B>

.  That is, the product
of the dimensions of 
<B>b</B>

must be equal to 
<B>i1 * ... * iN</B>

.
Otherwise, 
<B>Invalid_argument</B>

is raised.
<P>
<P>
<P>
<I>val reshape_0 </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array0.t</B>

<P>
Specialized version of 
<B>Bigarray.reshape</B>

for reshaping to
zero-dimensional arrays.
<P>
<P>
<B>Since</B>

4.05.0
<P>
<P>
<P>
<I>val reshape_1 </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt; int -&gt; ('a, 'b, 'c) Array1.t</B>

<P>
Specialized version of 
<B>Bigarray.reshape</B>

for reshaping to
one-dimensional arrays.
<P>
<P>
<P>
<I>val reshape_2 </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt;</B>

<B>int -&gt; int -&gt; ('a, 'b, 'c) Array2.t</B>

<P>
Specialized version of 
<B>Bigarray.reshape</B>

for reshaping to
two-dimensional arrays.
<P>
<P>
<P>
<I>val reshape_3 </I>

: 
<B>('a, 'b, 'c) Genarray.t -&gt;</B>

<B>int -&gt; int -&gt; int -&gt; ('a, 'b, 'c) Array3.t</B>

<P>
Specialized version of 
<B>Bigarray.reshape</B>

for reshaping to
three-dimensional arrays.
<P>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">Module</A><DD>
<DT id="3"><A HREF="#lbAD">Documentation</A><DD>
<DL>
<DT id="4"><A HREF="#lbAE">Element kinds</A><DD>
<DT id="5"><A HREF="#lbAF">Array layouts</A><DD>
<DT id="6"><A HREF="#lbAG">Supported layouts</A><DD>
<DT id="7"><A HREF="#lbAH">Generic arrays (of arbitrarily many dimensions)</A><DD>
<DT id="8"><A HREF="#lbAI">Zero-dimensional arrays</A><DD>
<DT id="9"><A HREF="#lbAJ">One-dimensional arrays</A><DD>
<DT id="10"><A HREF="#lbAK">Two-dimensional arrays</A><DD>
<DT id="11"><A HREF="#lbAL">Three-dimensional arrays</A><DD>
<DT id="12"><A HREF="#lbAM">Coercions between generic Bigarrays and fixed-dimension Bigarrays</A><DD>
<DT id="13"><A HREF="#lbAN">Re-shaping Bigarrays</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:57 GMT, March 31, 2021
</BODY>
</HTML>
