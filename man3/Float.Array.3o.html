
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Float.Array</TITLE>
</HEAD><BODY>
<H1>Float.Array</H1>
Section: OCaml library (3o)<BR>Updated: 2020-01-30<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Float.Array - no description
<A NAME="lbAC">&nbsp;</A>
<H2>Module</H2>

Module   Float.Array
<A NAME="lbAD">&nbsp;</A>
<H2>Documentation</H2>

<P>
Module
<B>Array</B>

<BR>&nbsp;:&nbsp;
<B>sig  end</B>

<P>
<P>
<P>
<P>
<P>
<P>
<P>
<I>type t </I>

= 
<B>floatarray</B>

<P>
<P>
The type of float arrays with packed representation.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val length </I>

: 
<B>t -&gt; int</B>

<P>
Return the length (number of elements) of the given floatarray.
<P>
<P>
<P>
<I>val get </I>

: 
<B>t -&gt; int -&gt; float</B>

<P>
<P>
<B>get a n</B>

returns the element number 
<B>n</B>

of floatarray 
<B>a</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n</B>

is outside the range 0 to
<B>(length a - 1)</B>

.
<P>
<P>
<P>
<I>val set </I>

: 
<B>t -&gt; int -&gt; float -&gt; unit</B>

<P>
<P>
<B>set a n x</B>

modifies floatarray 
<B>a</B>

in place, replacing element
number 
<B>n</B>

with 
<B>x</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n</B>

is outside the range 0 to
<B>(length a - 1)</B>

.
<P>
<P>
<P>
<I>val make </I>

: 
<B>int -&gt; float -&gt; t</B>

<P>
<P>
<B>make n x</B>

returns a fresh floatarray of length 
<B>n</B>

, initialized with 
<B>x</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n &lt; 0</B>

or 
<B>n &gt; Sys.max_floatarray_length</B>

.
<P>
<P>
<P>
<I>val create </I>

: 
<B>int -&gt; t</B>

<P>
<P>
<B>create n</B>

returns a fresh floatarray of length 
<B>n</B>

,
with uninitialized data.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n &lt; 0</B>

or 
<B>n &gt; Sys.max_floatarray_length</B>

.
<P>
<P>
<P>
<I>val init </I>

: 
<B>int -&gt; (int -&gt; float) -&gt; t</B>

<P>
<P>
<B>init n f</B>

returns a fresh floatarray of length 
<B>n</B>

,
with element number 
<B>i</B>

initialized to the result of 
<B>f i</B>

.
In other terms, 
<B>init n f</B>

tabulates the results of 
<B>f</B>

applied to the integers 
<B>0</B>

to 
<B>n-1</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>n &lt; 0</B>

or 
<B>n &gt; Sys.max_floatarray_length</B>

.
<P>
<P>
<P>
<I>val append </I>

: 
<B>t -&gt; t -&gt; t</B>

<P>
<P>
<B>append v1 v2</B>

returns a fresh floatarray containing the
concatenation of the floatarrays 
<B>v1</B>

and 
<B>v2</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if
<B>length v1 + length v2 &gt; Sys.max_floatarray_length</B>

.
<P>
<P>
<P>
<I>val concat </I>

: 
<B>t list -&gt; t</B>

<P>
Same as 
<B>Float.Array.append</B>

, but concatenates a list of floatarrays.
<P>
<P>
<P>
<I>val sub </I>

: 
<B>t -&gt; int -&gt; int -&gt; t</B>

<P>
<P>
<B>sub a start len</B>

returns a fresh floatarray of length 
<B>len</B>

,
containing the elements number 
<B>start</B>

to 
<B>start + len - 1</B>

of floatarray 
<B>a</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>start</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>a</B>

; that is, if
<B>start &lt; 0</B>

, or 
<B>len &lt; 0</B>

, or 
<B>start + len &gt; length a</B>

.
<P>
<P>
<P>
<I>val copy </I>

: 
<B>t -&gt; t</B>

<P>
<P>
<B>copy a</B>

returns a copy of 
<B>a</B>

, that is, a fresh floatarray
containing the same elements as 
<B>a</B>

.
<P>
<P>
<P>
<I>val fill </I>

: 
<B>t -&gt; int -&gt; int -&gt; float -&gt; unit</B>

<P>
<P>
<B>fill a ofs len x</B>

modifies the floatarray 
<B>a</B>

in place,
storing 
<B>x</B>

in elements number 
<B>ofs</B>

to 
<B>ofs + len - 1</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>ofs</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>a</B>

.
<P>
<P>
<P>
<I>val blit </I>

: 
<B>t -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit</B>

<P>
<P>
<B>blit v1 o1 v2 o2 len</B>

copies 
<B>len</B>

elements
from floatarray 
<B>v1</B>

, starting at element number 
<B>o1</B>

, to floatarray 
<B>v2</B>

,
starting at element number 
<B>o2</B>

. It works correctly even if
<B>v1</B>

and 
<B>v2</B>

are the same floatarray, and the source and
destination chunks overlap.
<P>
Raise 
<B>Invalid_argument</B>

if 
<B>o1</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>v1</B>

, or if 
<B>o2</B>

and 
<B>len</B>

do not
designate a valid subarray of 
<B>v2</B>

.
<P>
<P>
<P>
<I>val to_list </I>

: 
<B>t -&gt; float list</B>

<P>
<P>
<B>to_list a</B>

returns the list of all the elements of 
<B>a</B>

.
<P>
<P>
<P>
<I>val of_list </I>

: 
<B>float list -&gt; t</B>

<P>
<P>
<B>of_list l</B>

returns a fresh floatarray containing the elements
of 
<B>l</B>

.
<P>
Raise 
<B>Invalid_argument</B>

if the length of 
<B>l</B>

is greater than
<B>Sys.max_floatarray_length</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAE">&nbsp;</A>
<H3>Iterators</H3>

<P>
<P>

<P>
<I>val iter </I>

: 
<B>(float -&gt; unit) -&gt; t -&gt; unit</B>

<P>
<P>
<B>iter f a</B>

applies function 
<B>f</B>

in turn to all
the elements of 
<B>a</B>

.  It is equivalent to
<B>f a.(0); f a.(1); ...; f a.(length a - 1); ()</B>

.
<P>
<P>
<P>
<I>val iteri </I>

: 
<B>(int -&gt; float -&gt; unit) -&gt; t -&gt; unit</B>

<P>
Same as 
<B>Float.Array.iter</B>

, but the
function is applied with the index of the element as first argument,
and the element itself as second argument.
<P>
<P>
<P>
<I>val map </I>

: 
<B>(float -&gt; float) -&gt; t -&gt; t</B>

<P>
<P>
<B>map f a</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

,
and builds a floatarray with the results returned by 
<B>f</B>

.
<P>
<P>
<P>
<I>val mapi </I>

: 
<B>(int -&gt; float -&gt; float) -&gt; t -&gt; t</B>

<P>
Same as 
<B>Float.Array.map</B>

, but the
function is applied to the index of the element as first argument,
and the element itself as second argument.
<P>
<P>
<P>
<I>val fold_left </I>

: 
<B>('a -&gt; float -&gt; 'a) -&gt; 'a -&gt; t -&gt; 'a</B>

<P>
<P>
<B>fold_left f x a</B>

computes
<B>f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)</B>

,
where 
<B>n</B>

is the length of the floatarray 
<B>a</B>

.
<P>
<P>
<P>
<I>val fold_right </I>

: 
<B>(float -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a</B>

<P>
<P>
<B>fold_right f a x</B>

computes
<B>f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))</B>

,
where 
<B>n</B>

is the length of the floatarray 
<B>a</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAF">&nbsp;</A>
<H3>Iterators on two arrays</H3>

<P>
<P>

<P>
<I>val iter2 </I>

: 
<B>(float -&gt; float -&gt; unit) -&gt; t -&gt; t -&gt; unit</B>

<P>
<P>
<B>Array.iter2 f a b</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

and 
<B>b</B>

.
Raise 
<B>Invalid_argument</B>

if the floatarrays are not the same size.
<P>
<P>
<P>
<I>val map2 </I>

: 
<B>(float -&gt; float -&gt; float) -&gt; t -&gt; t -&gt; t</B>

<P>
<P>
<B>map2 f a b</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

and 
<B>b</B>

, and builds a floatarray with the results returned by 
<B>f</B>

:
<B>[| f a.(0) b.(0); ...; f a.(length a - 1) b.(length b - 1)|]</B>

.
Raise 
<B>Invalid_argument</B>

if the floatarrays are not the same size.
<P>
<P>
<P>
<P>

<A NAME="lbAG">&nbsp;</A>
<H3>Array scanning</H3>

<P>
<P>

<P>
<I>val for_all </I>

: 
<B>(float -&gt; bool) -&gt; t -&gt; bool</B>

<P>
<P>
<B>for_all p [|a1; ...; an|]</B>

checks if all elements of the floatarray
satisfy the predicate 
<B>p</B>

. That is, it returns
<B>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</B>

.
<P>
<P>
<P>
<I>val exists </I>

: 
<B>(float -&gt; bool) -&gt; t -&gt; bool</B>

<P>
<P>
<B>exists p [|a1; ...; an|]</B>

checks if at least one element of
the floatarray satisfies the predicate 
<B>p</B>

. That is, it returns
<B>(p a1) || (p a2) || ... || (p an)</B>

.
<P>
<P>
<P>
<I>val mem </I>

: 
<B>float -&gt; t -&gt; bool</B>

<P>
<P>
<B>mem a l</B>

is true if and only if there is an element of 
<B>l</B>

that is
structurally equal to 
<B>a</B>

, i.e. there is an 
<B>x</B>

in 
<B>l</B>

such
that 
<B>compare a x = 0</B>

.
<P>
<P>
<P>
<I>val mem_ieee </I>

: 
<B>float -&gt; t -&gt; bool</B>

<P>
Same as 
<B>Float.Array.mem</B>

, but uses IEEE equality instead of structural equality.
<P>
<P>
<P>
<P>

<A NAME="lbAH">&nbsp;</A>
<H3>Sorting</H3>

<P>
<P>

<P>
<I>val sort </I>

: 
<B>(float -&gt; float -&gt; int) -&gt; t -&gt; unit</B>

<P>
Sort a floatarray in increasing order according to a comparison
function.  The comparison function must return 0 if its arguments
compare as equal, a positive integer if the first is greater,
and a negative integer if the first is smaller (see below for a
complete specification).  For example, 
<B>compare</B>

is
a suitable comparison function.  After calling 
<B>sort</B>

, the
array is sorted in place in increasing order.
<B>sort</B>

is guaranteed to run in constant heap space
and (at most) logarithmic stack space.
<P>
The current implementation uses Heap Sort.  It runs in constant
stack space.
<P>
Specification of the comparison function:
Let 
<B>a</B>

be the floatarray and 
<B>cmp</B>

the comparison function. The following
must be true for all 
<B>x</B>

, 
<B>y</B>

, 
<B>z</B>

in 
<B>a</B>

:
<P>
-     
<B>cmp x y</B>

&gt; 0 if and only if 
<B>cmp y x</B>

&lt; 0
<P>
-     if 
<B>cmp x y</B>

&gt;= 0 and 
<B>cmp y z</B>

&gt;= 0 then 
<B>cmp x z</B>

&gt;= 0
<P>
When 
<B>sort</B>

returns, 
<B>a</B>

contains the same elements as before,
reordered in such a way that for all i and j valid indices of 
<B>a</B>

:
<P>
-     
<B>cmp a.(i) a.(j)</B>

&gt;= 0 if and only if i &gt;= j
<P>
<P>
<P>
<P>
<I>val stable_sort </I>

: 
<B>(float -&gt; float -&gt; int) -&gt; t -&gt; unit</B>

<P>
Same as 
<B>Float.Array.sort</B>

, but the sorting algorithm is stable (i.e.
elements that compare equal are kept in their original order) and
not guaranteed to run in constant heap space.
<P>
The current implementation uses Merge Sort. It uses a temporary
floatarray of length 
<B>n/2</B>

, where 
<B>n</B>

is the length of the floatarray.
It is usually faster than the current implementation of 
<B>Float.Array.sort</B>

.
<P>
<P>
<P>
<I>val fast_sort </I>

: 
<B>(float -&gt; float -&gt; int) -&gt; t -&gt; unit</B>

<P>
Same as 
<B>Float.Array.sort</B>

or 
<B>Float.Array.stable_sort</B>

, whichever is faster
on typical input.
<P>
<P>
<P>
<P>

<A NAME="lbAI">&nbsp;</A>
<H3>Iterators</H3>

<P>
<P>

<P>
<I>val to_seq </I>

: 
<B>t -&gt; float Seq.t</B>

<P>
Iterate on the floatarray, in increasing order. Modifications of the
floatarray during iteration will be reflected in the iterator.
<P>
<P>
<P>
<I>val to_seqi </I>

: 
<B>t -&gt; (int * float) Seq.t</B>

<P>
Iterate on the floatarray, in increasing order, yielding indices along
elements. Modifications of the floatarray during iteration will be
reflected in the iterator.
<P>
<P>
<P>
<I>val of_seq </I>

: 
<B>float Seq.t -&gt; t</B>

<P>
Create an array from the generator.
<P>
<P>
<P>
<I>val map_to_array </I>

: 
<B>(float -&gt; 'a) -&gt; t -&gt; 'a array</B>

<P>
<P>
<B>map_to_array f a</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

,
and builds an array with the results returned by 
<B>f</B>

:
<B>[| f a.(0); f a.(1); ...; f a.(length a - 1) |]</B>

.
<P>
<P>
<P>
<I>val map_from_array </I>

: 
<B>('a -&gt; float) -&gt; 'a array -&gt; t</B>

<P>
<P>
<B>map_from_array f a</B>

applies function 
<B>f</B>

to all the elements of 
<B>a</B>

,
and builds a floatarray with the results returned by 
<B>f</B>

.
<P>
<P>
<P>
<P>

<A NAME="lbAJ">&nbsp;</A>
<H3>Undocumented functions</H3>

<P>
<P>

<P>
<I>val unsafe_get </I>

: 
<B>t -&gt; int -&gt; float</B>

<P>
<P>
<P>
<P>
<I>val unsafe_set </I>

: 
<B>t -&gt; int -&gt; float -&gt; unit</B>

<P>
<P>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">Module</A><DD>
<DT id="3"><A HREF="#lbAD">Documentation</A><DD>
<DL>
<DT id="4"><A HREF="#lbAE">Iterators</A><DD>
<DT id="5"><A HREF="#lbAF">Iterators on two arrays</A><DD>
<DT id="6"><A HREF="#lbAG">Array scanning</A><DD>
<DT id="7"><A HREF="#lbAH">Sorting</A><DD>
<DT id="8"><A HREF="#lbAI">Iterators</A><DD>
<DT id="9"><A HREF="#lbAJ">Undocumented functions</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:43 GMT, March 31, 2021
</BODY>
</HTML>
