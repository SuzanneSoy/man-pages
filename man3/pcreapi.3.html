
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of PCREAPI</TITLE>
</HEAD><BODY>
<H1>PCREAPI</H1>
Section: C Library Functions (3)<BR>Updated: 18 December 2015<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

PCRE - Perl-compatible regular expressions
<P>
<B>#include &lt;<A HREF="file:///usr/include/pcre.h">pcre.h</A>&gt;</B>

<A NAME="lbAC">&nbsp;</A>
<H2>PCRE NATIVE API BASIC FUNCTIONS</H2>


<P>
<PRE>
<B>pcre *pcre_compile(const char *</B><I>pattern</I>, int <I>options</I>,
<B>     const char **</B><I>errptr</I>, int *<I>erroffset</I>,
<B>     const unsigned char *</B><I>tableptr</I>);

<B>pcre *pcre_compile2(const char *</B><I>pattern</I>, int <I>options</I>,
<B>     int *</B><I>errorcodeptr</I>,
<B>     const char **</B><I>errptr</I>, int *<I>erroffset</I>,
<B>     const unsigned char *</B><I>tableptr</I>);

<B>pcre_extra *pcre_study(const pcre *</B><I>code</I>, int <I>options</I>,
<B>     const char **</B><I>errptr</I>);

<B>void pcre_free_study(pcre_extra *</B><I>extra</I>);

<B>int pcre_exec(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     const char *</B><I>subject</I>, int <I>length</I>, int <I>startoffset</I>,
<B>     int </B><I>options</I>, int *<I>ovector</I>, int <I>ovecsize</I>);

<B>int pcre_dfa_exec(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     const char *</B><I>subject</I>, int <I>length</I>, int <I>startoffset</I>,
<B>     int </B><I>options</I>, int *<I>ovector</I>, int <I>ovecsize</I>,
<B>     int *</B><I>workspace</I>, int <I>wscount</I>);
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>PCRE NATIVE API STRING EXTRACTION FUNCTIONS</H2>


<P>
<PRE>
<B>int pcre_copy_named_substring(const pcre *</B><I>code</I>,
<B>     const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, const char *<I>stringname</I>,
<B>     char *</B><I>buffer</I>, int <I>buffersize</I>);

<B>int pcre_copy_substring(const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, int <I>stringnumber</I>, char *<I>buffer</I>,
<B>     int </B><I>buffersize</I>);

<B>int pcre_get_named_substring(const pcre *</B><I>code</I>,
<B>     const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, const char *<I>stringname</I>,
<B>     const char **</B><I>stringptr</I>);

<B>int pcre_get_stringnumber(const pcre *</B><I>code</I>,
<B>     const char *</B><I>name</I>);

<B>int pcre_get_stringtable_entries(const pcre *</B><I>code</I>,
<B>     const char *</B><I>name</I>, char **<I>first</I>, char **<I>last</I>);

<B>int pcre_get_substring(const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, int <I>stringnumber</I>,
<B>     const char **</B><I>stringptr</I>);

<B>int pcre_get_substring_list(const char *</B><I>subject</I>,
<B>     int *</B><I>ovector</I>, int <I>stringcount</I>, const char ***<I>listptr</I>);

<B>void pcre_free_substring(const char *</B><I>stringptr</I>);

<B>void pcre_free_substring_list(const char **</B><I>stringptr</I>);
</PRE>

<A NAME="lbAE">&nbsp;</A>
<H2>PCRE NATIVE API AUXILIARY FUNCTIONS</H2>


<P>
<PRE>
<B>int pcre_jit_exec(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     const char *</B><I>subject</I>, int <I>length</I>, int <I>startoffset</I>,
<B>     int </B><I>options</I>, int *<I>ovector</I>, int <I>ovecsize</I>,
<B>     pcre_jit_stack *</B><I>jstack</I>);

<B>pcre_jit_stack *pcre_jit_stack_alloc(int </B><I>startsize</I>, int <I>maxsize</I>);

<B>void pcre_jit_stack_free(pcre_jit_stack *</B><I>stack</I>);

<B>void pcre_assign_jit_stack(pcre_extra *</B><I>extra</I>,
<B>     pcre_jit_callback </B><I>callback</I>, void *<I>data</I>);

<B>const unsigned char *pcre_maketables(void);</B>

<B>int pcre_fullinfo(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     int </B><I>what</I>, void *<I>where</I>);

<B>int pcre_refcount(pcre *</B><I>code</I>, int <I>adjust</I>);

<B>int pcre_config(int </B><I>what</I>, void *<I>where</I>);

<B>const char *pcre_version(void);</B>

<B>int pcre_pattern_to_host_byte_order(pcre *</B><I>code</I>,
<B>     pcre_extra *</B><I>extra</I>, const unsigned char *<I>tables</I>);
</PRE>

<A NAME="lbAF">&nbsp;</A>
<H2>PCRE NATIVE API INDIRECTED FUNCTIONS</H2>


<P>
<PRE>
<B>void *(*pcre_malloc)(size_t);</B>

<B>void (*pcre_free)(void *);</B>

<B>void *(*pcre_stack_malloc)(size_t);</B>

<B>void (*pcre_stack_free)(void *);</B>

<B>int (*pcre_callout)(pcre_callout_block *);</B>

<B>int (*pcre_stack_guard)(void);</B>
</PRE>

<A NAME="lbAG">&nbsp;</A>
<H2>PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</H2>


<P>
As well as support for 8-bit character strings, PCRE also supports 16-bit
strings (from release 8.30) and 32-bit strings (from release 8.32), by means of
two additional libraries. They can be built as well as, or instead of, the
8-bit library. To avoid too much complication, this document describes the
8-bit versions of the functions, with only occasional references to the 16-bit
and 32-bit libraries.
<P>

The 16-bit and 32-bit functions operate in the same way as their 8-bit
counterparts; they just use different data types for their arguments and
results, and their names start with <B>pcre16_</B> or <B>pcre32_</B> instead of
<B>pcre_</B>. For every option that has UTF8 in its name (for example,
PCRE_UTF8), there are corresponding 16-bit and 32-bit names with UTF8 replaced
by UTF16 or UTF32, respectively. This facility is in fact just cosmetic; the
16-bit and 32-bit option names define the same bit values.
<P>

References to bytes and UTF-8 in this document should be read as references to
16-bit data units and UTF-16 when using the 16-bit library, or 32-bit data
units and UTF-32 when using the 32-bit library, unless specified otherwise.
More details of the specific differences for the 16-bit and 32-bit libraries
are given in the

<B>pcre16</B>

and

<B>pcre32</B>

pages.
<A NAME="lbAH">&nbsp;</A>
<H2>PCRE API OVERVIEW</H2>


<P>
PCRE has its own native API, which is described in this document. There are
also some wrapper functions (for the 8-bit library only) that correspond to the
POSIX regular expression API, but they do not give access to all the
functionality. They are described in the

<B>pcreposix</B>

documentation. Both of these APIs define a set of C function calls. A C++
wrapper (again for the 8-bit library only) is also distributed with PCRE. It is
documented in the

<B>pcrecpp</B>

page.
<P>

The native API C function prototypes are defined in the header file
<B>pcre.h</B>, and on Unix-like systems the (8-bit) library itself is called
<B>libpcre</B>. It can normally be accessed by adding <B>-lpcre</B> to the
command for linking an application that uses PCRE. The header file defines the
macros PCRE_MAJOR and PCRE_MINOR to contain the major and minor release numbers
for the library. Applications can use these to include support for different
releases of PCRE.
<P>

In a Windows environment, if you want to statically link an application program
against a non-dll <B>pcre.a</B> file, you must define PCRE_STATIC before
including <B>pcre.h</B> or <B>pcrecpp.h</B>, because otherwise the
<B>pcre_malloc()</B> and <B>pcre_free()</B> exported functions will be declared
<B>__declspec(dllimport)</B>, with unwanted results.
<P>

The functions <B>pcre_compile()</B>, <B>pcre_compile2()</B>, <B>pcre_study()</B>,
and <B>pcre_exec()</B> are used for compiling and matching regular expressions
in a Perl-compatible manner. A sample program that demonstrates the simplest
way of using them is provided in the file called <I>pcredemo.c</I> in the PCRE
source distribution. A listing of this program is given in the

<B>pcredemo</B>

documentation, and the

<B>pcresample</B>

documentation describes how to compile and run it.
<P>

Just-in-time compiler support is an optional feature of PCRE that can be built
in appropriate hardware environments. It greatly speeds up the matching
performance of many patterns. Simple programs can easily request that it be
used if available, by setting an option that is ignored when it is not
relevant. More complicated programs might need to make use of the functions
<B>pcre_jit_stack_alloc()</B>, <B>pcre_jit_stack_free()</B>, and
<B>pcre_assign_jit_stack()</B> in order to control the JIT code's memory usage.
<P>

From release 8.32 there is also a direct interface for JIT execution, which
gives improved performance. The JIT-specific functions are discussed in the

<B>pcrejit</B>

documentation.
<P>

A second matching function, <B>pcre_dfa_exec()</B>, which is not
Perl-compatible, is also provided. This uses a different algorithm for the
matching. The alternative algorithm finds all possible matches (at a given
point in the subject), and scans the subject just once (unless there are
lookbehind assertions). However, this algorithm does not return captured
substrings. A description of the two matching algorithms and their advantages
and disadvantages is given in the

<B>pcrematching</B>

documentation.
<P>

In addition to the main compiling and matching functions, there are convenience
functions for extracting captured substrings from a subject string that is
matched by <B>pcre_exec()</B>. They are:
<P>
<BR>&nbsp;&nbsp;<B>pcre_copy_substring()</B>
<BR>&nbsp;&nbsp;<B>pcre_copy_named_substring()</B>
<BR>&nbsp;&nbsp;<B>pcre_get_substring()</B>
<BR>&nbsp;&nbsp;<B>pcre_get_named_substring()</B>
<BR>&nbsp;&nbsp;<B>pcre_get_substring_list()</B>
<BR>&nbsp;&nbsp;<B>pcre_get_stringnumber()</B>
<BR>&nbsp;&nbsp;<B>pcre_get_stringtable_entries()</B>
<P>
<B>pcre_free_substring()</B> and <B>pcre_free_substring_list()</B> are also
provided, to free the memory used for extracted strings.
<P>

The function <B>pcre_maketables()</B> is used to build a set of character tables
in the current locale for passing to <B>pcre_compile()</B>, <B>pcre_exec()</B>,
or <B>pcre_dfa_exec()</B>. This is an optional facility that is provided for
specialist use. Most commonly, no special tables are passed, in which case
internal tables that are generated when PCRE is built are used.
<P>

The function <B>pcre_fullinfo()</B> is used to find out information about a
compiled pattern. The function <B>pcre_version()</B> returns a pointer to a
string containing the version of PCRE and its date of release.
<P>

The function <B>pcre_refcount()</B> maintains a reference count in a data block
containing a compiled pattern. This is provided for the benefit of
object-oriented applications.
<P>

The global variables <B>pcre_malloc</B> and <B>pcre_free</B> initially contain
the entry points of the standard <B>malloc()</B> and <B>free()</B> functions,
respectively. PCRE calls the memory management functions via these variables,
so a calling program can replace them if it wishes to intercept the calls. This
should be done before calling any PCRE functions.
<P>

The global variables <B>pcre_stack_malloc</B> and <B>pcre_stack_free</B> are also
indirections to memory management functions. These special functions are used
only when PCRE is compiled to use the heap for remembering data, instead of
recursive function calls, when running the <B>pcre_exec()</B> function. See the

<B>pcrebuild</B>

documentation for details of how to do this. It is a non-standard way of
building PCRE, for use in environments that have limited stacks. Because of the
greater use of memory management, it runs more slowly. Separate functions are
provided so that special-purpose external code can be used for this case. When
used, these functions always allocate memory blocks of the same size. There is
a discussion about PCRE's stack usage in the

<B>pcrestack</B>

documentation.
<P>

The global variable <B>pcre_callout</B> initially contains NULL. It can be set
by the caller to a &quot;callout&quot; function, which PCRE will then call at specified
points during a matching operation. Details are given in the

<B>pcrecallout</B>

documentation.
<P>

The global variable <B>pcre_stack_guard</B> initially contains NULL. It can be
set by the caller to a function that is called by PCRE whenever it starts
to compile a parenthesized part of a pattern. When parentheses are nested, PCRE
uses recursive function calls, which use up the system stack. This function is
provided so that applications with restricted stacks can force a compilation
error if the stack runs out. The function should return zero if all is well, or
non-zero to force an error.

<A NAME="lbAI">&nbsp;</A>
<H2>NEWLINES</H2>


<P>
PCRE supports five different conventions for indicating line breaks in
strings: a single CR (carriage return) character, a single LF (linefeed)
character, the two-character sequence CRLF, any of the three preceding, or any
Unicode newline sequence. The Unicode newline sequences are the three just
mentioned, plus the single characters VT (vertical tab, U+000B), FF (form feed,
U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS
(paragraph separator, U+2029).
<P>

Each of the first three conventions is used by at least one operating system as
its standard newline sequence. When PCRE is built, a default can be specified.
The default default is LF, which is the Unix standard. When PCRE is run, the
default can be overridden, either when a pattern is compiled, or when it is
matched.
<P>

At compile time, the newline convention can be specified by the <I>options</I>
argument of <B>pcre_compile()</B>, or it can be specified by special text at the
start of the pattern itself; this overrides any other settings. See the

<B>pcrepattern</B>

page for details of the special character sequences.
<P>

In the PCRE documentation the word &quot;newline&quot; is used to mean &quot;the character or
pair of characters that indicate a line break&quot;. The choice of newline
convention affects the handling of the dot, circumflex, and dollar
metacharacters, the handling of #-comments in /x mode, and, when CRLF is a
recognized line ending sequence, the match position advancement for a
non-anchored pattern. There is more detail about this in the


section on <B>pcre_exec()</B> options

below.
<P>

The choice of newline convention does not affect the interpretation of
the \n or \r escape sequences, nor does it affect what \R matches, which is
controlled in a similar way, but by separate options.
<A NAME="lbAJ">&nbsp;</A>
<H2>MULTITHREADING</H2>


<P>
The PCRE functions can be used in multi-threading applications, with the
proviso that the memory management functions pointed to by <B>pcre_malloc</B>,
<B>pcre_free</B>, <B>pcre_stack_malloc</B>, and <B>pcre_stack_free</B>, and the
callout and stack-checking functions pointed to by <B>pcre_callout</B> and
<B>pcre_stack_guard</B>, are shared by all threads.
<P>

The compiled form of a regular expression is not altered during matching, so
the same compiled pattern can safely be used by several threads at once.
<P>

If the just-in-time optimization feature is being used, it needs separate
memory stack areas for each thread. See the

<B>pcrejit</B>

documentation for more details.
<A NAME="lbAK">&nbsp;</A>
<H2>SAVING PRECOMPILED PATTERNS FOR LATER USE</H2>


<P>
The compiled form of a regular expression can be saved and re-used at a later
time, possibly by a different program, and even on a host other than the one on
which it was compiled. Details are given in the

<B>pcreprecompile</B>

documentation, which includes a description of the
<B>pcre_pattern_to_host_byte_order()</B> function. However, compiling a regular
expression with one version of PCRE for use with a different version is not
guaranteed to work and may cause crashes.
<A NAME="lbAL">&nbsp;</A>
<H2>CHECKING BUILD-TIME OPTIONS</H2>


<P>
<B>int pcre_config(int </B><I>what</I>, void *<I>where</I>);

<P>

The function <B>pcre_config()</B> makes it possible for a PCRE client to
discover which optional features have been compiled into the PCRE library. The

<B>pcrebuild</B>

documentation has more details about these optional features.
<P>

The first argument for <B>pcre_config()</B> is an integer, specifying which
information is required; the second argument is a pointer to a variable into
which the information is placed. The returned value is zero on success, or the
negative error code PCRE_ERROR_BADOPTION if the value in the first argument is
not recognized. The following information is available:
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_UTF8
<P>
The output is an integer that is set to one if UTF-8 support is available;
otherwise it is set to zero. This value should normally be given to the 8-bit
version of this function, <B>pcre_config()</B>. If it is given to the 16-bit
or 32-bit version of this function, the result is PCRE_ERROR_BADOPTION.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_UTF16
<P>
The output is an integer that is set to one if UTF-16 support is available;
otherwise it is set to zero. This value should normally be given to the 16-bit
version of this function, <B>pcre16_config()</B>. If it is given to the 8-bit
or 32-bit version of this function, the result is PCRE_ERROR_BADOPTION.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_UTF32
<P>
The output is an integer that is set to one if UTF-32 support is available;
otherwise it is set to zero. This value should normally be given to the 32-bit
version of this function, <B>pcre32_config()</B>. If it is given to the 8-bit
or 16-bit version of this function, the result is PCRE_ERROR_BADOPTION.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_UNICODE_PROPERTIES
<P>
The output is an integer that is set to one if support for Unicode character
properties is available; otherwise it is set to zero.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_JIT
<P>
The output is an integer that is set to one if support for just-in-time
compiling is available; otherwise it is set to zero.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_JITTARGET
<P>
The output is a pointer to a zero-terminated &quot;const char *&quot; string. If JIT
support is available, the string contains the name of the architecture for
which the JIT compiler is configured, for example &quot;x86 32bit (little endian +
unaligned)&quot;. If JIT support is not available, the result is NULL.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_NEWLINE
<P>
The output is an integer whose value specifies the default character sequence
that is recognized as meaning &quot;newline&quot;. The values that are supported in
ASCII/Unicode environments are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for
ANYCRLF, and -1 for ANY. In EBCDIC environments, CR, ANYCRLF, and ANY yield the
same values. However, the value for LF is normally 21, though some EBCDIC
environments use 37. The corresponding values for CRLF are 3349 and 3365. The
default should normally correspond to the standard sequence for your operating
system.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_BSR
<P>
The output is an integer whose value indicates what character sequences the \R
escape sequence matches by default. A value of 0 means that \R matches any
Unicode line ending sequence; a value of 1 means that \R matches only CR, LF,
or CRLF. The default can be overridden when a pattern is compiled or matched.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_LINK_SIZE
<P>
The output is an integer that contains the number of bytes used for internal
linkage in compiled regular expressions. For the 8-bit library, the value can
be 2, 3, or 4. For the 16-bit library, the value is either 2 or 4 and is still
a number of bytes. For the 32-bit library, the value is either 2 or 4 and is
still a number of bytes. The default value of 2 is sufficient for all but the
most massive patterns, since it allows the compiled pattern to be up to 64K in
size. Larger values allow larger regular expressions to be compiled, at the
expense of slower matching.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_POSIX_MALLOC_THRESHOLD
<P>
The output is an integer that contains the threshold above which the POSIX
interface uses <B>malloc()</B> for output vectors. Further details are given in
the

<B>pcreposix</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_PARENS_LIMIT
<P>
The output is a long integer that gives the maximum depth of nesting of
parentheses (of any kind) in a pattern. This limit is imposed to cap the amount
of system stack used when a pattern is compiled. It is specified when PCRE is
built; the default is 250. This limit does not take into account the stack that
may already be used by the calling application. For finer control over
compilation stack usage, you can set a pointer to an external checking function
in <B>pcre_stack_guard</B>.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_MATCH_LIMIT
<P>
The output is a long integer that gives the default limit for the number of
internal matching function calls in a <B>pcre_exec()</B> execution. Further
details are given with <B>pcre_exec()</B> below.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_MATCH_LIMIT_RECURSION
<P>
The output is a long integer that gives the default limit for the depth of
recursion when calling the internal matching function in a <B>pcre_exec()</B>
execution. Further details are given with <B>pcre_exec()</B> below.
<P>
<BR>&nbsp;&nbsp;PCRE_CONFIG_STACKRECURSE
<P>
The output is an integer that is set to one if internal recursion when running
<B>pcre_exec()</B> is implemented by recursive function calls that use the stack
to remember their state. This is the usual way that PCRE is compiled. The
output is zero if PCRE was compiled to use blocks of data on the heap instead
of recursive function calls. In this case, <B>pcre_stack_malloc</B> and
<B>pcre_stack_free</B> are called to manage memory blocks on the heap, thus
avoiding the use of the stack.
<A NAME="lbAM">&nbsp;</A>
<H2>COMPILING A PATTERN</H2>


<P>
<PRE>
<B>pcre *pcre_compile(const char *</B><I>pattern</I>, int <I>options</I>,
<B>     const char **</B><I>errptr</I>, int *<I>erroffset</I>,
<B>     const unsigned char *</B><I>tableptr</I>);

<B>pcre *pcre_compile2(const char *</B><I>pattern</I>, int <I>options</I>,
<B>     int *</B><I>errorcodeptr</I>,
<B>     const char **</B><I>errptr</I>, int *<I>erroffset</I>,
<B>     const unsigned char *</B><I>tableptr</I>);
</PRE>

<P>

Either of the functions <B>pcre_compile()</B> or <B>pcre_compile2()</B> can be
called to compile a pattern into an internal form. The only difference between
the two interfaces is that <B>pcre_compile2()</B> has an additional argument,
<I>errorcodeptr</I>, via which a numerical error code can be returned. To avoid
too much repetition, we refer just to <B>pcre_compile()</B> below, but the
information applies equally to <B>pcre_compile2()</B>.
<P>

The pattern is a C string terminated by a binary zero, and is passed in the
<I>pattern</I> argument. A pointer to a single block of memory that is obtained
via <B>pcre_malloc</B> is returned. This contains the compiled code and related
data. The <B>pcre</B> type is defined for the returned block; this is a typedef
for a structure whose contents are not externally defined. It is up to the
caller to free the memory (via <B>pcre_free</B>) when it is no longer required.
<P>

Although the compiled code of a PCRE regex is relocatable, that is, it does not
depend on memory location, the complete <B>pcre</B> data block is not
fully relocatable, because it may contain a copy of the <I>tableptr</I>
argument, which is an address (see below).
<P>

The <I>options</I> argument contains various bit settings that affect the
compilation. It should be zero if no options are required. The available
options are described below. Some of them (in particular, those that are
compatible with Perl, but some others as well) can also be set and unset from
within the pattern (see the detailed description in the

<B>pcrepattern</B>

documentation). For those options that can be different in different parts of
the pattern, the contents of the <I>options</I> argument specifies their
settings at the start of compilation and execution. The PCRE_ANCHORED,
PCRE_BSR_<I>xxx</I>, PCRE_NEWLINE_<I>xxx</I>, PCRE_NO_UTF8_CHECK, and
PCRE_NO_START_OPTIMIZE options can be set at the time of matching as well as at
compile time.
<P>

If <I>errptr</I> is NULL, <B>pcre_compile()</B> returns NULL immediately.
Otherwise, if compilation of a pattern fails, <B>pcre_compile()</B> returns
NULL, and sets the variable pointed to by <I>errptr</I> to point to a textual
error message. This is a static string that is part of the library. You must
not try to free it. Normally, the offset from the start of the pattern to the
data unit that was being processed when the error was discovered is placed in
the variable pointed to by <I>erroffset</I>, which must not be NULL (if it is,
an immediate error is given). However, for an invalid UTF-8 or UTF-16 string,
the offset is that of the first data unit of the failing character.
<P>

Some errors are not detected until the whole pattern has been scanned; in these
cases, the offset passed back is the length of the pattern. Note that the
offset is in data units, not characters, even in a UTF mode. It may sometimes
point into the middle of a UTF-8 or UTF-16 character.
<P>

If <B>pcre_compile2()</B> is used instead of <B>pcre_compile()</B>, and the
<I>errorcodeptr</I> argument is not NULL, a non-zero error code number is
returned via this argument in the event of an error. This is in addition to the
textual error message. Error codes and messages are listed below.
<P>

If the final argument, <I>tableptr</I>, is NULL, PCRE uses a default set of
character tables that are built when PCRE is compiled, using the default C
locale. Otherwise, <I>tableptr</I> must be an address that is the result of a
call to <B>pcre_maketables()</B>. This value is stored with the compiled
pattern, and used again by <B>pcre_exec()</B> and <B>pcre_dfa_exec()</B> when the
pattern is matched. For more discussion, see the section on locale support
below.
<P>

This code fragment shows a typical straightforward call to <B>pcre_compile()</B>:
<P>
<BR>&nbsp;&nbsp;pcre&nbsp;*re;
<BR>&nbsp;&nbsp;const&nbsp;char&nbsp;*error;
<BR>&nbsp;&nbsp;int&nbsp;erroffset;
<BR>&nbsp;&nbsp;re&nbsp;=&nbsp;pcre_compile(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;^A.*Z&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;pattern&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;error,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;error&nbsp;message&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;erroffset,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;error&nbsp;offset&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;use&nbsp;default&nbsp;character&nbsp;tables&nbsp;*/
<P>
The following names for option bits are defined in the <B>pcre.h</B> header
file:
<P>
<BR>&nbsp;&nbsp;PCRE_ANCHORED
<P>
If this bit is set, the pattern is forced to be &quot;anchored&quot;, that is, it is
constrained to match only at the first matching point in the string that is
being searched (the &quot;subject string&quot;). This effect can also be achieved by
appropriate constructs in the pattern itself, which is the only way to do it in
Perl.
<P>
<BR>&nbsp;&nbsp;PCRE_AUTO_CALLOUT
<P>
If this bit is set, <B>pcre_compile()</B> automatically inserts callout items,
all with number 255, before each pattern item. For discussion of the callout
facility, see the

<B>pcrecallout</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE_BSR_ANYCRLF
<BR>&nbsp;&nbsp;PCRE_BSR_UNICODE
<P>
These options (which are mutually exclusive) control what the \R escape
sequence matches. The choice is either to match only CR, LF, or CRLF, or to
match any Unicode newline sequence. The default is specified when PCRE is
built. It can be overridden from within the pattern, or by setting an option
when a compiled pattern is matched.
<P>
<BR>&nbsp;&nbsp;PCRE_CASELESS
<P>
If this bit is set, letters in the pattern match both upper and lower case
letters. It is equivalent to Perl's /i option, and it can be changed within a
pattern by a (?i) option setting. In UTF-8 mode, PCRE always understands the
concept of case for characters whose values are less than 128, so caseless
matching is always possible. For characters with higher values, the concept of
case is supported if PCRE is compiled with Unicode property support, but not
otherwise. If you want to use caseless matching for characters 128 and above,
you must ensure that PCRE is compiled with Unicode property support as well as
with UTF-8 support.
<P>
<BR>&nbsp;&nbsp;PCRE_DOLLAR_ENDONLY
<P>
If this bit is set, a dollar metacharacter in the pattern matches only at the
end of the subject string. Without this option, a dollar also matches
immediately before a newline at the end of the string (but not before any other
newlines). The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is set.
There is no equivalent to this option in Perl, and no way to set it within a
pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_DOTALL
<P>
If this bit is set, a dot metacharacter in the pattern matches a character of
any value, including one that indicates a newline. However, it only ever
matches one character, even if newlines are coded as CRLF. Without this option,
a dot does not match when the current position is at a newline. This option is
equivalent to Perl's /s option, and it can be changed within a pattern by a
(?s) option setting. A negative class such as [^a] always matches newline
characters, independent of the setting of this option.
<P>
<BR>&nbsp;&nbsp;PCRE_DUPNAMES
<P>
If this bit is set, names used to identify capturing subpatterns need not be
unique. This can be helpful for certain types of pattern when it is known that
only one instance of the named subpattern can ever be matched. There are more
details of named subpatterns below; see also the

<B>pcrepattern</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE_EXTENDED
<P>
If this bit is set, most white space characters in the pattern are totally
ignored except when escaped or inside a character class. However, white space
is not allowed within sequences such as (?&gt; that introduce various
parenthesized subpatterns, nor within a numerical quantifier such as {1,3}.
However, ignorable white space is permitted between an item and a following
quantifier and between a quantifier and a following + that indicates
possessiveness.
<P>

White space did not used to include the VT character (code 11), because Perl
did not treat this character as white space. However, Perl changed at release
5.18, so PCRE followed at release 8.34, and VT is now treated as white space.
<P>

PCRE_EXTENDED also causes characters between an unescaped # outside a character
class and the next newline, inclusive, to be ignored. PCRE_EXTENDED is
equivalent to Perl's /x option, and it can be changed within a pattern by a
(?x) option setting.
<P>

Which characters are interpreted as newlines is controlled by the options
passed to <B>pcre_compile()</B> or by a special sequence at the start of the
pattern, as described in the section entitled


&quot;Newline conventions&quot;

in the <B>pcrepattern</B> documentation. Note that the end of this type of
comment is a literal newline sequence in the pattern; escape sequences that
happen to represent a newline do not count.
<P>

This option makes it possible to include comments inside complicated patterns.
Note, however, that this applies only to data characters. White space characters
may never appear within special character sequences in a pattern, for example
within the sequence (?( that introduces a conditional subpattern.
<P>
<BR>&nbsp;&nbsp;PCRE_EXTRA
<P>
This option was invented in order to turn on additional functionality of PCRE
that is incompatible with Perl, but it is currently of very little use. When
set, any backslash in a pattern that is followed by a letter that has no
special meaning causes an error, thus reserving these combinations for future
expansion. By default, as in Perl, a backslash followed by a letter with no
special meaning is treated as a literal. (Perl can, however, be persuaded to
give an error for this, by running it with the -w option.) There are at present
no other features controlled by this option. It can also be set by a (?X)
option setting within a pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_FIRSTLINE
<P>
If this option is set, an unanchored pattern is required to match before or at
the first newline in the subject string, though the matched text may continue
over the newline.
<P>
<BR>&nbsp;&nbsp;PCRE_JAVASCRIPT_COMPAT
<P>
If this option is set, PCRE's behaviour is changed in some ways so that it is
compatible with JavaScript rather than Perl. The changes are as follows:
<P>

(1) A lone closing square bracket in a pattern causes a compile-time error,
because this is illegal in JavaScript (by default it is treated as a data
character). Thus, the pattern AB]CD becomes illegal when this option is set.
<P>

(2) At run time, a back reference to an unset subpattern group matches an empty
string (by default this causes the current matching alternative to fail). A
pattern such as (\1)(a) succeeds when this option is set (assuming it can find
an &quot;a&quot; in the subject), whereas it fails by default, for Perl compatibility.
<P>

(3) \U matches an upper case &quot;U&quot; character; by default \U causes a compile
time error (Perl uses \U to upper case subsequent characters).
<P>

(4) \u matches a lower case &quot;u&quot; character unless it is followed by four
hexadecimal digits, in which case the hexadecimal number defines the code point
to match. By default, \u causes a compile time error (Perl uses it to upper
case the following character).
<P>

(5) \x matches a lower case &quot;x&quot; character unless it is followed by two
hexadecimal digits, in which case the hexadecimal number defines the code point
to match. By default, as in Perl, a hexadecimal number is always expected after
\x, but it may have zero, one, or two digits (so, for example, \xz matches a
binary zero character followed by z).
<P>
<BR>&nbsp;&nbsp;PCRE_MULTILINE
<P>
By default, for the purposes of matching &quot;start of line&quot; and &quot;end of line&quot;,
PCRE treats the subject string as consisting of a single line of characters,
even if it actually contains newlines. The &quot;start of line&quot; metacharacter (^)
matches only at the start of the string, and the &quot;end of line&quot; metacharacter
($) matches only at the end of the string, or before a terminating newline
(except when PCRE_DOLLAR_ENDONLY is set). Note, however, that unless
PCRE_DOTALL is set, the &quot;any character&quot; metacharacter (.) does not match at a
newline. This behaviour (for ^, $, and dot) is the same as Perl.
<P>

When PCRE_MULTILINE it is set, the &quot;start of line&quot; and &quot;end of line&quot; constructs
match immediately following or immediately before internal newlines in the
subject string, respectively, as well as at the very start and end. This is
equivalent to Perl's /m option, and it can be changed within a pattern by a
(?m) option setting. If there are no newlines in a subject string, or no
occurrences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.
<P>
<BR>&nbsp;&nbsp;PCRE_NEVER_UTF
<P>
This option locks out interpretation of the pattern as UTF-8 (or UTF-16 or
UTF-32 in the 16-bit and 32-bit libraries). In particular, it prevents the
creator of the pattern from switching to UTF interpretation by starting the
pattern with (*UTF). This may be useful in applications that process patterns
from external sources. The combination of PCRE_UTF8 and PCRE_NEVER_UTF also
causes an error.
<P>
<BR>&nbsp;&nbsp;PCRE_NEWLINE_CR
<BR>&nbsp;&nbsp;PCRE_NEWLINE_LF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_CRLF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_ANYCRLF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_ANY
<P>
These options override the default newline definition that was chosen when PCRE
was built. Setting the first or the second specifies that a newline is
indicated by a single character (CR or LF, respectively). Setting
PCRE_NEWLINE_CRLF specifies that a newline is indicated by the two-character
CRLF sequence. Setting PCRE_NEWLINE_ANYCRLF specifies that any of the three
preceding sequences should be recognized. Setting PCRE_NEWLINE_ANY specifies
that any Unicode newline sequence should be recognized.
<P>

In an ASCII/Unicode environment, the Unicode newline sequences are the three
just mentioned, plus the single characters VT (vertical tab, U+000B), FF (form
feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS
(paragraph separator, U+2029). For the 8-bit library, the last two are
recognized only in UTF-8 mode.
<P>

When PCRE is compiled to run in an EBCDIC (mainframe) environment, the code for
CR is 0x0d, the same as ASCII. However, the character code for LF is normally
0x15, though in some EBCDIC environments 0x25 is used. Whichever of these is
not LF is made to correspond to Unicode's NEL character. EBCDIC codes are all
less than 256. For more details, see the

<B>pcrebuild</B>

documentation.
<P>

The newline setting in the options word uses three bits that are treated
as a number, giving eight possibilities. Currently only six are used (default
plus the five values above). This means that if you set more than one newline
option, the combination may or may not be sensible. For example,
PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent to PCRE_NEWLINE_CRLF, but
other combinations may yield unused numbers and cause an error.
<P>

The only time that a line break in a pattern is specially recognized when
compiling is when PCRE_EXTENDED is set. CR and LF are white space characters,
and so are ignored in this mode. Also, an unescaped # outside a character class
indicates a comment that lasts until after the next line break sequence. In
other circumstances, line break sequences in patterns are treated as literal
data.
<P>

The newline option that is set at compile time becomes the default that is used
for <B>pcre_exec()</B> and <B>pcre_dfa_exec()</B>, but it can be overridden.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_AUTO_CAPTURE
<P>
If this option is set, it disables the use of numbered capturing parentheses in
the pattern. Any opening parenthesis that is not followed by ? behaves as if it
were followed by ?: but named parentheses can still be used for capturing (and
they acquire numbers in the usual way). There is no equivalent of this option
in Perl.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_AUTO_POSSESS
<P>
If this option is set, it disables &quot;auto-possessification&quot;. This is an
optimization that, for example, turns a+b into a++b in order to avoid
backtracks into a+ that can never be successful. However, if callouts are in
use, auto-possessification means that some of them are never taken. You can set
this option if you want the matching functions to do a full unoptimized search
and run all the callouts, but it is mainly provided for testing purposes.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_START_OPTIMIZE
<P>
This is an option that acts at matching time; that is, it is really an option
for <B>pcre_exec()</B> or <B>pcre_dfa_exec()</B>. If it is set at compile time,
it is remembered with the compiled pattern and assumed at matching time. This
is necessary if you want to use JIT execution, because the JIT compiler needs
to know whether or not this option is set. For details see the discussion of
PCRE_NO_START_OPTIMIZE


below.

<P>
<BR>&nbsp;&nbsp;PCRE_UCP
<P>
This option changes the way PCRE processes \B, \b, \D, \d, \S, \s, \W,
\w, and some of the POSIX character classes. By default, only ASCII characters
are recognized, but if PCRE_UCP is set, Unicode properties are used instead to
classify characters. More details are given in the section on


generic character types

in the

<B>pcrepattern</B>

page. If you set PCRE_UCP, matching one of the items it affects takes much
longer. The option is available only if PCRE has been compiled with Unicode
property support.
<P>
<BR>&nbsp;&nbsp;PCRE_UNGREEDY
<P>
This option inverts the &quot;greediness&quot; of the quantifiers so that they are not
greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible
with Perl. It can also be set by a (?U) option setting within the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8
<P>
This option causes PCRE to regard both the pattern and the subject as strings
of UTF-8 characters instead of single-byte strings. However, it is available
only when PCRE is built to include UTF support. If not, the use of this option
provokes an error. Details of how this option changes the behaviour of PCRE are
given in the

<B>pcreunicode</B>

page.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_UTF8_CHECK
<P>
When PCRE_UTF8 is set, the validity of the pattern as a UTF-8 string is
automatically checked. There is a discussion about the


validity of UTF-8 strings

in the

<B>pcreunicode</B>

page. If an invalid UTF-8 sequence is found, <B>pcre_compile()</B> returns an
error. If you already know that your pattern is valid, and you want to skip
this check for performance reasons, you can set the PCRE_NO_UTF8_CHECK option.
When it is set, the effect of passing an invalid UTF-8 string as a pattern is
undefined. It may cause your program to crash or loop. Note that this option
can also be passed to <B>pcre_exec()</B> and <B>pcre_dfa_exec()</B>, to suppress
the validity checking of subject strings only. If the same string is being
matched many times, the option can be safely set for the second and subsequent
matchings to improve performance.
<A NAME="lbAN">&nbsp;</A>
<H2>COMPILATION ERROR CODES</H2>


<P>
The following table lists the error codes than may be returned by
<B>pcre_compile2()</B>, along with the error messages that may be returned by
both compiling functions. Note that error messages are always 8-bit ASCII
strings, even in 16-bit or 32-bit mode. As PCRE has developed, some error codes
have fallen out of use. To avoid confusion, they have not been re-used.
<P>
<BR>&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;no&nbsp;error
<BR>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;\&nbsp;at&nbsp;end&nbsp;of&nbsp;pattern
<BR>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;\c&nbsp;at&nbsp;end&nbsp;of&nbsp;pattern
<BR>&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;unrecognized&nbsp;character&nbsp;follows&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;numbers&nbsp;out&nbsp;of&nbsp;order&nbsp;in&nbsp;{}&nbsp;quantifier
<BR>&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;number&nbsp;too&nbsp;big&nbsp;in&nbsp;{}&nbsp;quantifier
<BR>&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;missing&nbsp;terminating&nbsp;]&nbsp;for&nbsp;character&nbsp;class
<BR>&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;invalid&nbsp;escape&nbsp;sequence&nbsp;in&nbsp;character&nbsp;class
<BR>&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;range&nbsp;out&nbsp;of&nbsp;order&nbsp;in&nbsp;character&nbsp;class
<BR>&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;nothing&nbsp;to&nbsp;repeat
<BR>&nbsp;&nbsp;10&nbsp;&nbsp;[this&nbsp;code&nbsp;is&nbsp;not&nbsp;in&nbsp;use]
<BR>&nbsp;&nbsp;11&nbsp;&nbsp;internal&nbsp;error:&nbsp;unexpected&nbsp;repeat
<BR>&nbsp;&nbsp;12&nbsp;&nbsp;unrecognized&nbsp;character&nbsp;after&nbsp;(?&nbsp;or&nbsp;(?-
<BR>&nbsp;&nbsp;13&nbsp;&nbsp;POSIX&nbsp;named&nbsp;classes&nbsp;are&nbsp;supported&nbsp;only&nbsp;within&nbsp;a&nbsp;class
<BR>&nbsp;&nbsp;14&nbsp;&nbsp;missing&nbsp;)
<BR>&nbsp;&nbsp;15&nbsp;&nbsp;reference&nbsp;to&nbsp;non-existent&nbsp;subpattern
<BR>&nbsp;&nbsp;16&nbsp;&nbsp;erroffset&nbsp;passed&nbsp;as&nbsp;NULL
<BR>&nbsp;&nbsp;17&nbsp;&nbsp;unknown&nbsp;option&nbsp;bit(s)&nbsp;set
<BR>&nbsp;&nbsp;18&nbsp;&nbsp;missing&nbsp;)&nbsp;after&nbsp;comment
<BR>&nbsp;&nbsp;19&nbsp;&nbsp;[this&nbsp;code&nbsp;is&nbsp;not&nbsp;in&nbsp;use]
<BR>&nbsp;&nbsp;20&nbsp;&nbsp;regular&nbsp;expression&nbsp;is&nbsp;too&nbsp;large
<BR>&nbsp;&nbsp;21&nbsp;&nbsp;failed&nbsp;to&nbsp;get&nbsp;memory
<BR>&nbsp;&nbsp;22&nbsp;&nbsp;unmatched&nbsp;parentheses
<BR>&nbsp;&nbsp;23&nbsp;&nbsp;internal&nbsp;error:&nbsp;code&nbsp;overflow
<BR>&nbsp;&nbsp;24&nbsp;&nbsp;unrecognized&nbsp;character&nbsp;after&nbsp;(?&lt;
<BR>&nbsp;&nbsp;25&nbsp;&nbsp;lookbehind&nbsp;assertion&nbsp;is&nbsp;not&nbsp;fixed&nbsp;length
<BR>&nbsp;&nbsp;26&nbsp;&nbsp;malformed&nbsp;number&nbsp;or&nbsp;name&nbsp;after&nbsp;(?(
<BR>&nbsp;&nbsp;27&nbsp;&nbsp;conditional&nbsp;group&nbsp;contains&nbsp;more&nbsp;than&nbsp;two&nbsp;branches
<BR>&nbsp;&nbsp;28&nbsp;&nbsp;assertion&nbsp;expected&nbsp;after&nbsp;(?(
<BR>&nbsp;&nbsp;29&nbsp;&nbsp;(?R&nbsp;or&nbsp;(?[+-]digits&nbsp;must&nbsp;be&nbsp;followed&nbsp;by&nbsp;)
<BR>&nbsp;&nbsp;30&nbsp;&nbsp;unknown&nbsp;POSIX&nbsp;class&nbsp;name
<BR>&nbsp;&nbsp;31&nbsp;&nbsp;POSIX&nbsp;collating&nbsp;elements&nbsp;are&nbsp;not&nbsp;supported
<BR>&nbsp;&nbsp;32&nbsp;&nbsp;this&nbsp;version&nbsp;of&nbsp;PCRE&nbsp;is&nbsp;compiled&nbsp;without&nbsp;UTF&nbsp;support
<BR>&nbsp;&nbsp;33&nbsp;&nbsp;[this&nbsp;code&nbsp;is&nbsp;not&nbsp;in&nbsp;use]
<BR>&nbsp;&nbsp;34&nbsp;&nbsp;character&nbsp;value&nbsp;in&nbsp;\x{}&nbsp;or&nbsp;\o{}&nbsp;is&nbsp;too&nbsp;large
<BR>&nbsp;&nbsp;35&nbsp;&nbsp;invalid&nbsp;condition&nbsp;(?(0)
<BR>&nbsp;&nbsp;36&nbsp;&nbsp;\C&nbsp;not&nbsp;allowed&nbsp;in&nbsp;lookbehind&nbsp;assertion
<BR>&nbsp;&nbsp;37&nbsp;&nbsp;PCRE&nbsp;does&nbsp;not&nbsp;support&nbsp;\L,&nbsp;\l,&nbsp;\N{name},&nbsp;\U,&nbsp;or&nbsp;\u
<BR>&nbsp;&nbsp;38&nbsp;&nbsp;number&nbsp;after&nbsp;(?C&nbsp;is&nbsp;&gt;&nbsp;255
<BR>&nbsp;&nbsp;39&nbsp;&nbsp;closing&nbsp;)&nbsp;for&nbsp;(?C&nbsp;expected
<BR>&nbsp;&nbsp;40&nbsp;&nbsp;recursive&nbsp;call&nbsp;could&nbsp;loop&nbsp;indefinitely
<BR>&nbsp;&nbsp;41&nbsp;&nbsp;unrecognized&nbsp;character&nbsp;after&nbsp;(?P
<BR>&nbsp;&nbsp;42&nbsp;&nbsp;syntax&nbsp;error&nbsp;in&nbsp;subpattern&nbsp;name&nbsp;(missing&nbsp;terminator)
<BR>&nbsp;&nbsp;43&nbsp;&nbsp;two&nbsp;named&nbsp;subpatterns&nbsp;have&nbsp;the&nbsp;same&nbsp;name
<BR>&nbsp;&nbsp;44&nbsp;&nbsp;invalid&nbsp;UTF-8&nbsp;string&nbsp;(specifically&nbsp;UTF-8)
<BR>&nbsp;&nbsp;45&nbsp;&nbsp;support&nbsp;for&nbsp;\P,&nbsp;\p,&nbsp;and&nbsp;\X&nbsp;has&nbsp;not&nbsp;been&nbsp;compiled
<BR>&nbsp;&nbsp;46&nbsp;&nbsp;malformed&nbsp;\P&nbsp;or&nbsp;\p&nbsp;sequence
<BR>&nbsp;&nbsp;47&nbsp;&nbsp;unknown&nbsp;property&nbsp;name&nbsp;after&nbsp;\P&nbsp;or&nbsp;\p
<BR>&nbsp;&nbsp;48&nbsp;&nbsp;subpattern&nbsp;name&nbsp;is&nbsp;too&nbsp;long&nbsp;(maximum&nbsp;32&nbsp;characters)
<BR>&nbsp;&nbsp;49&nbsp;&nbsp;too&nbsp;many&nbsp;named&nbsp;subpatterns&nbsp;(maximum&nbsp;10000)
<BR>&nbsp;&nbsp;50&nbsp;&nbsp;[this&nbsp;code&nbsp;is&nbsp;not&nbsp;in&nbsp;use]
<BR>&nbsp;&nbsp;51&nbsp;&nbsp;octal&nbsp;value&nbsp;is&nbsp;greater&nbsp;than&nbsp;\377&nbsp;in&nbsp;8-bit&nbsp;non-UTF-8&nbsp;mode
<BR>&nbsp;&nbsp;52&nbsp;&nbsp;internal&nbsp;error:&nbsp;overran&nbsp;compiling&nbsp;workspace
<BR>&nbsp;&nbsp;53&nbsp;&nbsp;internal&nbsp;error:&nbsp;previously-checked&nbsp;referenced&nbsp;subpattern
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;found
<BR>&nbsp;&nbsp;54&nbsp;&nbsp;DEFINE&nbsp;group&nbsp;contains&nbsp;more&nbsp;than&nbsp;one&nbsp;branch
<BR>&nbsp;&nbsp;55&nbsp;&nbsp;repeating&nbsp;a&nbsp;DEFINE&nbsp;group&nbsp;is&nbsp;not&nbsp;allowed
<BR>&nbsp;&nbsp;56&nbsp;&nbsp;inconsistent&nbsp;NEWLINE&nbsp;options
<BR>&nbsp;&nbsp;57&nbsp;&nbsp;\g&nbsp;is&nbsp;not&nbsp;followed&nbsp;by&nbsp;a&nbsp;braced,&nbsp;angle-bracketed,&nbsp;or&nbsp;quoted
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name/number&nbsp;or&nbsp;by&nbsp;a&nbsp;plain&nbsp;number
<BR>&nbsp;&nbsp;58&nbsp;&nbsp;a&nbsp;numbered&nbsp;reference&nbsp;must&nbsp;not&nbsp;be&nbsp;zero
<BR>&nbsp;&nbsp;59&nbsp;&nbsp;an&nbsp;argument&nbsp;is&nbsp;not&nbsp;allowed&nbsp;for&nbsp;(*ACCEPT),&nbsp;(*FAIL),&nbsp;or&nbsp;(*COMMIT)
<BR>&nbsp;&nbsp;60&nbsp;&nbsp;(*VERB)&nbsp;not&nbsp;recognized&nbsp;or&nbsp;malformed
<BR>&nbsp;&nbsp;61&nbsp;&nbsp;number&nbsp;is&nbsp;too&nbsp;big
<BR>&nbsp;&nbsp;62&nbsp;&nbsp;subpattern&nbsp;name&nbsp;expected
<BR>&nbsp;&nbsp;63&nbsp;&nbsp;digit&nbsp;expected&nbsp;after&nbsp;(?+
<BR>&nbsp;&nbsp;64&nbsp;&nbsp;]&nbsp;is&nbsp;an&nbsp;invalid&nbsp;data&nbsp;character&nbsp;in&nbsp;JavaScript&nbsp;compatibility&nbsp;mode
<BR>&nbsp;&nbsp;65&nbsp;&nbsp;different&nbsp;names&nbsp;for&nbsp;subpatterns&nbsp;of&nbsp;the&nbsp;same&nbsp;number&nbsp;are
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;allowed
<BR>&nbsp;&nbsp;66&nbsp;&nbsp;(*MARK)&nbsp;must&nbsp;have&nbsp;an&nbsp;argument
<BR>&nbsp;&nbsp;67&nbsp;&nbsp;this&nbsp;version&nbsp;of&nbsp;PCRE&nbsp;is&nbsp;not&nbsp;compiled&nbsp;with&nbsp;Unicode&nbsp;property
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;support
<BR>&nbsp;&nbsp;68&nbsp;&nbsp;\c&nbsp;must&nbsp;be&nbsp;followed&nbsp;by&nbsp;an&nbsp;ASCII&nbsp;character
<BR>&nbsp;&nbsp;69&nbsp;&nbsp;\k&nbsp;is&nbsp;not&nbsp;followed&nbsp;by&nbsp;a&nbsp;braced,&nbsp;angle-bracketed,&nbsp;or&nbsp;quoted&nbsp;name
<BR>&nbsp;&nbsp;70&nbsp;&nbsp;internal&nbsp;error:&nbsp;unknown&nbsp;opcode&nbsp;in&nbsp;find_fixedlength()
<BR>&nbsp;&nbsp;71&nbsp;&nbsp;\N&nbsp;is&nbsp;not&nbsp;supported&nbsp;in&nbsp;a&nbsp;class
<BR>&nbsp;&nbsp;72&nbsp;&nbsp;too&nbsp;many&nbsp;forward&nbsp;references
<BR>&nbsp;&nbsp;73&nbsp;&nbsp;disallowed&nbsp;Unicode&nbsp;code&nbsp;point&nbsp;(&gt;=&nbsp;0xd800&nbsp;&amp;&amp;&nbsp;&lt;=&nbsp;0xdfff)
<BR>&nbsp;&nbsp;74&nbsp;&nbsp;invalid&nbsp;UTF-16&nbsp;string&nbsp;(specifically&nbsp;UTF-16)
<BR>&nbsp;&nbsp;75&nbsp;&nbsp;name&nbsp;is&nbsp;too&nbsp;long&nbsp;in&nbsp;(*MARK),&nbsp;(*PRUNE),&nbsp;(*SKIP),&nbsp;or&nbsp;(*THEN)
<BR>&nbsp;&nbsp;76&nbsp;&nbsp;character&nbsp;value&nbsp;in&nbsp;\u....&nbsp;sequence&nbsp;is&nbsp;too&nbsp;large
<BR>&nbsp;&nbsp;77&nbsp;&nbsp;invalid&nbsp;UTF-32&nbsp;string&nbsp;(specifically&nbsp;UTF-32)
<BR>&nbsp;&nbsp;78&nbsp;&nbsp;setting&nbsp;UTF&nbsp;is&nbsp;disabled&nbsp;by&nbsp;the&nbsp;application
<BR>&nbsp;&nbsp;79&nbsp;&nbsp;non-hex&nbsp;character&nbsp;in&nbsp;\x{}&nbsp;(closing&nbsp;brace&nbsp;missing?)
<BR>&nbsp;&nbsp;80&nbsp;&nbsp;non-octal&nbsp;character&nbsp;in&nbsp;\o{}&nbsp;(closing&nbsp;brace&nbsp;missing?)
<BR>&nbsp;&nbsp;81&nbsp;&nbsp;missing&nbsp;opening&nbsp;brace&nbsp;after&nbsp;\o
<BR>&nbsp;&nbsp;82&nbsp;&nbsp;parentheses&nbsp;are&nbsp;too&nbsp;deeply&nbsp;nested
<BR>&nbsp;&nbsp;83&nbsp;&nbsp;invalid&nbsp;range&nbsp;in&nbsp;character&nbsp;class
<BR>&nbsp;&nbsp;84&nbsp;&nbsp;group&nbsp;name&nbsp;must&nbsp;start&nbsp;with&nbsp;a&nbsp;non-digit
<BR>&nbsp;&nbsp;85&nbsp;&nbsp;parentheses&nbsp;are&nbsp;too&nbsp;deeply&nbsp;nested&nbsp;(stack&nbsp;check)
<P>
The numbers 32 and 10000 in errors 48 and 49 are defaults; different values may
be used if the limits were changed when PCRE was built.

<A NAME="lbAO">&nbsp;</A>
<H2>STUDYING A PATTERN</H2>


<P>
<PRE>
<B>pcre_extra *pcre_study(const pcre *</B><I>code</I>, int <I>options</I>,
<B>     const char **</B><I>errptr</I>);
</PRE>

<P>

If a compiled pattern is going to be used several times, it is worth spending
more time analyzing it in order to speed up the time taken for matching. The
function <B>pcre_study()</B> takes a pointer to a compiled pattern as its first
argument. If studying the pattern produces additional information that will
help speed up matching, <B>pcre_study()</B> returns a pointer to a
<B>pcre_extra</B> block, in which the <I>study_data</I> field points to the
results of the study.
<P>

The returned value from <B>pcre_study()</B> can be passed directly to
<B>pcre_exec()</B> or <B>pcre_dfa_exec()</B>. However, a <B>pcre_extra</B> block
also contains other fields that can be set by the caller before the block is
passed; these are described


below

in the section on matching a pattern.
<P>

If studying the pattern does not produce any useful information,
<B>pcre_study()</B> returns NULL by default. In that circumstance, if the
calling program wants to pass any of the other fields to <B>pcre_exec()</B> or
<B>pcre_dfa_exec()</B>, it must set up its own <B>pcre_extra</B> block. However,
if <B>pcre_study()</B> is called with the PCRE_STUDY_EXTRA_NEEDED option, it
returns a <B>pcre_extra</B> block even if studying did not find any additional
information. It may still return NULL, however, if an error occurs in
<B>pcre_study()</B>.
<P>

The second argument of <B>pcre_study()</B> contains option bits. There are three
further options in addition to PCRE_STUDY_EXTRA_NEEDED:
<P>
<BR>&nbsp;&nbsp;PCRE_STUDY_JIT_COMPILE
<BR>&nbsp;&nbsp;PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
<BR>&nbsp;&nbsp;PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
<P>
If any of these are set, and the just-in-time compiler is available, the
pattern is further compiled into machine code that executes much faster than
the <B>pcre_exec()</B> interpretive matching function. If the just-in-time
compiler is not available, these options are ignored. All undefined bits in the
<I>options</I> argument must be zero.
<P>

JIT compilation is a heavyweight optimization. It can take some time for
patterns to be analyzed, and for one-off matches and simple patterns the
benefit of faster execution might be offset by a much slower study time.
Not all patterns can be optimized by the JIT compiler. For those that cannot be
handled, matching automatically falls back to the <B>pcre_exec()</B>
interpreter. For more details, see the

<B>pcrejit</B>

documentation.
<P>

The third argument for <B>pcre_study()</B> is a pointer for an error message. If
studying succeeds (even if no data is returned), the variable it points to is
set to NULL. Otherwise it is set to point to a textual error message. This is a
static string that is part of the library. You must not try to free it. You
should test the error pointer for NULL after calling <B>pcre_study()</B>, to be
sure that it has run successfully.
<P>

When you are finished with a pattern, you can free the memory used for the
study data by calling <B>pcre_free_study()</B>. This function was added to the
API for release 8.20. For earlier versions, the memory could be freed with
<B>pcre_free()</B>, just like the pattern itself. This will still work in cases
where JIT optimization is not used, but it is advisable to change to the new
function when convenient.
<P>

This is a typical way in which <B>pcre_study</B>() is used (except that in a
real application there should be tests for errors):
<P>
<BR>&nbsp;&nbsp;int&nbsp;rc;
<BR>&nbsp;&nbsp;pcre&nbsp;*re;
<BR>&nbsp;&nbsp;pcre_extra&nbsp;*sd;
<BR>&nbsp;&nbsp;re&nbsp;=&nbsp;pcre_compile(&quot;pattern&quot;,&nbsp;0,&nbsp;&amp;error,&nbsp;&amp;erroroffset,&nbsp;NULL);
<BR>&nbsp;&nbsp;sd&nbsp;=&nbsp;pcre_study(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;no&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;error);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;set&nbsp;to&nbsp;NULL&nbsp;or&nbsp;points&nbsp;to&nbsp;a&nbsp;message&nbsp;*/
<BR>&nbsp;&nbsp;rc&nbsp;=&nbsp;pcre_exec(&nbsp;&nbsp;&nbsp;/*&nbsp;see&nbsp;below&nbsp;for&nbsp;details&nbsp;of&nbsp;pcre_exec()&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;sd,&nbsp;&quot;subject&quot;,&nbsp;7,&nbsp;0,&nbsp;0,&nbsp;ovector,&nbsp;30);
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;pcre_free_study(sd);
<BR>&nbsp;&nbsp;pcre_free(re);
<P>
Studying a pattern does two things: first, a lower bound for the length of
subject string that is needed to match the pattern is computed. This does not
mean that there are any strings of that length that match, but it does
guarantee that no shorter strings match. The value is used to avoid wasting
time by trying to match strings that are shorter than the lower bound. You can
find out the value in a calling program via the <B>pcre_fullinfo()</B> function.
<P>

Studying a pattern is also useful for non-anchored patterns that do not have a
single fixed starting character. A bitmap of possible starting bytes is
created. This speeds up finding a position in the subject at which to start
matching. (In 16-bit mode, the bitmap is used for 16-bit values less than 256.
In 32-bit mode, the bitmap is used for 32-bit values less than 256.)
<P>

These two optimizations apply to both <B>pcre_exec()</B> and
<B>pcre_dfa_exec()</B>, and the information is also used by the JIT compiler.
The optimizations can be disabled by setting the PCRE_NO_START_OPTIMIZE option.
You might want to do this if your pattern contains callouts or (*MARK) and you
want to make use of these facilities in cases where matching fails.
<P>

PCRE_NO_START_OPTIMIZE can be specified at either compile time or execution
time. However, if PCRE_NO_START_OPTIMIZE is passed to <B>pcre_exec()</B>, (that
is, after any JIT compilation has happened) JIT execution is disabled. For JIT
execution to work with PCRE_NO_START_OPTIMIZE, the option must be set at
compile time.
<P>

There is a longer discussion of PCRE_NO_START_OPTIMIZE


below.


<A NAME="lbAP">&nbsp;</A>
<H2>LOCALE SUPPORT</H2>


<P>
PCRE handles caseless matching, and determines whether characters are letters,
digits, or whatever, by reference to a set of tables, indexed by character
code point. When running in UTF-8 mode, or in the 16- or 32-bit libraries, this
applies only to characters with code points less than 256. By default,
higher-valued code points never match escapes such as \w or \d. However, if
PCRE is built with Unicode property support, all characters can be tested with
\p and \P, or, alternatively, the PCRE_UCP option can be set when a pattern
is compiled; this causes \w and friends to use Unicode property support
instead of the built-in tables.
<P>

The use of locales with Unicode is discouraged. If you are handling characters
with code points greater than 128, you should either use Unicode support, or
use locales, but not try to mix the two.
<P>

PCRE contains an internal set of tables that are used when the final argument
of <B>pcre_compile()</B> is NULL. These are sufficient for many applications.
Normally, the internal tables recognize only ASCII characters. However, when
PCRE is built, it is possible to cause the internal tables to be rebuilt in the
default &quot;C&quot; locale of the local system, which may cause them to be different.
<P>

The internal tables can always be overridden by tables supplied by the
application that calls PCRE. These may be created in a different locale from
the default. As more and more applications change to using Unicode, the need
for this locale support is expected to die away.
<P>

External tables are built by calling the <B>pcre_maketables()</B> function,
which has no arguments, in the relevant locale. The result can then be passed
to <B>pcre_compile()</B> as often as necessary. For example, to build and use
tables that are appropriate for the French locale (where accented characters
with values greater than 128 are treated as letters), the following code could
be used:
<P>
<BR>&nbsp;&nbsp;setlocale(LC_CTYPE,&nbsp;&quot;fr_FR&quot;);
<BR>&nbsp;&nbsp;tables&nbsp;=&nbsp;pcre_maketables();
<BR>&nbsp;&nbsp;re&nbsp;=&nbsp;pcre_compile(...,&nbsp;tables);
<P>
The locale name &quot;fr_FR&quot; is used on Linux and other Unix-like systems; if you
are using Windows, the name for the French locale is &quot;french&quot;.
<P>

When <B>pcre_maketables()</B> runs, the tables are built in memory that is
obtained via <B>pcre_malloc</B>. It is the caller's responsibility to ensure
that the memory containing the tables remains available for as long as it is
needed.
<P>

The pointer that is passed to <B>pcre_compile()</B> is saved with the compiled
pattern, and the same tables are used via this pointer by <B>pcre_study()</B>
and also by <B>pcre_exec()</B> and <B>pcre_dfa_exec()</B>. Thus, for any single
pattern, compilation, studying and matching all happen in the same locale, but
different patterns can be processed in different locales.
<P>

It is possible to pass a table pointer or NULL (indicating the use of the
internal tables) to <B>pcre_exec()</B> or <B>pcre_dfa_exec()</B> (see the
discussion below in the section on matching a pattern). This facility is
provided for use with pre-compiled patterns that have been saved and reloaded.
Character tables are not saved with patterns, so if a non-standard table was
used at compile time, it must be provided again when the reloaded pattern is
matched. Attempting to use this facility to match a pattern in a different
locale from the one in which it was compiled is likely to lead to anomalous
(usually incorrect) results.

<A NAME="lbAQ">&nbsp;</A>
<H2>INFORMATION ABOUT A PATTERN</H2>


<P>
<PRE>
<B>int pcre_fullinfo(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     int </B><I>what</I>, void *<I>where</I>);
</PRE>

<P>

The <B>pcre_fullinfo()</B> function returns information about a compiled
pattern. It replaces the <B>pcre_info()</B> function, which was removed from the
library at version 8.30, after more than 10 years of obsolescence.
<P>

The first argument for <B>pcre_fullinfo()</B> is a pointer to the compiled
pattern. The second argument is the result of <B>pcre_study()</B>, or NULL if
the pattern was not studied. The third argument specifies which piece of
information is required, and the fourth argument is a pointer to a variable
to receive the data. The yield of the function is zero for success, or one of
the following negative numbers:
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;argument&nbsp;<I>code</I>&nbsp;was&nbsp;NULL
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;argument&nbsp;<I>where</I>&nbsp;was&nbsp;NULL
<BR>&nbsp;&nbsp;PCRE_ERROR_BADMAGIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;&quot;magic&nbsp;number&quot;&nbsp;was&nbsp;not&nbsp;found
<BR>&nbsp;&nbsp;PCRE_ERROR_BADENDIANNESS&nbsp;&nbsp;the&nbsp;pattern&nbsp;was&nbsp;compiled&nbsp;with&nbsp;different
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endianness
<BR>&nbsp;&nbsp;PCRE_ERROR_BADOPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;value&nbsp;of&nbsp;<I>what</I>&nbsp;was&nbsp;invalid
<BR>&nbsp;&nbsp;PCRE_ERROR_UNSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;requested&nbsp;field&nbsp;is&nbsp;not&nbsp;set
<P>
The &quot;magic number&quot; is placed at the start of each compiled pattern as an simple
check against passing an arbitrary memory pointer. The endianness error can
occur if a compiled pattern is saved and reloaded on a different host. Here is
a typical call of <B>pcre_fullinfo()</B>, to obtain the length of the compiled
pattern:
<P>
<BR>&nbsp;&nbsp;int&nbsp;rc;
<BR>&nbsp;&nbsp;size_t&nbsp;length;
<BR>&nbsp;&nbsp;rc&nbsp;=&nbsp;pcre_fullinfo(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre_study(),&nbsp;or&nbsp;NULL&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;PCRE_INFO_SIZE,&nbsp;&nbsp;&nbsp;/*&nbsp;what&nbsp;is&nbsp;required&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;where&nbsp;to&nbsp;put&nbsp;the&nbsp;data&nbsp;*/
<P>
The possible values for the third argument are defined in <B>pcre.h</B>, and are
as follows:
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_BACKREFMAX
<P>
Return the number of the highest back reference in the pattern. The fourth
argument should point to an <B>int</B> variable. Zero is returned if there are
no back references.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_CAPTURECOUNT
<P>
Return the number of capturing subpatterns in the pattern. The fourth argument
should point to an <B>int</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_DEFAULT_TABLES
<P>
Return a pointer to the internal default character tables within PCRE. The
fourth argument should point to an <B>unsigned char *</B> variable. This
information call is provided for internal use by the <B>pcre_study()</B>
function. External callers can cause PCRE to use its internal tables by passing
a NULL table pointer.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_FIRSTBYTE&nbsp;(deprecated)
<P>
Return information about the first data unit of any matched string, for a
non-anchored pattern. The name of this option refers to the 8-bit library,
where data units are bytes. The fourth argument should point to an <B>int</B>
variable. Negative values are used for special cases. However, this means that
when the 32-bit library is in non-UTF-32 mode, the full 32-bit range of
characters cannot be returned. For this reason, this value is deprecated; use
PCRE_INFO_FIRSTCHARACTERFLAGS and PCRE_INFO_FIRSTCHARACTER instead.
<P>

If there is a fixed first value, for example, the letter &quot;c&quot; from a pattern
such as (cat|cow|coyote), its value is returned. In the 8-bit library, the
value is always less than 256. In the 16-bit library the value can be up to
0xffff. In the 32-bit library the value can be up to 0x10ffff.
<P>

If there is no fixed first value, and if either
<P>
(a) the pattern was compiled with the PCRE_MULTILINE option, and every branch
starts with &quot;^&quot;, or
<P>
(b) every branch of the pattern starts with &quot;.*&quot; and PCRE_DOTALL is not set
(if it were set, the pattern would be anchored),
<P>
-1 is returned, indicating that the pattern matches only at the start of a
subject string or after any newline within the string. Otherwise -2 is
returned. For anchored patterns, -2 is returned.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_FIRSTCHARACTER
<P>
Return the value of the first data unit (non-UTF character) of any matched
string in the situation where PCRE_INFO_FIRSTCHARACTERFLAGS returns 1;
otherwise return 0. The fourth argument should point to an <B>uint_t</B>
variable.
<P>

In the 8-bit library, the value is always less than 256. In the 16-bit library
the value can be up to 0xffff. In the 32-bit library in UTF-32 mode the value
can be up to 0x10ffff, and up to 0xffffffff when not using UTF-32 mode.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_FIRSTCHARACTERFLAGS
<P>
Return information about the first data unit of any matched string, for a
non-anchored pattern. The fourth argument should point to an <B>int</B>
variable.
<P>

If there is a fixed first value, for example, the letter &quot;c&quot; from a pattern
such as (cat|cow|coyote), 1 is returned, and the character value can be
retrieved using PCRE_INFO_FIRSTCHARACTER. If there is no fixed first value, and
if either
<P>
(a) the pattern was compiled with the PCRE_MULTILINE option, and every branch
starts with &quot;^&quot;, or
<P>
(b) every branch of the pattern starts with &quot;.*&quot; and PCRE_DOTALL is not set
(if it were set, the pattern would be anchored),
<P>
2 is returned, indicating that the pattern matches only at the start of a
subject string or after any newline within the string. Otherwise 0 is
returned. For anchored patterns, 0 is returned.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_FIRSTTABLE
<P>
If the pattern was studied, and this resulted in the construction of a 256-bit
table indicating a fixed set of values for the first data unit in any matching
string, a pointer to the table is returned. Otherwise NULL is returned. The
fourth argument should point to an <B>unsigned char *</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_HASCRORLF
<P>
Return 1 if the pattern contains any explicit matches for CR or LF characters,
otherwise 0. The fourth argument should point to an <B>int</B> variable. An
explicit match is either a literal CR or LF character, or \r or \n.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_JCHANGED
<P>
Return 1 if the (?J) or (?-J) option setting is used in the pattern, otherwise
0. The fourth argument should point to an <B>int</B> variable. (?J) and
(?-J) set and unset the local PCRE_DUPNAMES option, respectively.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_JIT
<P>
Return 1 if the pattern was studied with one of the JIT options, and
just-in-time compiling was successful. The fourth argument should point to an
<B>int</B> variable. A return value of 0 means that JIT support is not available
in this version of PCRE, or that the pattern was not studied with a JIT option,
or that the JIT compiler could not handle this particular pattern. See the

<B>pcrejit</B>

documentation for details of what can and cannot be handled.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_JITSIZE
<P>
If the pattern was successfully studied with a JIT option, return the size of
the JIT compiled code, otherwise return zero. The fourth argument should point
to a <B>size_t</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_LASTLITERAL
<P>
Return the value of the rightmost literal data unit that must exist in any
matched string, other than at its start, if such a value has been recorded. The
fourth argument should point to an <B>int</B> variable. If there is no such
value, -1 is returned. For anchored patterns, a last literal value is recorded
only if it follows something of variable length. For example, for the pattern
/^a\d+z\d+/ the returned value is &quot;z&quot;, but for /^a\dz\d/ the returned value
is -1.
<P>

Since for the 32-bit library using the non-UTF-32 mode, this function is unable
to return the full 32-bit range of characters, this value is deprecated;
instead the PCRE_INFO_REQUIREDCHARFLAGS and PCRE_INFO_REQUIREDCHAR values should
be used.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_MATCH_EMPTY
<P>
Return 1 if the pattern can match an empty string, otherwise 0. The fourth
argument should point to an <B>int</B> variable.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_MATCHLIMIT
<P>
If the pattern set a match limit by including an item of the form
(*LIMIT_MATCH=nnnn) at the start, the value is returned. The fourth argument
should point to an unsigned 32-bit integer. If no such value has been set, the
call to <B>pcre_fullinfo()</B> returns the error PCRE_ERROR_UNSET.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_MAXLOOKBEHIND
<P>
Return the number of characters (NB not data units) in the longest lookbehind
assertion in the pattern. This information is useful when doing multi-segment
matching using the partial matching facilities. Note that the simple assertions
\b and \B require a one-character lookbehind. \A also registers a
one-character lookbehind, though it does not actually inspect the previous
character. This is to ensure that at least one character from the old segment
is retained when a new segment is processed. Otherwise, if there are no
lookbehinds in the pattern, \A might match incorrectly at the start of a new
segment.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_MINLENGTH
<P>
If the pattern was studied and a minimum length for matching subject strings
was computed, its value is returned. Otherwise the returned value is -1. The
value is a number of characters, which in UTF mode may be different from the
number of data units. The fourth argument should point to an <B>int</B>
variable. A non-negative value is a lower bound to the length of any matching
string. There may not be any strings of that length that do actually match, but
every string that does match is at least that long.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_NAMECOUNT
<BR>&nbsp;&nbsp;PCRE_INFO_NAMEENTRYSIZE
<BR>&nbsp;&nbsp;PCRE_INFO_NAMETABLE
<P>
PCRE supports the use of named as well as numbered capturing parentheses. The
names are just an additional way of identifying the parentheses, which still
acquire numbers. Several convenience functions such as
<B>pcre_get_named_substring()</B> are provided for extracting captured
substrings by name. It is also possible to extract the data directly, by first
converting the name to a number in order to access the correct pointers in the
output vector (described with <B>pcre_exec()</B> below). To do the conversion,
you need to use the name-to-number map, which is described by these three
values.
<P>

The map consists of a number of fixed-size entries. PCRE_INFO_NAMECOUNT gives
the number of entries, and PCRE_INFO_NAMEENTRYSIZE gives the size of each
entry; both of these return an <B>int</B> value. The entry size depends on the
length of the longest name. PCRE_INFO_NAMETABLE returns a pointer to the first
entry of the table. This is a pointer to <B>char</B> in the 8-bit library, where
the first two bytes of each entry are the number of the capturing parenthesis,
most significant byte first. In the 16-bit library, the pointer points to
16-bit data units, the first of which contains the parenthesis number. In the
32-bit library, the pointer points to 32-bit data units, the first of which
contains the parenthesis number. The rest of the entry is the corresponding
name, zero terminated.
<P>

The names are in alphabetical order. If (?| is used to create multiple groups
with the same number, as described in the


section on duplicate subpattern numbers

in the

<B>pcrepattern</B>

page, the groups may be given the same name, but there is only one entry in the
table. Different names for groups of the same number are not permitted.
Duplicate names for subpatterns with different numbers are permitted,
but only if PCRE_DUPNAMES is set. They appear in the table in the order in
which they were found in the pattern. In the absence of (?| this is the order
of increasing number; when (?| is used this is not necessarily the case because
later subpatterns may have lower numbers.
<P>

As a simple example of the name/number table, consider the following pattern
after compilation by the 8-bit library (assume PCRE_EXTENDED is set, so white
space - including newlines - is ignored):
<P>

<BR>&nbsp;&nbsp;(?&lt;date&gt;&nbsp;(?&lt;year&gt;(\d\d)?\d\d)&nbsp;-
<BR>&nbsp;&nbsp;(?&lt;month&gt;\d\d)&nbsp;-&nbsp;(?&lt;day&gt;\d\d)&nbsp;)
<P>
There are four named subpatterns, so the table has four entries, and each entry
in the table is eight bytes long. The table is as follows, with non-printing
bytes shows in hexadecimal, and undefined bytes shown as ??:
<P>
<BR>&nbsp;&nbsp;00&nbsp;01&nbsp;d&nbsp;&nbsp;a&nbsp;&nbsp;t&nbsp;&nbsp;e&nbsp;&nbsp;00&nbsp;??
<BR>&nbsp;&nbsp;00&nbsp;05&nbsp;d&nbsp;&nbsp;a&nbsp;&nbsp;y&nbsp;&nbsp;00&nbsp;??&nbsp;??
<BR>&nbsp;&nbsp;00&nbsp;04&nbsp;m&nbsp;&nbsp;o&nbsp;&nbsp;n&nbsp;&nbsp;t&nbsp;&nbsp;h&nbsp;&nbsp;00
<BR>&nbsp;&nbsp;00&nbsp;02&nbsp;y&nbsp;&nbsp;e&nbsp;&nbsp;a&nbsp;&nbsp;r&nbsp;&nbsp;00&nbsp;??
<P>
When writing code to extract data from named subpatterns using the
name-to-number map, remember that the length of the entries is likely to be
different for each compiled pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_OKPARTIAL
<P>
Return 1 if the pattern can be used for partial matching with
<B>pcre_exec()</B>, otherwise 0. The fourth argument should point to an
<B>int</B> variable. From release 8.00, this always returns 1, because the
restrictions that previously applied to partial matching have been lifted. The

<B>pcrepartial</B>

documentation gives details of partial matching.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_OPTIONS
<P>
Return a copy of the options with which the pattern was compiled. The fourth
argument should point to an <B>unsigned long int</B> variable. These option bits
are those specified in the call to <B>pcre_compile()</B>, modified by any
top-level option settings at the start of the pattern itself. In other words,
they are the options that will be in force when matching starts. For example,
if the pattern /(?im)abc(?-i)d/ is compiled with the PCRE_EXTENDED option, the
result is PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.
<P>

A pattern is automatically anchored by PCRE if all of its top-level
alternatives begin with one of the following:
<P>
<BR>&nbsp;&nbsp;^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless&nbsp;PCRE_MULTILINE&nbsp;is&nbsp;set
<BR>&nbsp;&nbsp;\A&nbsp;&nbsp;&nbsp;&nbsp;always
<BR>&nbsp;&nbsp;\G&nbsp;&nbsp;&nbsp;&nbsp;always

<BR>&nbsp;&nbsp;.*&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;PCRE_DOTALL&nbsp;is&nbsp;set&nbsp;and&nbsp;there&nbsp;are&nbsp;no&nbsp;back
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;references&nbsp;to&nbsp;the&nbsp;subpattern&nbsp;in&nbsp;which&nbsp;.*&nbsp;appears
<P>
For such patterns, the PCRE_ANCHORED bit is set in the options returned by
<B>pcre_fullinfo()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_RECURSIONLIMIT
<P>
If the pattern set a recursion limit by including an item of the form
(*LIMIT_RECURSION=nnnn) at the start, the value is returned. The fourth
argument should point to an unsigned 32-bit integer. If no such value has been
set, the call to <B>pcre_fullinfo()</B> returns the error PCRE_ERROR_UNSET.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_SIZE
<P>
Return the size of the compiled pattern in bytes (for all three libraries). The
fourth argument should point to a <B>size_t</B> variable. This value does not
include the size of the <B>pcre</B> structure that is returned by
<B>pcre_compile()</B>. The value that is passed as the argument to
<B>pcre_malloc()</B> when <B>pcre_compile()</B> is getting memory in which to
place the compiled data is the value returned by this option plus the size of
the <B>pcre</B> structure. Studying a compiled pattern, with or without JIT,
does not alter the value returned by this option.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_STUDYSIZE
<P>
Return the size in bytes (for all three libraries) of the data block pointed to
by the <I>study_data</I> field in a <B>pcre_extra</B> block. If <B>pcre_extra</B>
is NULL, or there is no study data, zero is returned. The fourth argument
should point to a <B>size_t</B> variable. The <I>study_data</I> field is set by
<B>pcre_study()</B> to record information that will speed up matching (see the
section entitled


&quot;Studying a pattern&quot;

above). The format of the <I>study_data</I> block is private, but its length
is made available via this option so that it can be saved and restored (see the

<B>pcreprecompile</B>

documentation for details).
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_REQUIREDCHARFLAGS
<P>
Returns 1 if there is a rightmost literal data unit that must exist in any
matched string, other than at its start. The fourth argument should  point to
an <B>int</B> variable. If there is no such value, 0 is returned. If returning
1, the character value itself can be retrieved using PCRE_INFO_REQUIREDCHAR.
<P>

For anchored patterns, a last literal value is recorded only if it follows
something of variable length. For example, for the pattern /^a\d+z\d+/ the
returned value 1 (with &quot;z&quot; returned from PCRE_INFO_REQUIREDCHAR), but for
/^a\dz\d/ the returned value is 0.
<P>
<BR>&nbsp;&nbsp;PCRE_INFO_REQUIREDCHAR
<P>
Return the value of the rightmost literal data unit that must exist in any
matched string, other than at its start, if such a value has been recorded. The
fourth argument should point to an <B>uint32_t</B> variable. If there is no such
value, 0 is returned.
<A NAME="lbAR">&nbsp;</A>
<H2>REFERENCE COUNTS</H2>


<P>
<B>int pcre_refcount(pcre *</B><I>code</I>, int <I>adjust</I>);

<P>

The <B>pcre_refcount()</B> function is used to maintain a reference count in the
data block that contains a compiled pattern. It is provided for the benefit of
applications that operate in an object-oriented manner, where different parts
of the application may be using the same compiled pattern, but you want to free
the block when they are all done.
<P>

When a pattern is compiled, the reference count field is initialized to zero.
It is changed only by calling this function, whose action is to add the
<I>adjust</I> value (which may be positive or negative) to it. The yield of the
function is the new value. However, the value of the count is constrained to
lie between 0 and 65535, inclusive. If the new value is outside these limits,
it is forced to the appropriate limit value.
<P>

Except when it is zero, the reference count is not correctly preserved if a
pattern is compiled on one host and then transferred to a host whose byte-order
is different. (This seems a highly unlikely scenario.)
<A NAME="lbAS">&nbsp;</A>
<H2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</H2>


<P>
<PRE>
<B>int pcre_exec(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     const char *</B><I>subject</I>, int <I>length</I>, int <I>startoffset</I>,
<B>     int </B><I>options</I>, int *<I>ovector</I>, int <I>ovecsize</I>);
</PRE>

<P>

The function <B>pcre_exec()</B> is called to match a subject string against a
compiled pattern, which is passed in the <I>code</I> argument. If the
pattern was studied, the result of the study should be passed in the
<I>extra</I> argument. You can call <B>pcre_exec()</B> with the same <I>code</I>
and <I>extra</I> arguments as many times as you like, in order to match
different subject strings with the same pattern.
<P>

This function is the main matching facility of the library, and it operates in
a Perl-like manner. For specialist use there is also an alternative matching
function, which is described


below

in the section about the <B>pcre_dfa_exec()</B> function.
<P>

In most applications, the pattern will have been compiled (and optionally
studied) in the same process that calls <B>pcre_exec()</B>. However, it is
possible to save compiled patterns and study data, and then use them later
in different processes, possibly even on different hosts. For a discussion
about this, see the

<B>pcreprecompile</B>

documentation.
<P>

Here is an example of a simple call to <B>pcre_exec()</B>:
<P>
<BR>&nbsp;&nbsp;int&nbsp;rc;
<BR>&nbsp;&nbsp;int&nbsp;ovector[30];
<BR>&nbsp;&nbsp;rc&nbsp;=&nbsp;pcre_exec(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;we&nbsp;didn't&nbsp;study&nbsp;the&nbsp;pattern&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;some&nbsp;string&quot;,&nbsp;&nbsp;/*&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;11,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start&nbsp;at&nbsp;offset&nbsp;0&nbsp;in&nbsp;the&nbsp;subject&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ovector,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;vector&nbsp;of&nbsp;integers&nbsp;for&nbsp;substring&nbsp;information&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;30);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;elements&nbsp;(NOT&nbsp;size&nbsp;in&nbsp;bytes)&nbsp;*/

<A NAME="lbAT">&nbsp;</A>
<H3>Extra data for <B>pcre_exec()</B></H3>


<P>
If the <I>extra</I> argument is not NULL, it must point to a <B>pcre_extra</B>
data block. The <B>pcre_study()</B> function returns such a block (when it
doesn't return NULL), but you can also create one for yourself, and pass
additional information in it. The <B>pcre_extra</B> block contains the following
fields (not necessarily in this order):
<P>
<BR>&nbsp;&nbsp;unsigned&nbsp;long&nbsp;int&nbsp;<I>flags</I>;
<BR>&nbsp;&nbsp;void&nbsp;*<I>study_data</I>;
<BR>&nbsp;&nbsp;void&nbsp;*<I>executable_jit</I>;
<BR>&nbsp;&nbsp;unsigned&nbsp;long&nbsp;int&nbsp;<I>match_limit</I>;
<BR>&nbsp;&nbsp;unsigned&nbsp;long&nbsp;int&nbsp;<I>match_limit_recursion</I>;
<BR>&nbsp;&nbsp;void&nbsp;*<I>callout_data</I>;
<BR>&nbsp;&nbsp;const&nbsp;unsigned&nbsp;char&nbsp;*<I>tables</I>;
<BR>&nbsp;&nbsp;unsigned&nbsp;char&nbsp;**<I>mark</I>;
<P>
In the 16-bit version of this structure, the <I>mark</I> field has type
&quot;PCRE_UCHAR16 **&quot;.
<P>
In the 32-bit version of this structure, the <I>mark</I> field has type
&quot;PCRE_UCHAR32 **&quot;.
<P>

The <I>flags</I> field is used to specify which of the other fields are set. The
flag bits are:
<P>
<BR>&nbsp;&nbsp;PCRE_EXTRA_CALLOUT_DATA
<BR>&nbsp;&nbsp;PCRE_EXTRA_EXECUTABLE_JIT
<BR>&nbsp;&nbsp;PCRE_EXTRA_MARK
<BR>&nbsp;&nbsp;PCRE_EXTRA_MATCH_LIMIT
<BR>&nbsp;&nbsp;PCRE_EXTRA_MATCH_LIMIT_RECURSION
<BR>&nbsp;&nbsp;PCRE_EXTRA_STUDY_DATA
<BR>&nbsp;&nbsp;PCRE_EXTRA_TABLES
<P>
Other flag bits should be set to zero. The <I>study_data</I> field and sometimes
the <I>executable_jit</I> field are set in the <B>pcre_extra</B> block that is
returned by <B>pcre_study()</B>, together with the appropriate flag bits. You
should not set these yourself, but you may add to the block by setting other
fields and their corresponding flag bits.
<P>

The <I>match_limit</I> field provides a means of preventing PCRE from using up a
vast amount of resources when running patterns that are not going to match,
but which have a very large number of possibilities in their search trees. The
classic example is a pattern that uses nested unlimited repeats.
<P>

Internally, <B>pcre_exec()</B> uses a function called <B>match()</B>, which it
calls repeatedly (sometimes recursively). The limit set by <I>match_limit</I> is
imposed on the number of times this function is called during a match, which
has the effect of limiting the amount of backtracking that can take place. For
patterns that are not anchored, the count restarts from zero for each position
in the subject string.
<P>

When <B>pcre_exec()</B> is called with a pattern that was successfully studied
with a JIT option, the way that the matching is executed is entirely different.
However, there is still the possibility of runaway matching that goes on for a
very long time, and so the <I>match_limit</I> value is also used in this case
(but in a different way) to limit how long the matching can continue.
<P>

The default value for the limit can be set when PCRE is built; the default
default is 10 million, which handles all but the most extreme cases. You can
override the default by suppling <B>pcre_exec()</B> with a <B>pcre_extra</B>
block in which <I>match_limit</I> is set, and PCRE_EXTRA_MATCH_LIMIT is set in
the <I>flags</I> field. If the limit is exceeded, <B>pcre_exec()</B> returns
PCRE_ERROR_MATCHLIMIT.
<P>

A value for the match limit may also be supplied by an item at the start of a
pattern of the form
<P>
<BR>&nbsp;&nbsp;(*LIMIT_MATCH=d)
<P>
where d is a decimal number. However, such a setting is ignored unless d is
less than the limit set by the caller of <B>pcre_exec()</B> or, if no such limit
is set, less than the default.
<P>

The <I>match_limit_recursion</I> field is similar to <I>match_limit</I>, but
instead of limiting the total number of times that <B>match()</B> is called, it
limits the depth of recursion. The recursion depth is a smaller number than the
total number of calls, because not all calls to <B>match()</B> are recursive.
This limit is of use only if it is set smaller than <I>match_limit</I>.
<P>

Limiting the recursion depth limits the amount of machine stack that can be
used, or, when PCRE has been compiled to use memory on the heap instead of the
stack, the amount of heap memory that can be used. This limit is not relevant,
and is ignored, when matching is done using JIT compiled code.
<P>

The default value for <I>match_limit_recursion</I> can be set when PCRE is
built; the default default is the same value as the default for
<I>match_limit</I>. You can override the default by suppling <B>pcre_exec()</B>
with a <B>pcre_extra</B> block in which <I>match_limit_recursion</I> is set, and
PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the <I>flags</I> field. If the limit
is exceeded, <B>pcre_exec()</B> returns PCRE_ERROR_RECURSIONLIMIT.
<P>

A value for the recursion limit may also be supplied by an item at the start of
a pattern of the form
<P>
<BR>&nbsp;&nbsp;(*LIMIT_RECURSION=d)
<P>
where d is a decimal number. However, such a setting is ignored unless d is
less than the limit set by the caller of <B>pcre_exec()</B> or, if no such limit
is set, less than the default.
<P>

The <I>callout_data</I> field is used in conjunction with the &quot;callout&quot; feature,
and is described in the

<B>pcrecallout</B>

documentation.
<P>

The <I>tables</I> field is provided for use with patterns that have been
pre-compiled using custom character tables, saved to disc or elsewhere, and
then reloaded, because the tables that were used to compile a pattern are not
saved with it. See the

<B>pcreprecompile</B>

documentation for a discussion of saving compiled patterns for later use. If
NULL is passed using this mechanism, it forces PCRE's internal tables to be
used.
<P>

<B>Warning:</B> The tables that <B>pcre_exec()</B> uses must be the same as those
that were used when the pattern was compiled. If this is not the case, the
behaviour of <B>pcre_exec()</B> is undefined. Therefore, when a pattern is
compiled and matched in the same process, this field should never be set. In
this (the most common) case, the correct table pointer is automatically passed
with the compiled pattern from <B>pcre_compile()</B> to <B>pcre_exec()</B>.
<P>

If PCRE_EXTRA_MARK is set in the <I>flags</I> field, the <I>mark</I> field must
be set to point to a suitable variable. If the pattern contains any
backtracking control verbs such as (*MARK:NAME), and the execution ends up with
a name to pass back, a pointer to the name string (zero terminated) is placed
in the variable pointed to by the <I>mark</I> field. The names are within the
compiled pattern; if you wish to retain such a name you must copy it before
freeing the memory of a compiled pattern. If there is no name to pass back, the
variable pointed to by the <I>mark</I> field is set to NULL. For details of the
backtracking control verbs, see the section entitled


&quot;Backtracking control&quot;

in the

<B>pcrepattern</B>

documentation.

<A NAME="lbAU">&nbsp;</A>
<H3>Option bits for <B>pcre_exec()</B></H3>


<P>
The unused bits of the <I>options</I> argument for <B>pcre_exec()</B> must be
zero. The only bits that may be set are PCRE_ANCHORED, PCRE_NEWLINE_<I>xxx</I>,
PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_START_OPTIMIZE, PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_HARD, and
PCRE_PARTIAL_SOFT.
<P>

If the pattern was successfully studied with one of the just-in-time (JIT)
compile options, the only supported options for JIT execution are
PCRE_NO_UTF8_CHECK, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and PCRE_PARTIAL_SOFT. If an
unsupported option is used, JIT execution is disabled and the normal
interpretive code in <B>pcre_exec()</B> is run.
<P>
<BR>&nbsp;&nbsp;PCRE_ANCHORED
<P>
The PCRE_ANCHORED option limits <B>pcre_exec()</B> to matching at the first
matching position. If a pattern was compiled with PCRE_ANCHORED, or turned out
to be anchored by virtue of its contents, it cannot be made unachored at
matching time.
<P>
<BR>&nbsp;&nbsp;PCRE_BSR_ANYCRLF
<BR>&nbsp;&nbsp;PCRE_BSR_UNICODE
<P>
These options (which are mutually exclusive) control what the \R escape
sequence matches. The choice is either to match only CR, LF, or CRLF, or to
match any Unicode newline sequence. These options override the choice that was
made or defaulted when the pattern was compiled.
<P>
<BR>&nbsp;&nbsp;PCRE_NEWLINE_CR
<BR>&nbsp;&nbsp;PCRE_NEWLINE_LF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_CRLF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_ANYCRLF
<BR>&nbsp;&nbsp;PCRE_NEWLINE_ANY
<P>
These options override the newline definition that was chosen or defaulted when
the pattern was compiled. For details, see the description of
<B>pcre_compile()</B> above. During matching, the newline choice affects the
behaviour of the dot, circumflex, and dollar metacharacters. It may also alter
the way the match position is advanced after a match failure for an unanchored
pattern.
<P>

When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or PCRE_NEWLINE_ANY is set, and a
match attempt for an unanchored pattern fails when the current position is at a
CRLF sequence, and the pattern contains no explicit matches for CR or LF
characters, the match position is advanced by two characters instead of one, in
other words, to after the CRLF.
<P>

The above rule is a compromise that makes the most common cases work as
expected. For example, if the pattern is .+A (and the PCRE_DOTALL option is not
set), it does not match the string &quot;\r\nA&quot; because, after failing at the
start, it skips both the CR and the LF before retrying. However, the pattern
[\r\n]A does match that string, because it contains an explicit CR or LF
reference, and so advances only by one character after the first failure.
<P>

An explicit match for CR of LF is either a literal appearance of one of those
characters, or one of the \r or \n escape sequences. Implicit matches such as
[^X] do not count, nor does \s (which includes CR and LF in the characters
that it matches).
<P>

Notwithstanding the above, anomalous effects may still occur when CRLF is a
valid newline sequence and explicit \r or \n escapes appear in the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_NOTBOL
<P>
This option specifies that first character of the subject string is not the
beginning of a line, so the circumflex metacharacter should not match before
it. Setting this without PCRE_MULTILINE (at compile time) causes circumflex
never to match. This option affects only the behaviour of the circumflex
metacharacter. It does not affect \A.
<P>
<BR>&nbsp;&nbsp;PCRE_NOTEOL
<P>
This option specifies that the end of the subject string is not the end of a
line, so the dollar metacharacter should not match it nor (except in multiline
mode) a newline immediately before it. Setting this without PCRE_MULTILINE (at
compile time) causes dollar never to match. This option affects only the
behaviour of the dollar metacharacter. It does not affect \Z or \z.
<P>
<BR>&nbsp;&nbsp;PCRE_NOTEMPTY
<P>
An empty string is not considered to be a valid match if this option is set. If
there are alternatives in the pattern, they are tried. If all the alternatives
match the empty string, the entire match fails. For example, if the pattern
<P>
<BR>&nbsp;&nbsp;a?b?
<P>
is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it matches an empty
string at the start of the subject. With PCRE_NOTEMPTY set, this match is not
valid, so PCRE searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.
<P>
<BR>&nbsp;&nbsp;PCRE_NOTEMPTY_ATSTART
<P>
This is like PCRE_NOTEMPTY, except that an empty string match that is not at
the start of the subject is permitted. If the pattern is anchored, such a match
can occur only if the pattern contains \K.
<P>

Perl has no direct equivalent of PCRE_NOTEMPTY or PCRE_NOTEMPTY_ATSTART, but it
does make a special case of a pattern match of the empty string within its
<B>split()</B> function, and when using the /g modifier. It is possible to
emulate Perl's behaviour after matching a null string by first trying the match
again at the same offset with PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED, and then
if that fails, by advancing the starting offset (see below) and trying an
ordinary match again. There is some code that demonstrates how to do this in
the

<B>pcredemo</B>

sample program. In the most general case, you have to check to see if the
newline convention recognizes CRLF as a newline, and if so, and the current
character is CR followed by LF, advance the starting offset by two characters
instead of one.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_START_OPTIMIZE
<P>
There are a number of optimizations that <B>pcre_exec()</B> uses at the start of
a match, in order to speed up the process. For example, if it is known that an
unanchored match must start with a specific character, it searches the subject
for that character, and fails immediately if it cannot find it, without
actually running the main matching function. This means that a special item
such as (*COMMIT) at the start of a pattern is not considered until after a
suitable starting point for the match has been found. Also, when callouts or
(*MARK) items are in use, these &quot;start-up&quot; optimizations can cause them to be
skipped if the pattern is never actually used. The start-up optimizations are
in effect a pre-scan of the subject that takes place before the pattern is run.
<P>

The PCRE_NO_START_OPTIMIZE option disables the start-up optimizations, possibly
causing performance to suffer, but ensuring that in cases where the result is
&quot;no match&quot;, the callouts do occur, and that items such as (*COMMIT) and (*MARK)
are considered at every possible starting position in the subject string. If
PCRE_NO_START_OPTIMIZE is set at compile time, it cannot be unset at matching
time. The use of PCRE_NO_START_OPTIMIZE at matching time (that is, passing it
to <B>pcre_exec()</B>) disables JIT execution; in this situation, matching is
always done using interpretively.
<P>

Setting PCRE_NO_START_OPTIMIZE can change the outcome of a matching operation.
Consider the pattern
<P>
<BR>&nbsp;&nbsp;(*COMMIT)ABC
<P>
When this is compiled, PCRE records the fact that a match must start with the
character &quot;A&quot;. Suppose the subject string is &quot;DEFABC&quot;. The start-up
optimization scans along the subject, finds &quot;A&quot; and runs the first match
attempt from there. The (*COMMIT) item means that the pattern must match the
current starting position, which in this case, it does. However, if the same
match is run with PCRE_NO_START_OPTIMIZE set, the initial scan along the
subject string does not happen. The first match attempt is run starting from
&quot;D&quot; and when this fails, (*COMMIT) prevents any further matches being tried, so
the overall result is &quot;no match&quot;. If the pattern is studied, more start-up
optimizations may be used. For example, a minimum length for the subject may be
recorded. Consider the pattern
<P>
<BR>&nbsp;&nbsp;(*MARK:A)(X|Y)
<P>
The minimum length for a match is one character. If the subject is &quot;ABC&quot;, there
will be attempts to match &quot;ABC&quot;, &quot;BC&quot;, &quot;C&quot;, and then finally an empty string.
If the pattern is studied, the final attempt does not take place, because PCRE
knows that the subject is too short, and so the (*MARK) is never encountered.
In this case, studying the pattern does not affect the overall match result,
which is still &quot;no match&quot;, but it does affect the auxiliary information that is
returned.
<P>
<BR>&nbsp;&nbsp;PCRE_NO_UTF8_CHECK
<P>
When PCRE_UTF8 is set at compile time, the validity of the subject as a UTF-8
string is automatically checked when <B>pcre_exec()</B> is subsequently called.
The entire string is checked before any other processing takes place. The value
of <I>startoffset</I> is also checked to ensure that it points to the start of a
UTF-8 character. There is a discussion about the


validity of UTF-8 strings

in the

<B>pcreunicode</B>

page. If an invalid sequence of bytes is found, <B>pcre_exec()</B> returns the
error PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is set and the problem is a
truncated character at the end of the subject, PCRE_ERROR_SHORTUTF8. In both
cases, information about the precise nature of the error may also be returned
(see the descriptions of these errors in the section entitled <I>Error return
values from</I> <B>pcre_exec()</B>


below).

If <I>startoffset</I> contains a value that does not point to the start of a
UTF-8 character (or to the end of the subject), PCRE_ERROR_BADUTF8_OFFSET is
returned.
<P>

If you already know that your subject is valid, and you want to skip these
checks for performance reasons, you can set the PCRE_NO_UTF8_CHECK option when
calling <B>pcre_exec()</B>. You might want to do this for the second and
subsequent calls to <B>pcre_exec()</B> if you are making repeated calls to find
all the matches in a single subject string. However, you should be sure that
the value of <I>startoffset</I> points to the start of a character (or the end
of the subject). When PCRE_NO_UTF8_CHECK is set, the effect of passing an
invalid string as a subject or an invalid value of <I>startoffset</I> is
undefined. Your program may crash or loop.
<P>
<BR>&nbsp;&nbsp;PCRE_PARTIAL_HARD
<BR>&nbsp;&nbsp;PCRE_PARTIAL_SOFT
<P>
These options turn on the partial matching feature. For backwards
compatibility, PCRE_PARTIAL is a synonym for PCRE_PARTIAL_SOFT. A partial match
occurs if the end of the subject string is reached successfully, but there are
not enough subject characters to complete the match. If this happens when
PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD) is set, matching continues by
testing any remaining alternatives. Only if no complete match can be found is
PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH. In other words,
PCRE_PARTIAL_SOFT says that the caller is prepared to handle a partial match,
but only if no complete match can be found.
<P>

If PCRE_PARTIAL_HARD is set, it overrides PCRE_PARTIAL_SOFT. In this case, if a
partial match is found, <B>pcre_exec()</B> immediately returns
PCRE_ERROR_PARTIAL, without considering any other alternatives. In other words,
when PCRE_PARTIAL_HARD is set, a partial match is considered to be more
important that an alternative complete match.
<P>

In both cases, the portion of the string that was inspected when the partial
match was found is set as the first matching string. There is a more detailed
discussion of partial and multi-segment matching, with examples, in the

<B>pcrepartial</B>

documentation.
<A NAME="lbAV">&nbsp;</A>
<H3>The string to be matched by <B>pcre_exec()</B></H3>


<P>
The subject string is passed to <B>pcre_exec()</B> as a pointer in
<I>subject</I>, a length in <I>length</I>, and a starting offset in
<I>startoffset</I>. The units for <I>length</I> and <I>startoffset</I> are bytes
for the 8-bit library, 16-bit data items for the 16-bit library, and 32-bit
data items for the 32-bit library.
<P>

If <I>startoffset</I> is negative or greater than the length of the subject,
<B>pcre_exec()</B> returns PCRE_ERROR_BADOFFSET. When the starting offset is
zero, the search for a match starts at the beginning of the subject, and this
is by far the most common case. In UTF-8 or UTF-16 mode, the offset must point
to the start of a character, or the end of the subject (in UTF-32 mode, one
data unit equals one character, so all offsets are valid). Unlike the pattern
string, the subject may contain binary zeroes.
<P>

A non-zero starting offset is useful when searching for another match in the
same subject by calling <B>pcre_exec()</B> again after a previous success.
Setting <I>startoffset</I> differs from just passing over a shortened string and
setting PCRE_NOTBOL in the case of a pattern that begins with any kind of
lookbehind. For example, consider the pattern
<P>
<BR>&nbsp;&nbsp;\Biss\B
<P>
which finds occurrences of &quot;iss&quot; in the middle of words. (\B matches only if
the current position in the subject is not a word boundary.) When applied to
the string &quot;Mississipi&quot; the first call to <B>pcre_exec()</B> finds the first
occurrence. If <B>pcre_exec()</B> is called again with just the remainder of the
subject, namely &quot;issipi&quot;, it does not match, because \B is always false at the
start of the subject, which is deemed to be a word boundary. However, if
<B>pcre_exec()</B> is passed the entire string again, but with <I>startoffset</I>
set to 4, it finds the second occurrence of &quot;iss&quot; because it is able to look
behind the starting point to discover that it is preceded by a letter.
<P>

Finding all the matches in a subject is tricky when the pattern can match an
empty string. It is possible to emulate Perl's /g behaviour by first trying the
match again at the same offset, with the PCRE_NOTEMPTY_ATSTART and
PCRE_ANCHORED options, and then if that fails, advancing the starting offset
and trying an ordinary match again. There is some code that demonstrates how to
do this in the

<B>pcredemo</B>

sample program. In the most general case, you have to check to see if the
newline convention recognizes CRLF as a newline, and if so, and the current
character is CR followed by LF, advance the starting offset by two characters
instead of one.
<P>

If a non-zero starting offset is passed when the pattern is anchored, one
attempt to match at the given offset is made. This can only succeed if the
pattern does not require the match to be at the start of the subject.
<A NAME="lbAW">&nbsp;</A>
<H3>How <B>pcre_exec()</B> returns captured substrings</H3>


<P>
In general, a pattern matches a certain portion of the subject, and in
addition, further substrings from the subject may be picked out by parts of the
pattern. Following the usage in Jeffrey Friedl's book, this is called
&quot;capturing&quot; in what follows, and the phrase &quot;capturing subpattern&quot; is used for
a fragment of a pattern that picks out a substring. PCRE supports several other
kinds of parenthesized subpattern that do not cause substrings to be captured.
<P>

Captured substrings are returned to the caller via a vector of integers whose
address is passed in <I>ovector</I>. The number of elements in the vector is
passed in <I>ovecsize</I>, which must be a non-negative number. <B>Note</B>: this
argument is NOT the size of <I>ovector</I> in bytes.
<P>

The first two-thirds of the vector is used to pass back captured substrings,
each substring using a pair of integers. The remaining third of the vector is
used as workspace by <B>pcre_exec()</B> while matching capturing subpatterns,
and is not available for passing back information. The number passed in
<I>ovecsize</I> should always be a multiple of three. If it is not, it is
rounded down.
<P>

When a match is successful, information about captured substrings is returned
in pairs of integers, starting at the beginning of <I>ovector</I>, and
continuing up to two-thirds of its length at the most. The first element of
each pair is set to the offset of the first character in a substring, and the
second is set to the offset of the first character after the end of a
substring. These values are always data unit offsets, even in UTF mode. They
are byte offsets in the 8-bit library, 16-bit data item offsets in the 16-bit
library, and 32-bit data item offsets in the 32-bit library. <B>Note</B>: they
are not character counts.
<P>

The first pair of integers, <I>ovector[0]</I> and <I>ovector[1]</I>, identify the
portion of the subject string matched by the entire pattern. The next pair is
used for the first capturing subpattern, and so on. The value returned by
<B>pcre_exec()</B> is one more than the highest numbered pair that has been set.
For example, if two substrings have been captured, the returned value is 3. If
there are no capturing subpatterns, the return value from a successful match is
1, indicating that just the first pair of offsets has been set.
<P>

If a capturing subpattern is matched repeatedly, it is the last portion of the
string that it matched that is returned.
<P>

If the vector is too small to hold all the captured substring offsets, it is
used as far as possible (up to two-thirds of its length), and the function
returns a value of zero. If neither the actual string matched nor any captured
substrings are of interest, <B>pcre_exec()</B> may be called with <I>ovector</I>
passed as NULL and <I>ovecsize</I> as zero. However, if the pattern contains
back references and the <I>ovector</I> is not big enough to remember the related
substrings, PCRE has to get additional memory for use during matching. Thus it
is usually advisable to supply an <I>ovector</I> of reasonable size.
<P>

There are some cases where zero is returned (indicating vector overflow) when
in fact the vector is exactly the right size for the final match. For example,
consider the pattern
<P>
<BR>&nbsp;&nbsp;(a)(?:(b)c|bd)
<P>
If a vector of 6 elements (allowing for only 1 captured substring) is given
with subject string &quot;abd&quot;, <B>pcre_exec()</B> will try to set the second
captured string, thereby recording a vector overflow, before failing to match
&quot;c&quot; and backing up to try the second alternative. The zero return, however,
does correctly indicate that the maximum number of slots (namely 2) have been
filled. In similar cases where there is temporary overflow, but the final
number of used slots is actually less than the maximum, a non-zero value is
returned.
<P>

The <B>pcre_fullinfo()</B> function can be used to find out how many capturing
subpatterns there are in a compiled pattern. The smallest size for
<I>ovector</I> that will allow for <I>n</I> captured substrings, in addition to
the offsets of the substring matched by the whole pattern, is (<I>n</I>+1)*3.
<P>

It is possible for capturing subpattern number <I>n+1</I> to match some part of
the subject when subpattern <I>n</I> has not been used at all. For example, if
the string &quot;abc&quot; is matched against the pattern (a|(z))(bc) the return from the
function is 4, and subpatterns 1 and 3 are matched, but 2 is not. When this
happens, both values in the offset pairs corresponding to unused subpatterns
are set to -1.
<P>

Offset values that correspond to unused subpatterns at the end of the
expression are also set to -1. For example, if the string &quot;abc&quot; is matched
against the pattern (abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The
return from the function is 2, because the highest used capturing subpattern
number is 1, and the offsets for for the second and third capturing subpatterns
(assuming the vector is large enough, of course) are set to -1.
<P>

<B>Note</B>: Elements in the first two-thirds of <I>ovector</I> that do not
correspond to capturing parentheses in the pattern are never changed. That is,
if a pattern contains <I>n</I> capturing parentheses, no more than
<I>ovector[0]</I> to <I>ovector[2n+1]</I> are set by <B>pcre_exec()</B>. The other
elements (in the first two-thirds) retain whatever values they previously had.
<P>

Some convenience functions are provided for extracting the captured substrings
as separate strings. These are described below.

<A NAME="lbAX">&nbsp;</A>
<H3>Error return values from <B>pcre_exec()</B></H3>


<P>
If <B>pcre_exec()</B> fails, it returns a negative number. The following are
defined in the header file:
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOMATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)
<P>
The subject string did not match the pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-2)
<P>
Either <I>code</I> or <I>subject</I> was passed as NULL, or <I>ovector</I> was
NULL and <I>ovecsize</I> was not zero.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADOPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-3)
<P>
An unrecognized bit was set in the <I>options</I> argument.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADMAGIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-4)
<P>
PCRE stores a 4-byte &quot;magic number&quot; at the start of the compiled code, to catch
the case when it is passed a junk pointer and to detect when a pattern that was
compiled in an environment of one endianness is run in an environment with the
other endianness. This is the error that PCRE gives when the magic number is
not present.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_UNKNOWN_OPCODE&nbsp;(-5)
<P>
While running the pattern match, an unknown item was encountered in the
compiled pattern. This error could be caused by a bug in PCRE or by overwriting
of the compiled pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOMEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-6)
<P>
If a pattern contains back references, but the <I>ovector</I> that is passed to
<B>pcre_exec()</B> is not big enough to remember the referenced substrings, PCRE
gets a block of memory at the start of matching to use for this purpose. If the
call via <B>pcre_malloc()</B> fails, this error is given. The memory is
automatically freed at the end of matching.
<P>

This error is also given if <B>pcre_stack_malloc()</B> fails in
<B>pcre_exec()</B>. This can happen only when PCRE has been compiled with
<B>--disable-stack-for-recursion</B>.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOSUBSTRING&nbsp;&nbsp;&nbsp;&nbsp;(-7)
<P>
This error is used by the <B>pcre_copy_substring()</B>,
<B>pcre_get_substring()</B>, and <B>pcre_get_substring_list()</B> functions (see
below). It is never returned by <B>pcre_exec()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_MATCHLIMIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-8)
<P>
The backtracking limit, as specified by the <I>match_limit</I> field in a
<B>pcre_extra</B> structure (or defaulted) was reached. See the description
above.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_CALLOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-9)
<P>
This error is never generated by <B>pcre_exec()</B> itself. It is provided for
use by callout functions that want to yield a distinctive error code. See the

<B>pcrecallout</B>

documentation for details.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADUTF8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-10)
<P>
A string that contains an invalid UTF-8 byte sequence was passed as a subject,
and the PCRE_NO_UTF8_CHECK option was not set. If the size of the output vector
(<I>ovecsize</I>) is at least 2, the byte offset to the start of the the invalid
UTF-8 character is placed in the first element, and a reason code is placed in
the second element. The reason codes are listed in the


following section.

For backward compatibility, if PCRE_PARTIAL_HARD is set and the problem is a
truncated UTF-8 character at the end of the subject (reason codes 1 to 5),
PCRE_ERROR_SHORTUTF8 is returned instead of PCRE_ERROR_BADUTF8.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADUTF8_OFFSET&nbsp;(-11)
<P>
The UTF-8 byte sequence that was passed as a subject was checked and found to
be valid (the PCRE_NO_UTF8_CHECK option was not set), but the value of
<I>startoffset</I> did not point to the beginning of a UTF-8 character or the
end of the subject.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_PARTIAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-12)
<P>
The subject string did not match, but it did match partially. See the

<B>pcrepartial</B>

documentation for details of partial matching.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADPARTIAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-13)
<P>
This code is no longer in use. It was formerly returned when the PCRE_PARTIAL
option was used with a compiled pattern containing items that were not
supported for partial matching. From release 8.00 onwards, there are no
restrictions on partial matching.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_INTERNAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-14)
<P>
An unexpected internal error has occurred. This error could be caused by a bug
in PCRE or by overwriting of the compiled pattern.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADCOUNT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-15)
<P>
This error is given if the value of the <I>ovecsize</I> argument is negative.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_RECURSIONLIMIT&nbsp;(-21)
<P>
The internal recursion limit, as specified by the <I>match_limit_recursion</I>
field in a <B>pcre_extra</B> structure (or defaulted) was reached. See the
description above.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADNEWLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-23)
<P>
An invalid combination of PCRE_NEWLINE_<I>xxx</I> options was given.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADOFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-24)
<P>
The value of <I>startoffset</I> was negative or greater than the length of the
subject, that is, the value in <I>length</I>.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_SHORTUTF8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-25)
<P>
This error is returned instead of PCRE_ERROR_BADUTF8 when the subject string
ends with a truncated UTF-8 character and the PCRE_PARTIAL_HARD option is set.
Information about the failure is returned as for PCRE_ERROR_BADUTF8. It is in
fact sufficient to detect this case, but this special error code for
PCRE_PARTIAL_HARD precedes the implementation of returned information; it is
retained for backwards compatibility.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_RECURSELOOP&nbsp;&nbsp;&nbsp;&nbsp;(-26)
<P>
This error is returned when <B>pcre_exec()</B> detects a recursion loop within
the pattern. Specifically, it means that either the whole pattern or a
subpattern has been called recursively for the second time at the same position
in the subject string. Some simple patterns that might do this are detected and
faulted at compile time, but more complicated cases, in particular mutual
recursions between two different subpatterns, cannot be detected until run
time.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_JIT_STACKLIMIT&nbsp;(-27)
<P>
This error is returned when a pattern that was successfully studied using a
JIT compile option is being matched, but the memory available for the
just-in-time processing stack is not large enough. See the

<B>pcrejit</B>

documentation for more details.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADMODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-28)
<P>
This error is given if a pattern that was compiled by the 8-bit library is
passed to a 16-bit or 32-bit library function, or vice versa.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADENDIANNESS&nbsp;&nbsp;(-29)
<P>
This error is given if a pattern that was compiled and saved is reloaded on a
host with different endianness. The utility function
<B>pcre_pattern_to_host_byte_order()</B> can be used to convert such a pattern
so that it runs on the new host.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_JIT_BADOPTION
<P>
This error is returned when a pattern that was successfully studied using a JIT
compile option is being matched, but the matching mode (partial or complete
match) does not correspond to any JIT compilation mode. When the JIT fast path
function is used, this error may be also given for invalid options. See the

<B>pcrejit</B>

documentation for more details.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_BADLENGTH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-32)
<P>
This error is given if <B>pcre_exec()</B> is called with a negative value for
the <I>length</I> argument.
<P>

Error numbers -16 to -20, -22, and 30 are not used by <B>pcre_exec()</B>.

<A NAME="lbAY">&nbsp;</A>
<H3>Reason codes for invalid UTF-8 strings</H3>


<P>
This section applies only to the 8-bit library. The corresponding information
for the 16-bit and 32-bit libraries is given in the

<B>pcre16</B>

and

<B>pcre32</B>

pages.
<P>

When <B>pcre_exec()</B> returns either PCRE_ERROR_BADUTF8 or
PCRE_ERROR_SHORTUTF8, and the size of the output vector (<I>ovecsize</I>) is at
least 2, the offset of the start of the invalid UTF-8 character is placed in
the first output vector element (<I>ovector[0]</I>) and a reason code is placed
in the second element (<I>ovector[1]</I>). The reason codes are given names in
the <B>pcre.h</B> header file:
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR1
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR2
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR3
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR4
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR5
<P>
The string ends with a truncated UTF-8 character; the code specifies how many
bytes are missing (1 to 5). Although RFC 3629 restricts UTF-8 characters to be
no longer than 4 bytes, the encoding scheme (originally defined by RFC 2279)
allows for up to 6 bytes, and this is checked first; hence the possibility of
4 or 5 missing bytes.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR6
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR7
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR8
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR9
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR10
<P>
The two most significant bits of the 2nd, 3rd, 4th, 5th, or 6th byte of the
character do not have the binary value 0b10 (that is, either the most
significant bit is 0, or the next bit is 1).
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR11
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR12
<P>
A character that is valid by the RFC 2279 rules is either 5 or 6 bytes long;
these code points are excluded by RFC 3629.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR13
<P>
A 4-byte character has a value greater than 0x10fff; these code points are
excluded by RFC 3629.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR14
<P>
A 3-byte character has a value in the range 0xd800 to 0xdfff; this range of
code points are reserved by RFC 3629 for use with UTF-16, and so are excluded
from UTF-8.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR15
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR16
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR17
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR18
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR19
<P>
A 2-, 3-, 4-, 5-, or 6-byte character is &quot;overlong&quot;, that is, it codes for a
value that can be represented by fewer bytes, which is invalid. For example,
the two bytes 0xc0, 0xae give the value 0x2e, whose correct coding uses just
one byte.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR20
<P>
The two most significant bits of the first byte of a character have the binary
value 0b10 (that is, the most significant bit is 1 and the second is 0). Such a
byte can only validly occur as the second or subsequent byte of a multi-byte
character.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR21
<P>
The first byte of a character has the value 0xfe or 0xff. These values can
never occur in a valid UTF-8 string.
<P>
<BR>&nbsp;&nbsp;PCRE_UTF8_ERR22
<P>
This error code was formerly used when the presence of a so-called
&quot;non-character&quot; caused an error. Unicode corrigendum #9 makes it clear that
such characters should not cause a string to be rejected, and so this code is
no longer in use and is never returned.
<A NAME="lbAZ">&nbsp;</A>
<H2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</H2>


<P>
<PRE>
<B>int pcre_copy_substring(const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, int <I>stringnumber</I>, char *<I>buffer</I>,
<B>     int </B><I>buffersize</I>);

<B>int pcre_get_substring(const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, int <I>stringnumber</I>,
<B>     const char **</B><I>stringptr</I>);

<B>int pcre_get_substring_list(const char *</B><I>subject</I>,
<B>     int *</B><I>ovector</I>, int <I>stringcount</I>, const char ***<I>listptr</I>);
</PRE>

<P>

Captured substrings can be accessed directly by using the offsets returned by
<B>pcre_exec()</B> in <I>ovector</I>. For convenience, the functions
<B>pcre_copy_substring()</B>, <B>pcre_get_substring()</B>, and
<B>pcre_get_substring_list()</B> are provided for extracting captured substrings
as new, separate, zero-terminated strings. These functions identify substrings
by number. The next section describes functions for extracting named
substrings.
<P>

A substring that contains a binary zero is correctly extracted and has a
further zero added on the end, but the result is not, of course, a C string.
However, you can process such a string by referring to the length that is
returned by <B>pcre_copy_substring()</B> and <B>pcre_get_substring()</B>.
Unfortunately, the interface to <B>pcre_get_substring_list()</B> is not adequate
for handling strings containing binary zeros, because the end of the final
string is not independently indicated.
<P>

The first three arguments are the same for all three of these functions:
<I>subject</I> is the subject string that has just been successfully matched,
<I>ovector</I> is a pointer to the vector of integer offsets that was passed to
<B>pcre_exec()</B>, and <I>stringcount</I> is the number of substrings that were
captured by the match, including the substring that matched the entire regular
expression. This is the value returned by <B>pcre_exec()</B> if it is greater
than zero. If <B>pcre_exec()</B> returned zero, indicating that it ran out of
space in <I>ovector</I>, the value passed as <I>stringcount</I> should be the
number of elements in the vector divided by three.
<P>

The functions <B>pcre_copy_substring()</B> and <B>pcre_get_substring()</B>
extract a single substring, whose number is given as <I>stringnumber</I>. A
value of zero extracts the substring that matched the entire pattern, whereas
higher values extract the captured substrings. For <B>pcre_copy_substring()</B>,
the string is placed in <I>buffer</I>, whose length is given by
<I>buffersize</I>, while for <B>pcre_get_substring()</B> a new block of memory is
obtained via <B>pcre_malloc</B>, and its address is returned via
<I>stringptr</I>. The yield of the function is the length of the string, not
including the terminating zero, or one of these error codes:
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOMEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-6)
<P>
The buffer was too small for <B>pcre_copy_substring()</B>, or the attempt to get
memory failed for <B>pcre_get_substring()</B>.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOSUBSTRING&nbsp;&nbsp;&nbsp;&nbsp;(-7)
<P>
There is no substring whose number is <I>stringnumber</I>.
<P>

The <B>pcre_get_substring_list()</B> function extracts all available substrings
and builds a list of pointers to them. All this is done in a single block of
memory that is obtained via <B>pcre_malloc</B>. The address of the memory block
is returned via <I>listptr</I>, which is also the start of the list of string
pointers. The end of the list is marked by a NULL pointer. The yield of the
function is zero if all went well, or the error code
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_NOMEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-6)
<P>
if the attempt to get the memory block failed.
<P>

When any of these functions encounter a substring that is unset, which can
happen when capturing subpattern number <I>n+1</I> matches some part of the
subject, but subpattern <I>n</I> has not been used at all, they return an empty
string. This can be distinguished from a genuine zero-length substring by
inspecting the appropriate offset in <I>ovector</I>, which is negative for unset
substrings.
<P>

The two convenience functions <B>pcre_free_substring()</B> and
<B>pcre_free_substring_list()</B> can be used to free the memory returned by
a previous call of <B>pcre_get_substring()</B> or
<B>pcre_get_substring_list()</B>, respectively. They do nothing more than call
the function pointed to by <B>pcre_free</B>, which of course could be called
directly from a C program. However, PCRE is used in some situations where it is
linked via a special interface to another programming language that cannot use
<B>pcre_free</B> directly; it is for these cases that the functions are
provided.
<A NAME="lbBA">&nbsp;</A>
<H2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</H2>


<P>
<PRE>
<B>int pcre_get_stringnumber(const pcre *</B><I>code</I>,
<B>     const char *</B><I>name</I>);

<B>int pcre_copy_named_substring(const pcre *</B><I>code</I>,
<B>     const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, const char *<I>stringname</I>,
<B>     char *</B><I>buffer</I>, int <I>buffersize</I>);

<B>int pcre_get_named_substring(const pcre *</B><I>code</I>,
<B>     const char *</B><I>subject</I>, int *<I>ovector</I>,
<B>     int </B><I>stringcount</I>, const char *<I>stringname</I>,
<B>     const char **</B><I>stringptr</I>);
</PRE>

<P>

To extract a substring by name, you first have to find associated number.
For example, for this pattern
<P>
<BR>&nbsp;&nbsp;(a+)b(?&lt;xxx&gt;\d+)...
<P>
the number of the subpattern called &quot;xxx&quot; is 2. If the name is known to be
unique (PCRE_DUPNAMES was not set), you can find the number from the name by
calling <B>pcre_get_stringnumber()</B>. The first argument is the compiled
pattern, and the second is the name. The yield of the function is the
subpattern number, or PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of
that name.
<P>

Given the number, you can extract the substring directly, or use one of the
functions described in the previous section. For convenience, there are also
two functions that do the whole job.
<P>

Most of the arguments of <B>pcre_copy_named_substring()</B> and
<B>pcre_get_named_substring()</B> are the same as those for the similarly named
functions that extract by number. As these are described in the previous
section, they are not re-described here. There are just two differences:
<P>

First, instead of a substring number, a substring name is given. Second, there
is an extra argument, given at the start, which is a pointer to the compiled
pattern. This is needed in order to gain access to the name-to-number
translation table.
<P>

These functions call <B>pcre_get_stringnumber()</B>, and if it succeeds, they
then call <B>pcre_copy_substring()</B> or <B>pcre_get_substring()</B>, as
appropriate. <B>NOTE:</B> If PCRE_DUPNAMES is set and there are duplicate names,
the behaviour may not be what you want (see the next section).
<P>

<B>Warning:</B> If the pattern uses the (?| feature to set up multiple
subpatterns with the same number, as described in the


section on duplicate subpattern numbers

in the

<B>pcrepattern</B>

page, you cannot use names to distinguish the different subpatterns, because
names are not included in the compiled code. The matching process uses only
numbers. For this reason, the use of different names for subpatterns of the
same number causes an error at compile time.
<A NAME="lbBB">&nbsp;</A>
<H2>DUPLICATE SUBPATTERN NAMES</H2>


<P>
<PRE>
<B>int pcre_get_stringtable_entries(const pcre *</B><I>code</I>,
<B>     const char *</B><I>name</I>, char **<I>first</I>, char **<I>last</I>);
</PRE>

<P>

When a pattern is compiled with the PCRE_DUPNAMES option, names for subpatterns
are not required to be unique. (Duplicate names are always allowed for
subpatterns with the same number, created by using the (?| feature. Indeed, if
such subpatterns are named, they are required to use the same names.)
<P>

Normally, patterns with duplicate names are such that in any one match, only
one of the named subpatterns participates. An example is shown in the

<B>pcrepattern</B>

documentation.
<P>

When duplicates are present, <B>pcre_copy_named_substring()</B> and
<B>pcre_get_named_substring()</B> return the first substring corresponding to
the given name that is set. If none are set, PCRE_ERROR_NOSUBSTRING (-7) is
returned; no data is returned. The <B>pcre_get_stringnumber()</B> function
returns one of the numbers that are associated with the name, but it is not
defined which it is.
<P>

If you want to get full details of all captured substrings for a given name,
you must use the <B>pcre_get_stringtable_entries()</B> function. The first
argument is the compiled pattern, and the second is the name. The third and
fourth are pointers to variables which are updated by the function. After it
has run, they point to the first and last entries in the name-to-number table
for the given name. The function itself returns the length of each entry, or
PCRE_ERROR_NOSUBSTRING (-7) if there are none. The format of the table is
described above in the section entitled <I>Information about a pattern</I>


above.

Given all the relevant entries for the name, you can extract each of their
numbers, and hence the captured data, if any.
<A NAME="lbBC">&nbsp;</A>
<H2>FINDING ALL POSSIBLE MATCHES</H2>


<P>
The traditional matching function uses a similar algorithm to Perl, which stops
when it finds the first match, starting at a given point in the subject. If you
want to find all possible matches, or the longest possible match, consider
using the alternative matching function (see below) instead. If you cannot use
the alternative function, but still need to find all possible matches, you
can kludge it up by making use of the callout facility, which is described in
the

<B>pcrecallout</B>

documentation.
<P>

What you have to do is to insert a callout right at the end of the pattern.
When your callout function is called, extract and save the current matched
substring. Then return 1, which forces <B>pcre_exec()</B> to backtrack and try
other alternatives. Ultimately, when it runs out of matches, <B>pcre_exec()</B>
will yield PCRE_ERROR_NOMATCH.
<A NAME="lbBD">&nbsp;</A>
<H2>OBTAINING AN ESTIMATE OF STACK USAGE</H2>


<P>
Matching certain patterns using <B>pcre_exec()</B> can use a lot of process
stack, which in certain environments can be rather limited in size. Some users
find it helpful to have an estimate of the amount of stack that is used by
<B>pcre_exec()</B>, to help them set recursion limits, as described in the

<B>pcrestack</B>

documentation. The estimate that is output by <B>pcretest</B> when called with
the <B>-m</B> and <B>-C</B> options is obtained by calling <B>pcre_exec</B> with
the values NULL, NULL, NULL, -999, and -999 for its first five arguments.
<P>

Normally, if its first argument is NULL, <B>pcre_exec()</B> immediately returns
the negative error code PCRE_ERROR_NULL, but with this special combination of
arguments, it returns instead a negative number whose absolute value is the
approximate stack frame size in bytes. (A negative number is used so that it is
clear that no match has happened.) The value is approximate because in some
cases, recursive calls to <B>pcre_exec()</B> occur when there are one or two
additional variables on the stack.
<P>

If PCRE has been compiled to use the heap instead of the stack for recursion,
the value returned is the size of each block that is obtained from the heap.

<A NAME="lbBE">&nbsp;</A>
<H2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</H2>


<P>
<PRE>
<B>int pcre_dfa_exec(const pcre *</B><I>code</I>, const pcre_extra *<I>extra</I>,
<B>     const char *</B><I>subject</I>, int <I>length</I>, int <I>startoffset</I>,
<B>     int </B><I>options</I>, int *<I>ovector</I>, int <I>ovecsize</I>,
<B>     int *</B><I>workspace</I>, int <I>wscount</I>);
</PRE>

<P>

The function <B>pcre_dfa_exec()</B> is called to match a subject string against
a compiled pattern, using a matching algorithm that scans the subject string
just once, and does not backtrack. This has different characteristics to the
normal algorithm, and is not compatible with Perl. Some of the features of PCRE
patterns are not supported. Nevertheless, there are times when this kind of
matching can be useful. For a discussion of the two matching algorithms, and a
list of features that <B>pcre_dfa_exec()</B> does not support, see the

<B>pcrematching</B>

documentation.
<P>

The arguments for the <B>pcre_dfa_exec()</B> function are the same as for
<B>pcre_exec()</B>, plus two extras. The <I>ovector</I> argument is used in a
different way, and this is described below. The other common arguments are used
in the same way as for <B>pcre_exec()</B>, so their description is not repeated
here.
<P>

The two additional arguments provide workspace for the function. The workspace
vector should contain at least 20 elements. It is used for keeping track of
multiple paths through the pattern tree. More workspace will be needed for
patterns and subjects where there are a lot of potential matches.
<P>

Here is an example of a simple call to <B>pcre_dfa_exec()</B>:
<P>
<BR>&nbsp;&nbsp;int&nbsp;rc;
<BR>&nbsp;&nbsp;int&nbsp;ovector[10];
<BR>&nbsp;&nbsp;int&nbsp;wspace[20];
<BR>&nbsp;&nbsp;rc&nbsp;=&nbsp;pcre_dfa_exec(
<BR>&nbsp;&nbsp;&nbsp;&nbsp;re,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;result&nbsp;of&nbsp;pcre_compile()&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;we&nbsp;didn't&nbsp;study&nbsp;the&nbsp;pattern&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&quot;some&nbsp;string&quot;,&nbsp;&nbsp;/*&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;11,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;subject&nbsp;string&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start&nbsp;at&nbsp;offset&nbsp;0&nbsp;in&nbsp;the&nbsp;subject&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;default&nbsp;options&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ovector,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;vector&nbsp;of&nbsp;integers&nbsp;for&nbsp;substring&nbsp;information&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;elements&nbsp;(NOT&nbsp;size&nbsp;in&nbsp;bytes)&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;wspace,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;working&nbsp;space&nbsp;vector&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;elements&nbsp;(NOT&nbsp;size&nbsp;in&nbsp;bytes)&nbsp;*/
<A NAME="lbBF">&nbsp;</A>
<H3>Option bits for <B>pcre_dfa_exec()</B></H3>


<P>
The unused bits of the <I>options</I> argument for <B>pcre_dfa_exec()</B> must be
zero. The only bits that may be set are PCRE_ANCHORED, PCRE_NEWLINE_<I>xxx</I>,
PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_UTF8_CHECK, PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE,
PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST, and PCRE_DFA_RESTART.
All but the last four of these are exactly the same as for <B>pcre_exec()</B>,
so their description is not repeated here.
<P>
<BR>&nbsp;&nbsp;PCRE_PARTIAL_HARD
<BR>&nbsp;&nbsp;PCRE_PARTIAL_SOFT
<P>
These have the same general effect as they do for <B>pcre_exec()</B>, but the
details are slightly different. When PCRE_PARTIAL_HARD is set for
<B>pcre_dfa_exec()</B>, it returns PCRE_ERROR_PARTIAL if the end of the subject
is reached and there is still at least one matching possibility that requires
additional characters. This happens even if some complete matches have also
been found. When PCRE_PARTIAL_SOFT is set, the return code PCRE_ERROR_NOMATCH
is converted into PCRE_ERROR_PARTIAL if the end of the subject is reached,
there have been no complete matches, but there is still at least one matching
possibility. The portion of the string that was inspected when the longest
partial match was found is set as the first matching string in both cases.
There is a more detailed discussion of partial and multi-segment matching, with
examples, in the

<B>pcrepartial</B>

documentation.
<P>
<BR>&nbsp;&nbsp;PCRE_DFA_SHORTEST
<P>
Setting the PCRE_DFA_SHORTEST option causes the matching algorithm to stop as
soon as it has found one match. Because of the way the alternative algorithm
works, this is necessarily the shortest possible match at the first possible
matching point in the subject string.
<P>
<BR>&nbsp;&nbsp;PCRE_DFA_RESTART
<P>
When <B>pcre_dfa_exec()</B> returns a partial match, it is possible to call it
again, with additional subject characters, and have it continue with the same
match. The PCRE_DFA_RESTART option requests this action; when it is set, the
<I>workspace</I> and <I>wscount</I> options must reference the same vector as
before because data about the match so far is left in them after a partial
match. There is more discussion of this facility in the

<B>pcrepartial</B>

documentation.
<A NAME="lbBG">&nbsp;</A>
<H3>Successful returns from <B>pcre_dfa_exec()</B></H3>


<P>
When <B>pcre_dfa_exec()</B> succeeds, it may have matched more than one
substring in the subject. Note, however, that all the matches from one run of
the function start at the same point in the subject. The shorter matches are
all initial substrings of the longer matches. For example, if the pattern
<P>
<BR>&nbsp;&nbsp;&lt;.*&gt;
<P>
is matched against the string
<P>
<BR>&nbsp;&nbsp;This&nbsp;is&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;&nbsp;&lt;something&nbsp;further&gt;&nbsp;no&nbsp;more
<P>
the three matched strings are
<P>
<BR>&nbsp;&nbsp;&lt;something&gt;
<BR>&nbsp;&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;
<BR>&nbsp;&nbsp;&lt;something&gt;&nbsp;&lt;something&nbsp;else&gt;&nbsp;&lt;something&nbsp;further&gt;
<P>
On success, the yield of the function is a number greater than zero, which is
the number of matched substrings. The substrings themselves are returned in
<I>ovector</I>. Each string uses two elements; the first is the offset to the
start, and the second is the offset to the end. In fact, all the strings have
the same start offset. (Space could have been saved by giving this only once,
but it was decided to retain some compatibility with the way <B>pcre_exec()</B>
returns data, even though the meaning of the strings is different.)
<P>

The strings are returned in reverse order of length; that is, the longest
matching string is given first. If there were too many matches to fit into
<I>ovector</I>, the yield of the function is zero, and the vector is filled with
the longest matches. Unlike <B>pcre_exec()</B>, <B>pcre_dfa_exec()</B> can use
the entire <I>ovector</I> for returning matched strings.
<P>

NOTE: PCRE's &quot;auto-possessification&quot; optimization usually applies to character
repeats at the end of a pattern (as well as internally). For example, the
pattern &quot;a\d+&quot; is compiled as if it were &quot;a\d++&quot; because there is no point
even considering the possibility of backtracking into the repeated digits. For
DFA matching, this means that only one possible match is found. If you really
do want multiple matches in such cases, either use an ungreedy repeat
(&quot;a\d+?&quot;) or set the PCRE_NO_AUTO_POSSESS option when compiling.
<A NAME="lbBH">&nbsp;</A>
<H3>Error returns from <B>pcre_dfa_exec()</B></H3>


<P>
The <B>pcre_dfa_exec()</B> function returns a negative number when it fails.
Many of the errors are the same as for <B>pcre_exec()</B>, and these are
described


above.

There are in addition the following errors that are specific to
<B>pcre_dfa_exec()</B>:
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_UITEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-16)
<P>
This return is given if <B>pcre_dfa_exec()</B> encounters an item in the pattern
that it does not support, for instance, the use of \C or a back reference.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_UCOND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-17)
<P>
This return is given if <B>pcre_dfa_exec()</B> encounters a condition item that
uses a back reference for the condition, or a test for recursion in a specific
group. These are not supported.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_UMLIMIT&nbsp;&nbsp;&nbsp;&nbsp;(-18)
<P>
This return is given if <B>pcre_dfa_exec()</B> is called with an <I>extra</I>
block that contains a setting of the <I>match_limit</I> or
<I>match_limit_recursion</I> fields. This is not supported (these fields are
meaningless for DFA matching).
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_WSSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-19)
<P>
This return is given if <B>pcre_dfa_exec()</B> runs out of space in the
<I>workspace</I> vector.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_RECURSE&nbsp;&nbsp;&nbsp;&nbsp;(-20)
<P>
When a recursive subpattern is processed, the matching function calls itself
recursively, using private vectors for <I>ovector</I> and <I>workspace</I>. This
error is given if the output vector is not large enough. This should be
extremely rare, as a vector of size 1000 is used.
<P>
<BR>&nbsp;&nbsp;PCRE_ERROR_DFA_BADRESTART&nbsp;(-30)
<P>
When <B>pcre_dfa_exec()</B> is called with the <B>PCRE_DFA_RESTART</B> option,
some plausibility checks are made on the contents of the workspace, which
should contain data about the previous partial match. If any of these checks
fail, this error is given.
<A NAME="lbBI">&nbsp;</A>
<H2>SEE ALSO</H2>


<P>
<B><A HREF="/cgi-bin/man/man2html?3+pcre16">pcre16</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcre32">pcre32</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcrebuild">pcrebuild</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcrecallout">pcrecallout</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?3+pcrecpp">pcrecpp</A>(3)</B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcrematching">pcrematching</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcrepartial">pcrepartial</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?3+pcreposix">pcreposix</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcreprecompile">pcreprecompile</A></B>(3), <B><A HREF="/cgi-bin/man/man2html?3+pcresample">pcresample</A></B>(3),
<B><A HREF="/cgi-bin/man/man2html?3+pcrestack">pcrestack</A></B>(3).
<A NAME="lbBJ">&nbsp;</A>
<H2>AUTHOR</H2>


<P>
<PRE>
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</PRE>

<A NAME="lbBK">&nbsp;</A>
<H2>REVISION</H2>


<P>
<PRE>
Last updated: 18 December 2015
Copyright (c) 1997-2015 University of Cambridge.
</PRE>

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">PCRE NATIVE API BASIC FUNCTIONS</A><DD>
<DT id="3"><A HREF="#lbAD">PCRE NATIVE API STRING EXTRACTION FUNCTIONS</A><DD>
<DT id="4"><A HREF="#lbAE">PCRE NATIVE API AUXILIARY FUNCTIONS</A><DD>
<DT id="5"><A HREF="#lbAF">PCRE NATIVE API INDIRECTED FUNCTIONS</A><DD>
<DT id="6"><A HREF="#lbAG">PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</A><DD>
<DT id="7"><A HREF="#lbAH">PCRE API OVERVIEW</A><DD>
<DT id="8"><A HREF="#lbAI">NEWLINES</A><DD>
<DT id="9"><A HREF="#lbAJ">MULTITHREADING</A><DD>
<DT id="10"><A HREF="#lbAK">SAVING PRECOMPILED PATTERNS FOR LATER USE</A><DD>
<DT id="11"><A HREF="#lbAL">CHECKING BUILD-TIME OPTIONS</A><DD>
<DT id="12"><A HREF="#lbAM">COMPILING A PATTERN</A><DD>
<DT id="13"><A HREF="#lbAN">COMPILATION ERROR CODES</A><DD>
<DT id="14"><A HREF="#lbAO">STUDYING A PATTERN</A><DD>
<DT id="15"><A HREF="#lbAP">LOCALE SUPPORT</A><DD>
<DT id="16"><A HREF="#lbAQ">INFORMATION ABOUT A PATTERN</A><DD>
<DT id="17"><A HREF="#lbAR">REFERENCE COUNTS</A><DD>
<DT id="18"><A HREF="#lbAS">MATCHING A PATTERN: THE TRADITIONAL FUNCTION</A><DD>
<DL>
<DT id="19"><A HREF="#lbAT">Extra data for <B>pcre_exec()</B></A><DD>
<DT id="20"><A HREF="#lbAU">Option bits for <B>pcre_exec()</B></A><DD>
<DT id="21"><A HREF="#lbAV">The string to be matched by <B>pcre_exec()</B></A><DD>
<DT id="22"><A HREF="#lbAW">How <B>pcre_exec()</B> returns captured substrings</A><DD>
<DT id="23"><A HREF="#lbAX">Error return values from <B>pcre_exec()</B></A><DD>
<DT id="24"><A HREF="#lbAY">Reason codes for invalid UTF-8 strings</A><DD>
</DL>
<DT id="25"><A HREF="#lbAZ">EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</A><DD>
<DT id="26"><A HREF="#lbBA">EXTRACTING CAPTURED SUBSTRINGS BY NAME</A><DD>
<DT id="27"><A HREF="#lbBB">DUPLICATE SUBPATTERN NAMES</A><DD>
<DT id="28"><A HREF="#lbBC">FINDING ALL POSSIBLE MATCHES</A><DD>
<DT id="29"><A HREF="#lbBD">OBTAINING AN ESTIMATE OF STACK USAGE</A><DD>
<DT id="30"><A HREF="#lbBE">MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</A><DD>
<DL>
<DT id="31"><A HREF="#lbBF">Option bits for <B>pcre_dfa_exec()</B></A><DD>
<DT id="32"><A HREF="#lbBG">Successful returns from <B>pcre_dfa_exec()</B></A><DD>
<DT id="33"><A HREF="#lbBH">Error returns from <B>pcre_dfa_exec()</B></A><DD>
</DL>
<DT id="34"><A HREF="#lbBI">SEE ALSO</A><DD>
<DT id="35"><A HREF="#lbBJ">AUTHOR</A><DD>
<DT id="36"><A HREF="#lbBK">REVISION</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:51 GMT, March 31, 2021
</BODY>
</HTML>
