
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of Set.Make</TITLE>
</HEAD><BODY>
<H1>Set.Make</H1>
Section: OCaml library (3o)<BR>Updated: 2020-01-30<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Set.Make - Functor building an implementation of the set structure given a totally ordered type.
<A NAME="lbAC">&nbsp;</A>
<H2>Module</H2>

Module   Set.Make
<A NAME="lbAD">&nbsp;</A>
<H2>Documentation</H2>

<P>
Module
<B>Make</B>

<BR>&nbsp;:&nbsp;
<B>functor (Ord : OrderedType) -&gt; sig  end</B>

<P>
<P>
Functor building an implementation of the set structure
given a totally ordered type.
<P>
<P>
<B>Parameters:</B>

<P>
&quot;Ord&quot;
<P>
<B>Set.OrderedType</B>

<P>
<P>
<P>
<P>
<P>
<P>
<P>
<I>type elt </I>

<P>
<P>
The type of the set elements.
<P>
<P>
<I>type t </I>

<P>
<P>
The type of sets.
<P>
<P>
<P>
<I>val empty </I>

: 
<B>t</B>

<P>
The empty set.
<P>
<P>
<P>
<I>val is_empty </I>

: 
<B>t -&gt; bool</B>

<P>
Test whether a set is empty or not.
<P>
<P>
<P>
<I>val mem </I>

: 
<B>elt -&gt; t -&gt; bool</B>

<P>
<P>
<B>mem x s</B>

tests whether 
<B>x</B>

belongs to the set 
<B>s</B>

.
<P>
<P>
<P>
<I>val add </I>

: 
<B>elt -&gt; t -&gt; t</B>

<P>
<P>
<B>add x s</B>

returns a set containing all elements of 
<B>s</B>

,
plus 
<B>x</B>

. If 
<B>x</B>

was already in 
<B>s</B>

, 
<B>s</B>

is returned unchanged
(the result of the function is then physically equal to 
<B>s</B>

).
<P>
<P>
<B>Before4.03</B>

Physical equality was not ensured.
<P>
<P>
<P>
<P>
<I>val singleton </I>

: 
<B>elt -&gt; t</B>

<P>
<P>
<B>singleton x</B>

returns the one-element set containing only 
<B>x</B>

.
<P>
<P>
<P>
<I>val remove </I>

: 
<B>elt -&gt; t -&gt; t</B>

<P>
<P>
<B>remove x s</B>

returns a set containing all elements of 
<B>s</B>

,
except 
<B>x</B>

. If 
<B>x</B>

was not in 
<B>s</B>

, 
<B>s</B>

is returned unchanged
(the result of the function is then physically equal to 
<B>s</B>

).
<P>
<P>
<B>Before4.03</B>

Physical equality was not ensured.
<P>
<P>
<P>
<P>
<I>val union </I>

: 
<B>t -&gt; t -&gt; t</B>

<P>
Set union.
<P>
<P>
<P>
<I>val inter </I>

: 
<B>t -&gt; t -&gt; t</B>

<P>
Set intersection.
<P>
<P>
<P>
<I>val disjoint </I>

: 
<B>t -&gt; t -&gt; bool</B>

<P>
Test if two sets are disjoint.
<P>
<P>
<B>Since</B>

4.08.0
<P>
<P>
<P>
<I>val diff </I>

: 
<B>t -&gt; t -&gt; t</B>

<P>
Set difference: 
<B>diff s1 s2</B>

contains the elements of 
<B>s1</B>

that are not in 
<B>s2</B>

.
<P>
<P>
<P>
<I>val compare </I>

: 
<B>t -&gt; t -&gt; int</B>

<P>
Total ordering between sets. Can be used as the ordering function
for doing sets of sets.
<P>
<P>
<P>
<I>val equal </I>

: 
<B>t -&gt; t -&gt; bool</B>

<P>
<P>
<B>equal s1 s2</B>

tests whether the sets 
<B>s1</B>

and 
<B>s2</B>

are
equal, that is, contain equal elements.
<P>
<P>
<P>
<I>val subset </I>

: 
<B>t -&gt; t -&gt; bool</B>

<P>
<P>
<B>subset s1 s2</B>

tests whether the set 
<B>s1</B>

is a subset of
the set 
<B>s2</B>

.
<P>
<P>
<P>
<I>val iter </I>

: 
<B>(elt -&gt; unit) -&gt; t -&gt; unit</B>

<P>
<P>
<B>iter f s</B>

applies 
<B>f</B>

in turn to all elements of 
<B>s</B>

.
The elements of 
<B>s</B>

are presented to 
<B>f</B>

in increasing order
with respect to the ordering over the type of the elements.
<P>
<P>
<P>
<I>val map </I>

: 
<B>(elt -&gt; elt) -&gt; t -&gt; t</B>

<P>
<P>
<B>map f s</B>

is the set whose elements are 
<B>f a0</B>

,
<B>f a1</B>

... 
<B>f</B>

<B>aN</B>

, where 
<B>a0</B>

,
<B>a1</B>

...
<B>aN</B>

are the elements of 
<B>s</B>

.
<P>
The elements are passed to 
<B>f</B>

in increasing order
with respect to the ordering over the type of the elements.
<P>
If no element of 
<B>s</B>

is changed by 
<B>f</B>

, 
<B>s</B>

is returned
unchanged. (If each output of 
<B>f</B>

is physically equal to its
input, the returned set is physically equal to 
<B>s</B>

.)
<P>
<P>
<B>Since</B>

4.04.0
<P>
<P>
<P>
<I>val fold </I>

: 
<B>(elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a</B>

<P>
<P>
<B>fold f s a</B>

computes 
<B>(f xN ... (f x2 (f x1 a))...)</B>

,
where 
<B>x1 ... xN</B>

are the elements of 
<B>s</B>

, in increasing order.
<P>
<P>
<P>
<I>val for_all </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; bool</B>

<P>
<P>
<B>for_all p s</B>

checks if all elements of the set
satisfy the predicate 
<B>p</B>

.
<P>
<P>
<P>
<I>val exists </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; bool</B>

<P>
<P>
<B>exists p s</B>

checks if at least one element of
the set satisfies the predicate 
<B>p</B>

.
<P>
<P>
<P>
<I>val filter </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; t</B>

<P>
<P>
<B>filter p s</B>

returns the set of all elements in 
<B>s</B>

that satisfy predicate 
<B>p</B>

. If 
<B>p</B>

satisfies every element in 
<B>s</B>

,
<B>s</B>

is returned unchanged (the result of the function is then
physically equal to 
<B>s</B>

).
<P>
<P>
<B>Before4.03</B>

Physical equality was not ensured.
<P>
<P>
<P>
<P>
<I>val partition </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; t * t</B>

<P>
<P>
<B>partition p s</B>

returns a pair of sets 
<B>(s1, s2)</B>

, where
<B>s1</B>

is the set of all the elements of 
<B>s</B>

that satisfy the
predicate 
<B>p</B>

, and 
<B>s2</B>

is the set of all the elements of
<B>s</B>

that do not satisfy 
<B>p</B>

.
<P>
<P>
<P>
<I>val cardinal </I>

: 
<B>t -&gt; int</B>

<P>
Return the number of elements of a set.
<P>
<P>
<P>
<I>val elements </I>

: 
<B>t -&gt; elt list</B>

<P>
Return the list of all elements of the given set.
The returned list is sorted in increasing order with respect
to the ordering 
<B>Ord.compare</B>

, where 
<B>Ord</B>

is the argument
given to 
<B>Set.Make</B>

.
<P>
<P>
<P>
<I>val min_elt </I>

: 
<B>t -&gt; elt</B>

<P>
Return the smallest element of the given set
(with respect to the 
<B>Ord.compare</B>

ordering), or raise
<B>Not_found</B>

if the set is empty.
<P>
<P>
<P>
<I>val min_elt_opt </I>

: 
<B>t -&gt; elt option</B>

<P>
Return the smallest element of the given set
(with respect to the 
<B>Ord.compare</B>

ordering), or 
<B>None</B>

if the set is empty.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val max_elt </I>

: 
<B>t -&gt; elt</B>

<P>
Same as 
<B>Set.S.min_elt</B>

, but returns the largest element of the
given set.
<P>
<P>
<P>
<I>val max_elt_opt </I>

: 
<B>t -&gt; elt option</B>

<P>
Same as 
<B>Set.S.min_elt_opt</B>

, but returns the largest element of the
given set.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val choose </I>

: 
<B>t -&gt; elt</B>

<P>
Return one element of the given set, or raise 
<B>Not_found</B>

if
the set is empty. Which element is chosen is unspecified,
but equal elements will be chosen for equal sets.
<P>
<P>
<P>
<I>val choose_opt </I>

: 
<B>t -&gt; elt option</B>

<P>
Return one element of the given set, or 
<B>None</B>

if
the set is empty. Which element is chosen is unspecified,
but equal elements will be chosen for equal sets.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val split </I>

: 
<B>elt -&gt; t -&gt; t * bool * t</B>

<P>
<P>
<B>split x s</B>

returns a triple 
<B>(l, present, r)</B>

, where
<B>l</B>

is the set of elements of 
<B>s</B>

that are
strictly less than 
<B>x</B>

;
<B>r</B>

is the set of elements of 
<B>s</B>

that are
strictly greater than 
<B>x</B>

;
<B>present</B>

is 
<B>false</B>

if 
<B>s</B>

contains no element equal to 
<B>x</B>

,
or 
<B>true</B>

if 
<B>s</B>

contains an element equal to 
<B>x</B>

.
<P>
<P>
<P>
<I>val find </I>

: 
<B>elt -&gt; t -&gt; elt</B>

<P>
<P>
<B>find x s</B>

returns the element of 
<B>s</B>

equal to 
<B>x</B>

(according
to 
<B>Ord.compare</B>

), or raise 
<B>Not_found</B>

if no such element
exists.
<P>
<P>
<B>Since</B>

4.01.0
<P>
<P>
<P>
<I>val find_opt </I>

: 
<B>elt -&gt; t -&gt; elt option</B>

<P>
<P>
<B>find_opt x s</B>

returns the element of 
<B>s</B>

equal to 
<B>x</B>

(according
to 
<B>Ord.compare</B>

), or 
<B>None</B>

if no such element
exists.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val find_first </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; elt</B>

<P>
<P>
<B>find_first f s</B>

, where 
<B>f</B>

is a monotonically increasing function,
returns the lowest element 
<B>e</B>

of 
<B>s</B>

such that 
<B>f e</B>

,
or raises 
<B>Not_found</B>

if no such element exists.
<P>
For example, 
<B>find_first (fun e -&gt; Ord.compare e x &gt;= 0) s</B>

will return
the first element 
<B>e</B>

of 
<B>s</B>

where 
<B>Ord.compare e x &gt;= 0</B>

(intuitively:
<B>e &gt;= x</B>

), or raise 
<B>Not_found</B>

if 
<B>x</B>

is greater than any element of
<B>s</B>

.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val find_first_opt </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; elt option</B>

<P>
<P>
<B>find_first_opt f s</B>

, where 
<B>f</B>

is a monotonically increasing function,
returns an option containing the lowest element 
<B>e</B>

of 
<B>s</B>

such that
<B>f e</B>

, or 
<B>None</B>

if no such element exists.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val find_last </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; elt</B>

<P>
<P>
<B>find_last f s</B>

, where 
<B>f</B>

is a monotonically decreasing function,
returns the highest element 
<B>e</B>

of 
<B>s</B>

such that 
<B>f e</B>

,
or raises 
<B>Not_found</B>

if no such element exists.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val find_last_opt </I>

: 
<B>(elt -&gt; bool) -&gt; t -&gt; elt option</B>

<P>
<P>
<B>find_last_opt f s</B>

, where 
<B>f</B>

is a monotonically decreasing function,
returns an option containing the highest element 
<B>e</B>

of 
<B>s</B>

such that
<B>f e</B>

, or 
<B>None</B>

if no such element exists.
<P>
<P>
<B>Since</B>

4.05
<P>
<P>
<P>
<I>val of_list </I>

: 
<B>elt list -&gt; t</B>

<P>
<P>
<B>of_list l</B>

creates a set from a list of elements.
This is usually more efficient than folding 
<B>add</B>

over the list,
except perhaps for lists with many duplicated elements.
<P>
<P>
<B>Since</B>

4.02.0
<P>
<P>
<P>
<P>

<A NAME="lbAE">&nbsp;</A>
<H3>Iterators</H3>

<P>
<P>

<P>
<I>val to_seq_from </I>

: 
<B>elt -&gt; t -&gt; elt Seq.t</B>

<P>
<P>
<B>to_seq_from x s</B>

iterates on a subset of the elements of 
<B>s</B>

in ascending order, from 
<B>x</B>

or above.
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>
<I>val to_seq </I>

: 
<B>t -&gt; elt Seq.t</B>

<P>
Iterate on the whole set, in ascending order
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>
<I>val add_seq </I>

: 
<B>elt Seq.t -&gt; t -&gt; t</B>

<P>
Add the given elements to the set, in order.
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>
<I>val of_seq </I>

: 
<B>elt Seq.t -&gt; t</B>

<P>
Build a set from the given bindings
<P>
<P>
<B>Since</B>

4.07
<P>
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT id="1"><A HREF="#lbAB">NAME</A><DD>
<DT id="2"><A HREF="#lbAC">Module</A><DD>
<DT id="3"><A HREF="#lbAD">Documentation</A><DD>
<DL>
<DT id="4"><A HREF="#lbAE">Iterators</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 00:05:56 GMT, March 31, 2021
</BODY>
</HTML>
